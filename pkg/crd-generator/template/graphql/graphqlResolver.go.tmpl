package graph

import (
	"context"
	"encoding/json"
	"fmt"

	log "github.com/sirupsen/logrus"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/rest"

	qm "gitlab.eng.vmware.com/nsx-allspark_users/go-protos/pkg/query-manager"
	libgrpc "gitlab.eng.vmware.com/nsx-allspark_users/lib-go/grpc"
	nexus_client "{{.BaseImportPath}}nexus-client"
	"{{.BaseImportPath}}nexus-gql/graph/model"

)

var c resolverConfig
var nc *nexus_client.Clientset

type resolverConfig struct {
	{{ range  $key, $node := .Nodes }}{{ if $node.IsNexusNode }}v{{$node.PkgName}}{{$node.NodeName}} *nexus_client.{{$node.PkgName}}{{$node.NodeName}}
    {{ else }}{{ end }}{{ end }}
}

func getParentName(parentLabels map[string]interface{}, key string) string {
    if v, ok := parentLabels[key]; ok && v != nil {
	    return v.(string)
	}
	return ""
}

//////////////////////////////////////
// Nexus K8sAPIEndpointConfig
//////////////////////////////////////
func getK8sAPIEndpointConfig() *rest.Config {
	filePath := os.Getenv("KUBECONFIG")
	if filePath != "" {
		config, err := clientcmd.BuildConfigFromFlags("", filePath)
		if err != nil {
			return nil
		}
		return config
	}
	config, err := rest.InClusterConfig()
	if err != nil {
		return nil
	}
	return config
}

//////////////////////////////////////
// GRPC SERVER CONFIG
//////////////////////////////////////
func grpcServer() qm.ServerClient{
	addr := "localhost:45781"
	conn, err := libgrpc.ClientConn(addr, libgrpc.Config{})
	if err != nil {
		fmt.Printf("Failed to connect to query-manager server, err: %v", err)
	}
	return qm.NewServerClient(conn)
}
{{ range $key, $node := .Nodes }}
{{ if $node.IsParentNode }}
{{ if $node.IsSingletonNode }}
//////////////////////////////////////
// Singleton Resolver for Parent Node
// PKG: {{$node.PkgName}}, NODE: {{$node.PkgName}}
//////////////////////////////////////
func (c *resolverConfig) getRootResolver() (*model.{{$node.PkgName}}{{$node.NodeName}}, error) {
	k8sApiConfig := getK8sAPIEndpointConfig()
	nexusClient, err := nexus_client.NewForConfig(k8sApiConfig)
	if err != nil {
        return nil, fmt.Errorf("failed to get k8s client config: %s", err)
	}
	nc = nexusClient
	v{{$node.NodeName}}, err := nc.Get{{$node.PkgName}}{{$node.NodeName}}(context.TODO())
	if err != nil {
	    log.Errorf("Error getting root node %s", err)
        return nil, nil
	}
	c.v{{$node.PkgName}}{{$node.NodeName}} = v{{$node.NodeName}}
	{{ $node.Alias }}
	{{ $node.ReturnType }}
	return ret, nil
}{{ else }}
//////////////////////////////////////
// Non Singleton Resolver for Parent Node
// PKG: {{$node.PkgName}}, NODE: {{$node.PkgName}}
//////////////////////////////////////
func (c *resolverConfig) getRootResolver(id *string) ([]*model.{{$node.PkgName}}{{$node.NodeName}}, error) {
	k8sApiConfig := getK8sAPIEndpointConfig()
	nexusClient, err := nexus_client.NewForConfig(k8sApiConfig)
	if err != nil {
		return nil, fmt.Errorf("failed to get k8s client config: %s", err)
	}
	nc = nexusClient
	var v{{$node.NodeName}}List []*model.{{$node.PkgName}}{{$node.NodeName}}
	if id != nil && *id != "" {
		v{{$node.NodeName}}, err := nc.Get{{$node.PkgName}}{{$node.NodeName}}(context.TODO(), *id)
		if err != nil {
			log.Errorf("Error getting root node %s", err)
			return nil, nil
		}
		c.v{{$node.PkgName}}{{$node.NodeName}} = v{{$node.NodeName}}
		{{ $node.Alias }}
		{{ $node.ReturnType }}
		v{{$node.NodeName}}List = append(v{{$node.NodeName}}List, ret)
		return v{{$node.NodeName}}List, nil
	}
	v{{$node.NodeName}}ListObj, err := nc.{{$node.NodeName}}().List{{$node.GroupResourceNameTitle}}(context.TODO(), metav1.ListOptions{})
	for _,i := range v{{$node.NodeName}}ListObj{
		v{{$node.NodeName}}, err := nc.Get{{$node.PkgName}}{{$node.NodeName}}(context.TODO(), i.DisplayName())
		if err != nil {
			log.Errorf("Error getting root node %s", err)
			continue
		}
		c.v{{$node.PkgName}}{{$node.NodeName}} = v{{$node.NodeName}}
		{{ $node.Alias }}
		{{ $node.ReturnType }}
		v{{$node.NodeName}}List = append(v{{$node.NodeName}}List, ret)
	}
	return v{{$node.NodeName}}List, nil
}
{{ end }}{{end}}
{{ if $node.IsNexusNode }}
//////////////////////////////////////
// CustomQuery Resolver for Node: {{$node.NodeName}} in PKG: {{$node.PkgName}}
//////////////////////////////////////

// Resolver for queryServiceTable
func (c *resolverConfig) get{{$node.PkgName}}{{$node.NodeName}}queryServiceTableResolver(obj *model.{{$node.PkgName}}{{$node.NodeName}}, startTime *string, endTime *string, systemServices *bool, showGateways *bool, groupby *string, noMetrics *bool) (*model.TimeSeriesData,error) {
	ctx := context.Background()
	var filters = make(map[string]string)
	filters[""] = ""
	resp, err := grpcServer().GetMetrics(ctx, &qm.MetricArg{QueryType: "/ServiceTable", StartTime: *startTime, EndTime: *endTime, Metric: "", Filters: filters,TimeInterval: ""})
	if err != nil {
		fmt.Printf("Failed to getMetrics, err: %v", err)
	}
	b, _ := json.Marshal(resp.Data)
	data := string(b)
	ret := &model.TimeSeriesData{
		Data: &data,
	}
	return ret,nil
}

// Resolver for queryServiceVersionTable
func (c *resolverConfig) get{{$node.PkgName}}{{$node.NodeName}}queryServiceVersionTableResolver(obj *model.{{$node.PkgName}}{{$node.NodeName}}, startTime *string, endTime *string, systemServices *bool, showGateways *bool, noMetrics *bool) (*model.TimeSeriesData,error) {
	ctx := context.Background()
	var filters = make(map[string]string)
	filters[""] = ""
	resp, err := grpcServer().GetMetrics(ctx, &qm.MetricArg{QueryType: "/ServiceTable", StartTime: *startTime, EndTime: *endTime, Metric: "", Filters: filters,TimeInterval: ""})
	if err != nil {
		fmt.Printf("Failed to getMetrics, err: %v", err)
	}
	b, _ := json.Marshal(resp.Data)
	data := string(b)
	ret := &model.TimeSeriesData{
		Data: &data,
	}
	return ret,nil
}

// Resolver for queryServiceTS
func (c *resolverConfig) get{{$node.PkgName}}{{$node.NodeName}}queryServiceTSResolver(obj *model.{{$node.PkgName}}{{$node.NodeName}}, svcMetric *string, startTime *string, endTime *string, timeInterval *string) (*model.TimeSeriesData,error) {
	ctx := context.Background()
	var filters = make(map[string]string)
	filters[""] = ""
	resp, err := grpcServer().GetMetrics(ctx, &qm.MetricArg{QueryType: "/ServiceMetricSeries", StartTime: *startTime, EndTime: *endTime, Metric: *svcMetric, Filters: filters,TimeInterval: *timeInterval})
	if err != nil {
		fmt.Printf("Failed to getMetrics, err: %v", err)
	}
	b, _ := json.Marshal(resp.Data)
	data := string(b)
	ret := &model.TimeSeriesData{
		Data: &data,
	}
	return ret,nil
}

// Resolver for queryIncomingAPIs
func (c *resolverConfig) get{{$node.PkgName}}{{$node.NodeName}}queryIncomingAPIsResolver(obj *model.{{$node.PkgName}}{{$node.NodeName}}, startTime *string, endTime *string, destinationService *string, destinationServiceVersion *string, timeInterval *string, timeZone *string) (*model.TimeSeriesData,error) {
	ctx := context.Background()
	var filters = make(map[string]string)
	filters[""] = ""
	resp, err := grpcServer().GetMetrics(ctx, &qm.MetricArg{QueryType: "/IncomingAPIs", StartTime: *startTime, EndTime: *endTime, Metric: "", Filters: filters,TimeInterval: *timeInterval})
	if err != nil {
		fmt.Printf("Failed to getMetrics, err: %v", err)
	}
	b, _ := json.Marshal(resp.Data)
	data := string(b)
	ret := &model.TimeSeriesData{
		Data: &data,
	}
	return ret,nil
}

// Resolver for queryOutgoingAPIs
func (c *resolverConfig) get{{$node.PkgName}}{{$node.NodeName}}queryOutgoingAPIsResolver(obj *model.{{$node.PkgName}}{{$node.NodeName}}, startTime *string, endTime *string, timeInterval *string, timeZone *string) (*model.TimeSeriesData,error) {
	ctx := context.Background()
	var filters = make(map[string]string)
	filters[""] = ""
	resp, err := grpcServer().GetMetrics(ctx, &qm.MetricArg{QueryType: "/OutgoingAPIs", StartTime: *startTime, EndTime: *endTime, Metric: "", Filters: filters,TimeInterval: *timeInterval})
	if err != nil {
		fmt.Printf("Failed to getMetrics, err: %v", err)
	}
	b, _ := json.Marshal(resp.Data)
	data := string(b)
	ret := &model.TimeSeriesData{
		Data: &data,
	}
	return ret,nil
}

// Resolver for queryIncomingTCP
func (c *resolverConfig) get{{$node.PkgName}}{{$node.NodeName}}queryIncomingTCPResolver(obj *model.{{$node.PkgName}}{{$node.NodeName}}, startTime *string, endTime *string, destinationService *string, destinationServiceVersion *string) (*model.TimeSeriesData,error) {
	ctx := context.Background()
	var filters = make(map[string]string)
	filters[""] = ""
	resp, err := grpcServer().GetMetrics(ctx, &qm.MetricArg{QueryType: "/IncomingTCP", StartTime: *startTime, EndTime: *endTime, Metric: "", Filters: filters,TimeInterval: ""})
	if err != nil {
		fmt.Printf("Failed to getMetrics, err: %v", err)
	}
	b, _ := json.Marshal(resp.Data)
	data := string(b)
	ret := &model.TimeSeriesData{
		Data: &data,
	}
	return ret,nil
}

// Resolver for queryOutgoingTCP
func (c *resolverConfig) get{{$node.PkgName}}{{$node.NodeName}}queryOutgoingTCPResolver(obj *model.{{$node.PkgName}}{{$node.NodeName}}, startTime *string, endTime *string, destinationService *string, destinationServiceVersion *string) (*model.TimeSeriesData,error) {
	ctx := context.Background()
	var filters = make(map[string]string)
	filters[""] = ""
	resp, err := grpcServer().GetMetrics(ctx, &qm.MetricArg{QueryType: "/OutgoingTCP", StartTime: *startTime, EndTime: *endTime, Metric: "", Filters: filters,TimeInterval: ""})
	if err != nil {
		fmt.Printf("Failed to getMetrics, err: %v", err)
	}
	b, _ := json.Marshal(resp.Data)
	data := string(b)
	ret := &model.TimeSeriesData{
		Data: &data,
	}
	return ret,nil
}

// Resolver for queryServiceTopology
func (c *resolverConfig) get{{$node.PkgName}}{{$node.NodeName}}queryServiceTopologyResolver(obj *model.{{$node.PkgName}}{{$node.NodeName}}, startTime *string, endTime *string, metricStringArray *string) (*model.TimeSeriesData,error) {
	ctx := context.Background()
	var filters = make(map[string]string)
	filters[""] = ""
	resp, err := grpcServer().GetMetrics(ctx, &qm.MetricArg{QueryType: "/ServiceTopology", StartTime: *startTime, EndTime: *endTime, Metric: *metricStringArray, Filters: filters,TimeInterval: ""})
	if err != nil {
		fmt.Printf("Failed to getMetrics, err: %v", err)
	}
	b, _ := json.Marshal(resp.Data)
	data := string(b)
	ret := &model.TimeSeriesData{
		Data: &data,
	}
	return ret,nil
}
{{ range $key, $query := $node.CustomQueries }}
// Custom query
func (c *resolverConfig) get{{$node.PkgName}}{{$node.NodeName}}{{$query.Name}}(obj *model.{{$node.PkgName}}{{$node.NodeName}}, {{ range $key, $arg := $query.Args }} {{$arg.Name}} *{{$arg.Type}}, {{ end }}) (*model.TimeSeriesData,error) {
	// TODO FILL me
	return nil, nil
}{{ end }}
{{ end }}{{ end }}
{{ range $key, $node := .Nodes }}{{ range $key, $child := $node.ChildFields }}{{ if $child.IsSingleton }}
//////////////////////////////////////
// CHILD RESOLVER (Singleton)
// FieldName: {{$child.FieldName}} Node: {{$child.NodeName}} PKG: {{$child.PkgName}}
//////////////////////////////////////
func (c *resolverConfig) get{{$child.PkgName}}{{$child.NodeName}}{{$child.FieldName}}Resolver(obj *model.{{$child.PkgName}}{{$child.NodeName}}) (*model.{{$child.FieldTypePkgPath}}, error) {
	v{{$child.BaseTypeName}}, err := {{$child.ChainAPI}}.Get{{$child.FieldName}}(context.TODO())
	if err != nil {
	    log.Errorf("Error getting node %s", err)
        return &model.{{$child.FieldTypePkgPath}}{}, nil
    }
	c.v{{$child.FieldTypePkgPath}} = v{{$child.BaseTypeName}}
	{{ $child.Alias }}
    for k, v := range obj.ParentLabels {
        parentLabels[k] = v
    }
	{{ $child.ReturnType }}
	return ret, nil
}{{ else }}
//////////////////////////////////////
// CHILD RESOLVER (Non Singleton)
// FieldName: {{$child.FieldName}} Node: {{$child.NodeName}} PKG: {{$child.PkgName}}
//////////////////////////////////////
func (c *resolverConfig) get{{$child.PkgName}}{{$child.NodeName}}{{$child.FieldName}}Resolver(obj *model.{{$child.PkgName}}{{$child.NodeName}}, id *string) (*model.{{$child.FieldTypePkgPath}}, error) {
	if id != nil && *id != "" {
		v{{$child.BaseTypeName}}, err := {{$child.ChainAPI}}.Get{{$child.FieldName}}(context.TODO(), *id)
		if err != nil {
			log.Errorf("Error getting node %s", err)
			return &model.{{$child.FieldTypePkgPath}}{}, nil
		}
		c.v{{$child.FieldTypePkgPath}} = v{{$child.BaseTypeName}}
		{{ $child.Alias }}
		for k, v := range obj.ParentLabels {
			parentLabels[k] = v
		}
		{{ $child.ReturnType }}
		return ret, nil
	}
	v{{$child.BaseTypeName}}Parent, err := {{$child.LinkAPI}}
	if err != nil {
	    log.Errorf("Error getting Parent node details %s", err)
        return &model.{{$child.FieldTypePkgPath}}{}, nil
    }
	v{{$child.BaseTypeName}}, err := v{{$child.BaseTypeName}}Parent.Get{{$child.FieldName}}(context.TODO())
	if err != nil {
	    log.Errorf("Error getting node %s", err)
        return &model.{{$child.FieldTypePkgPath}}{}, nil
    }
	c.v{{$child.FieldTypePkgPath}} = v{{$child.BaseTypeName}}
	{{ $child.Alias }}
    for k, v := range obj.ParentLabels {
        parentLabels[k] = v
    }
	{{ $child.ReturnType }}
	return ret, nil
}{{ end }}{{ end }}
{{ range $key, $link := $node.LinkFields }}
//////////////////////////////////////
// LINK RESOLVER
// FieldName: {{$link.FieldName}} Node: {{$link.NodeName}} PKG: {{$link.PkgName}}
//////////////////////////////////////
func (c *resolverConfig) get{{$link.PkgName}}{{$link.NodeName}}{{$link.FieldName}}Resolver(obj *model.{{$link.PkgName}}{{$link.NodeName}}) (*model.{{$link.FieldTypePkgPath}}, error) {
	v{{$link.BaseTypeName}}Parent, err := {{$link.LinkAPI}}
	if err != nil {
	    log.Errorf("Error getting Parent node details %s", err)
        return &model.{{$link.FieldTypePkgPath}}{}, nil
    }
	v{{$link.BaseTypeName}}, err := v{{$link.BaseTypeName}}Parent.Get{{$link.FieldName}}(context.TODO())
	if err != nil {
	    log.Errorf("Error getting node %s", err)
        return &model.{{$link.FieldTypePkgPath}}{}, nil
    }
	c.v{{$link.FieldTypePkgPath}} = v{{$link.BaseTypeName}}
	{{ $link.Alias }}
    for k, v := range obj.ParentLabels {
        parentLabels[k] = v
    }
	{{ $link.ReturnType }}
	return ret, nil
}{{ end }}
{{ range $key, $children := $node.ChildrenFields }}
//////////////////////////////////////
// CHILDREN RESOLVER
// FieldName: {{$children.FieldName}} Node: {{$children.NodeName}} PKG: {{$children.PkgName}}
//////////////////////////////////////
func (c *resolverConfig) get{{$children.PkgName}}{{$children.NodeName}}{{$children.FieldName}}Resolver(obj *model.{{$children.PkgName}}{{$children.NodeName}}, id *string) ([]*model.{{$children.FieldTypePkgPath}}, error) {
	var v{{$children.FieldTypePkgPath}}List []*model.{{$children.FieldTypePkgPath}}
	if id != nil && *id != "" {
		{{ if $children.IsSingleton }}v{{$children.BaseTypeName}}, err := {{$children.ChainAPI}}.Get{{$children.FieldName}}(context.TODO()){{ else }}v{{$children.BaseTypeName}}, err := {{$children.ChainAPI}}.Get{{$children.FieldName}}(context.TODO(), *id){{ end }}
		if err != nil {
	        log.Errorf("Error getting node %s", err)
            return v{{$children.FieldTypePkgPath}}List, nil
        }
		{{ $children.Alias }}
        for k, v := range obj.ParentLabels {
            parentLabels[k] = v
        }
		{{ $children.ReturnType }}
		v{{$children.FieldTypePkgPath}}List = append(v{{$children.FieldTypePkgPath}}List, ret)
		return v{{$children.FieldTypePkgPath}}List, nil
	}
	v{{$children.BaseTypeName}}Parent, err := {{$children.LinkAPI}}
	if err != nil {
	    log.Errorf("Error getting Parent node details %s", err)
        return v{{$children.FieldTypePkgPath}}List, nil
    }
	v{{$children.BaseTypeName}}AllObj, err := v{{$children.BaseTypeName}}Parent.GetAll{{$children.FieldName}}(context.TODO())
	if err != nil {
	    log.Errorf("Error getting node %s", err)
        return v{{$children.FieldTypePkgPath}}List, nil
    }
	for _, i := range v{{$children.BaseTypeName}}AllObj {
		{{ if $children.IsSingleton }}v{{$children.BaseTypeName}}, err := {{$children.ChainAPI}}.Get{{$children.FieldName}}(context.TODO()){{ else }}v{{$children.BaseTypeName}}, err := {{$children.ChainAPI}}.Get{{$children.FieldName}}(context.TODO(), i.DisplayName()){{ end }}
		if err != nil {
	        log.Errorf("Error getting node %s", err)
            continue
		}
		{{ $children.Alias }}
		 for k, v := range obj.ParentLabels {
             parentLabels[k] = v
         }
		{{ $children.ReturnType }}
		v{{$children.FieldTypePkgPath}}List = append(v{{$children.FieldTypePkgPath}}List, ret)
	}
	return v{{$children.FieldTypePkgPath}}List, nil
}{{ end }}
{{ range $key, $links := $node.LinksFields }}
//////////////////////////////////////
// LINKS RESOLVER
// FieldName: {{$links.FieldName}} Node: {{$links.NodeName}} PKG: {{$links.PkgName}}
//////////////////////////////////////
func (c *resolverConfig) get{{$links.PkgName}}{{$links.NodeName}}{{$links.FieldName}}Resolver(obj *model.{{$links.PkgName}}{{$links.NodeName}}, id *string) ([]*model.{{$links.FieldTypePkgPath}}, error) {
	var v{{$links.FieldTypePkgPath}}List []*model.{{$links.FieldTypePkgPath}}
	if id != nil && *id != "" {
		v{{$links.BaseTypeName}}Parent, err := {{$links.LinkAPI}}
		if err != nil {
			log.Errorf("Error getting Parent node details %s", err)
			return v{{$links.FieldTypePkgPath}}List, nil
		}
		v{{$links.BaseTypeName}}, err := v{{$links.BaseTypeName}}Parent.Get{{$links.FieldName}}(context.TODO(), *id)
		if err != nil {
			log.Errorf("Error getting node %s", err)
			return v{{$links.FieldTypePkgPath}}List, nil
		}
		{{ $links.Alias }}
        for k, v := range obj.ParentLabels {
            parentLabels[k] = v
        }
		{{ $links.ReturnType }}
		v{{$links.FieldTypePkgPath}}List = append(v{{$links.FieldTypePkgPath}}List, ret)
		return v{{$links.FieldTypePkgPath}}List, nil
	}
	v{{$links.BaseTypeName}}Parent, err := {{$links.LinkAPI}}
	if err != nil {
	    log.Errorf("Error getting Parent node details %s", err)
        return v{{$links.FieldTypePkgPath}}List, nil
    }
	v{{$links.BaseTypeName}}AllObj, err := v{{$links.BaseTypeName}}Parent.GetAll{{$links.FieldName}}(context.TODO())
	if err != nil {
	    log.Errorf("Error getting node %s", err)
        return v{{$links.FieldTypePkgPath}}List, nil
    }
	for _, i := range v{{$links.BaseTypeName}}AllObj {
		v{{$links.BaseTypeName}}Parent, err := {{$links.LinkAPI}}
		if err != nil {
			log.Errorf("Error getting Parent node details %s", err)
            continue
		}
		v{{$links.BaseTypeName}}, err := v{{$links.BaseTypeName}}Parent.Get{{$links.FieldName}}(context.TODO(), i.DisplayName())
		if err != nil {
			log.Errorf("Error getting node %s", err)
			continue
		}
		{{ $links.Alias }}
		 for k, v := range obj.ParentLabels {
             parentLabels[k] = v
         }
		{{ $links.ReturnType }}
		v{{$links.FieldTypePkgPath}}List = append(v{{$links.FieldTypePkgPath}}List, ret)
	}
	return v{{$links.FieldTypePkgPath}}List, nil
}{{ end }}{{ end }}
