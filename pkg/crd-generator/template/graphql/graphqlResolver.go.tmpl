package graph

import (
	"context"
	"encoding/json"
	"fmt"
	nexus_client "{{.BaseImportPath}}nexus-client"
	"{{.BaseImportPath}}nexus-gql/graph/model"

	qm "gitlab.eng.vmware.com/nsx-allspark_users/go-protos/pkg/query-manager"
	libgrpc "gitlab.eng.vmware.com/nsx-allspark_users/lib-go/grpc"
	"k8s.io/client-go/rest"
)

var c resolverConfig

type resolverConfig struct {
	{{ range  $key, $node := .Nodes }}{{ if $node.IsNexusNode }}v{{$node.PkgName}}{{$node.NodeName}} *nexus_client.{{$node.PkgName}}{{$node.NodeName}}
	{{ else }}{{ end }}{{ end }}
}

//////////////////////////////////////
// Nexus K8sAPIEndpointConfig
//////////////////////////////////////
func getK8sAPIEndpointConfig() *rest.Config {

	filePath := os.Getenv("KUBECONFIG")
	if filePath != "" {
		config, err := clientcmd.BuildConfigFromFlags("", filePath)
		if err != nil {
			return nil
		}
		return config
	}

	config, err := rest.InClusterConfig()
	if err != nil {
		return nil
	}

	return config
}

//////////////////////////////////////
// GRPC SERVER CONFIG
//////////////////////////////////////
func grpcServer() qm.ServerClient{
	addr := "localhost:45781"
	conn, err := libgrpc.ClientConn(addr, libgrpc.Config{})
	if err != nil {
		fmt.Printf("Failed to connect to query-manager server, err: %v", err)
	}
	return qm.NewServerClient(conn)
}
{{ range $key, $node := .Nodes }}{{ if $node.IsParentNode }}
//////////////////////////////////////
// Resolver for Parent Node: {{$node.PkgName}}
//////////////////////////////////////
func (c *resolverConfig) getRootResolver() (*model.{{$node.PkgName}}{{$node.NodeName}}, error) {
	k8sApiConfig := getK8sAPIEndpointConfig()
	nc, err := nexus_client.NewForConfig(k8sApiConfig)
	if err != nil {
		panic(err)
	}
	v{{$node.NodeName}}, err := nc.Get{{$node.PkgName}}{{$node.NodeName}}(context.TODO())
	if err != nil {
		panic(err)
	}
	c.v{{$node.PkgName}}{{$node.NodeName}} = v{{$node.NodeName}}
	{{ if $node.ReturnType }}
	{{ $node.Alias }}
	{{ $node.ReturnType }}
	return ret, nil{{ else }}
	ret := &model.{{$node.PkgName}}{{$node.NodeName}} {}
	return ret, nil{{ end }}
}
{{ if $node.IsNexusNode }}
//////////////////////////////////////
// CustomQuery Resolver for Node: {{$node.PkgName}}{{$node.NodeName}}
//////////////////////////////////////

// Resolver for queryServiceTable
func (c *resolverConfig) get{{$node.PkgName}}{{$node.NodeName}}queryServiceTableResolver(startTime *string, endTime *string, systemServices *bool, showGateways *bool, groupby *string, noMetrics *bool) (*model.TimeSeriesData,error) {
	ctx := context.Background()
	var filters = make(map[string]string)
	filters[""] = ""
	resp, err := grpcServer().GetMetrics(ctx, &qm.MetricArg{QueryType: "/ServiceTable", StartTime: *startTime, EndTime: *endTime, Metric: "", Filters: filters,TimeInterval: ""})
	if err != nil {
		fmt.Printf("Failed to getMetrics, err: %v", err)
	}
	b, _ := json.Marshal(resp.Data)
	data := string(b)
	ret := &model.TimeSeriesData{
		Data: &data,
	}
	return ret,nil
}

// Resolver for queryServiceVersionTable
func (c *resolverConfig) get{{$node.PkgName}}{{$node.NodeName}}queryServiceVersionTableResolver(startTime *string, endTime *string, systemServices *bool, showGateways *bool, noMetrics *bool) (*model.TimeSeriesData,error) {
	ctx := context.Background()
	var filters = make(map[string]string)
	filters[""] = ""
	resp, err := grpcServer().GetMetrics(ctx, &qm.MetricArg{QueryType: "/ServiceTable", StartTime: *startTime, EndTime: *endTime, Metric: "", Filters: filters,TimeInterval: ""})
	if err != nil {
		fmt.Printf("Failed to getMetrics, err: %v", err)
	}
	b, _ := json.Marshal(resp.Data)
	data := string(b)
	ret := &model.TimeSeriesData{
		Data: &data,
	}
	return ret,nil
}

// Resolver for queryServiceTS
func (c *resolverConfig) get{{$node.PkgName}}{{$node.NodeName}}queryServiceTSResolver(svcMetric *string, startTime *string, endTime *string, timeInterval *string) (*model.TimeSeriesData,error) {
	ctx := context.Background()
	var filters = make(map[string]string)
	filters[""] = ""
	resp, err := grpcServer().GetMetrics(ctx, &qm.MetricArg{QueryType: "/ServiceMetricSeries", StartTime: *startTime, EndTime: *endTime, Metric: *svcMetric, Filters: filters,TimeInterval: *timeInterval})
	if err != nil {
		fmt.Printf("Failed to getMetrics, err: %v", err)
	}
	b, _ := json.Marshal(resp.Data)
	data := string(b)
	ret := &model.TimeSeriesData{
		Data: &data,
	}
	return ret,nil
}

// Resolver for queryIncomingAPIs
func (c *resolverConfig) get{{$node.PkgName}}{{$node.NodeName}}queryIncomingAPIsResolver(startTime *string, endTime *string, destinationService *string, destinationServiceVersion *string, timeInterval *string, timeZone *string) (*model.TimeSeriesData,error) {
	ctx := context.Background()
	var filters = make(map[string]string)
	filters[""] = ""
	resp, err := grpcServer().GetMetrics(ctx, &qm.MetricArg{QueryType: "/IncomingAPIs", StartTime: *startTime, EndTime: *endTime, Metric: "", Filters: filters,TimeInterval: *timeInterval})
	if err != nil {
		fmt.Printf("Failed to getMetrics, err: %v", err)
	}
	b, _ := json.Marshal(resp.Data)
	data := string(b)
	ret := &model.TimeSeriesData{
		Data: &data,
	}
	return ret,nil
}

// Resolver for queryOutgoingAPIs
func (c *resolverConfig) get{{$node.PkgName}}{{$node.NodeName}}queryOutgoingAPIsResolver(startTime *string, endTime *string, timeInterval *string, timeZone *string) (*model.TimeSeriesData,error) {
	ctx := context.Background()
	var filters = make(map[string]string)
	filters[""] = ""
	resp, err := grpcServer().GetMetrics(ctx, &qm.MetricArg{QueryType: "/OutgoingAPIs", StartTime: *startTime, EndTime: *endTime, Metric: "", Filters: filters,TimeInterval: *timeInterval})
	if err != nil {
		fmt.Printf("Failed to getMetrics, err: %v", err)
	}
	b, _ := json.Marshal(resp.Data)
	data := string(b)
	ret := &model.TimeSeriesData{
		Data: &data,
	}
	return ret,nil
}

// Resolver for queryIncomingTCP
func (c *resolverConfig) get{{$node.PkgName}}{{$node.NodeName}}queryIncomingTCPResolver(startTime *string, endTime *string, destinationService *string, destinationServiceVersion *string) (*model.TimeSeriesData,error) {
	ctx := context.Background()
	var filters = make(map[string]string)
	filters[""] = ""
	resp, err := grpcServer().GetMetrics(ctx, &qm.MetricArg{QueryType: "/IncomingTCP", StartTime: *startTime, EndTime: *endTime, Metric: "", Filters: filters,TimeInterval: ""})
	if err != nil {
		fmt.Printf("Failed to getMetrics, err: %v", err)
	}
	b, _ := json.Marshal(resp.Data)
	data := string(b)
	ret := &model.TimeSeriesData{
		Data: &data,
	}
	return ret,nil
}

// Resolver for queryOutgoingTCP
func (c *resolverConfig) get{{$node.PkgName}}{{$node.NodeName}}queryOutgoingTCPResolver(startTime *string, endTime *string, destinationService *string, destinationServiceVersion *string) (*model.TimeSeriesData,error) {
	ctx := context.Background()
	var filters = make(map[string]string)
	filters[""] = ""
	resp, err := grpcServer().GetMetrics(ctx, &qm.MetricArg{QueryType: "/OutgoingTCP", StartTime: *startTime, EndTime: *endTime, Metric: "", Filters: filters,TimeInterval: ""})
	if err != nil {
		fmt.Printf("Failed to getMetrics, err: %v", err)
	}
	b, _ := json.Marshal(resp.Data)
	data := string(b)
	ret := &model.TimeSeriesData{
		Data: &data,
	}
	return ret,nil
}

// Resolver for queryServiceTopology
func (c *resolverConfig) get{{$node.PkgName}}{{$node.NodeName}}queryServiceTopologyResolver(startTime *string, endTime *string, metricStringArray *string) (*model.TimeSeriesData,error) {
	ctx := context.Background()
	var filters = make(map[string]string)
	filters[""] = ""
	resp, err := grpcServer().GetMetrics(ctx, &qm.MetricArg{QueryType: "/ServiceTopology", StartTime: *startTime, EndTime: *endTime, Metric: *metricStringArray, Filters: filters,TimeInterval: ""})
	if err != nil {
		fmt.Printf("Failed to getMetrics, err: %v", err)
	}
	b, _ := json.Marshal(resp.Data)
	data := string(b)
	ret := &model.TimeSeriesData{
		Data: &data,
	}
	return ret,nil
}
{{ end }}{{ end }}{{ end }}
{{ range $key, $node := .Nodes }}{{ range $key, $child := $node.ChildLinkFields }}
//////////////////////////////////////
// Child/Link Node : {{$child.FieldName}} {{$child.BaseTypeName}}
// Resolver for {{$child.NodeName}}
//////////////////////////////////////
func (c *resolverConfig) get{{$child.PkgName}}{{$child.NodeName}}{{$child.FieldName}}Resolver() (*model.{{$child.FieldTypePkgPath}}, error) {
	{{ if $child.ReturnType }}v{{$child.BaseTypeName}}, err := c.v{{$child.PkgName}}{{$child.NodeName}}.Get{{$child.FieldName}}(context.TODO())
	if err != nil {
		panic(err)
	}
	c.v{{$child.FieldTypePkgPath}} = v{{$child.BaseTypeName}}
	{{ $child.Alias }}
	{{ $child.ReturnType }}
	return ret, nil{{ else }}ret := &model.{{$child.FieldTypePkgPath}} {}
	return ret, nil{{ end }}
}
{{ end }}{{ range $key, $child := $node.ChildrenLinksFields }}
//////////////////////////////////////
// Children/Links Node : {{$child.FieldName}}
// Resolver for {{$child.NodeName}}
//////////////////////////////////////
func (c *resolverConfig) get{{$child.PkgName}}{{$child.NodeName}}{{$child.FieldName}}Resolver(id *string) ([]*model.{{$child.FieldTypePkgPath}}, error) {
	{{ if $child.ReturnType }}var v{{$child.FieldTypePkgPath}}List []*model.{{$child.FieldTypePkgPath}}
	if id != nil && *id != "" {
		v{{$child.BaseTypeName}}, err := c.v{{$child.PkgName}}{{$child.NodeName}}.Get{{$child.FieldName}}(context.TODO(), *id)
		if err != nil {
			panic(err)
		}
		{{ $child.Alias }}
		{{ $child.ReturnType }}
		v{{$child.FieldTypePkgPath}}List = append(v{{$child.FieldTypePkgPath}}List, ret)
		return v{{$child.FieldTypePkgPath}}List, nil
	}
	for i := range c.v{{$child.PkgName}}{{$child.NodeName}}.Spec.{{$child.FieldName}}Gvk {
		v{{$child.BaseTypeName}}, err := c.v{{$child.PkgName}}{{$child.NodeName}}.Get{{$child.FieldName}}(context.TODO(), i)
		if err != nil {
			panic(err)
		}
		{{ $child.Alias }}
		{{ $child.ReturnType }}
		v{{$child.FieldTypePkgPath}}List = append(v{{$child.FieldTypePkgPath}}List, ret)
	}
	return v{{$child.FieldTypePkgPath}}List, nil
	{{ else }}var v{{$child.FieldTypePkgPath}}List []*model.{{$child.FieldTypePkgPath}}
	if id != nil && *id != "" {
		ret := &model.{{$child.FieldTypePkgPath}}{
			Id: id,
		}
		v{{$child.FieldTypePkgPath}}List = append(v{{$child.FieldTypePkgPath}}List, ret)
		return v{{$child.FieldTypePkgPath}}List, nil
	}
	return v{{$child.FieldTypePkgPath}}List, nil{{ end }}
}
{{ end }}{{ range $key, $custom := $node.CustomFields }}
//////////////////////////////////////
// CustomField: {{$custom.FieldName}} of CustomType: {{$custom.NodeName}}
// Resolver for {{$custom.NodeName}}
//////////////////////////////////////
func (c *resolverConfig) get{{$custom.PkgName}}{{$custom.NodeName}}{{$custom.FieldName}}Resolver() (*model.{{$custom.FieldTypePkgPath}}, error) {
	{{ if $custom.ReturnType }}v{{$custom.PkgName}} := c.v{{$custom.PkgName}}{{$custom.NodeName}}
	{{ $custom.Alias }}
	{{ $custom.ReturnType }}
	return ret, nil{{ else }}ret := &model.{{$custom.FieldTypePkgPath}} {}
	return ret, nil{{ end }}
}{{ end }}{{ end }}