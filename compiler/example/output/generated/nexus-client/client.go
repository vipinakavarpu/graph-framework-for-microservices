// Code generated by nexus. DO NOT EDIT.

// Nexus client is a shim layer working over k8s API meant to simplify graph operation on nexus nodes.
// Features of nexus client:
// - create/get/update/delete/list of nexus nodes,
// - name hashing to avoid name collision between objects with same name but different parents,
// - ability to get, create and delete child of given parent object,
// - ability to add link and remove link to given object,
// - recursive delete of object and all it's children.
// To initialize client use NewForConfig function with Rest Config as a parameter. After that you can start using
// nexus client. You can check example in: https://gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/docs/-/tree/master/example/crudapp

package nexus_client

import (
	"context"
	"encoding/json"
	"sync"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	types "k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/rest"
	cache "k8s.io/client-go/tools/cache"

	baseClientset "nexustempmodule/client/clientset/versioned"
	fakeBaseClienset "nexustempmodule/client/clientset/versioned/fake"
	"nexustempmodule/common"
	"nexustempmodule/helper"

	baseglobaltsmtanzuvmwarecomv1 "nexustempmodule/apis/global.tsm.tanzu.vmware.com/v1"

	informerglobaltsmtanzuvmwarecomv1 "nexustempmodule/client/informers/externalversions/global.tsm.tanzu.vmware.com/v1"
)

type Clientset struct {
	baseClient  baseClientset.Interface
	globalTsmV1 *GlobalTsmV1
}

type subscription struct {
	informer cache.SharedIndexInformer
	stop     chan struct{}
}

// subscriptionMap will store crd string as key and value as subscription type,
// for example key="roots.orgchart.vmware.org" and value=subscription{}
var subscriptionMap = sync.Map{}

func subscribe(key string, informer cache.SharedIndexInformer) {
	s := subscription{
		informer: informer,
		stop:     make(chan struct{}),
	}
	go s.informer.Run(s.stop)
	subscriptionMap.Store(key, s)
}

func (c *Clientset) SubscribeAll() {
	var key string

	key = "accesstokens.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAccessTokenInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "acpconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewACPConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "additionalattributeses.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAdditionalAttributesInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "allsparkserviceses.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAllSparkServicesInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "annotations.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAnnotationInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "apidiscoveryrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewApiDiscoveryRTInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "apidiscoveries.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewApiDiscoveryInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "appfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAppFolderInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "appgroups.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAppGroupInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "apptemplateservicedefinitions.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAppTemplateServiceDefinitionInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "apptemplates.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAppTemplateInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "appusers.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAppUserInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "appversions.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAppVersionInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "apps.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAppInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "applicationinfos.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewApplicationInfoInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "attackdiscoveryrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAttackDiscoveryRTInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "attackdiscoveries.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAttackDiscoveryInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "authenticationpolicies.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAuthenticationPolicyInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "autoscalerfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAutoscalerFolderInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "autoscalerconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAutoscalerConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "autoscalers.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAutoscalerInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "autoscalercrs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAutoscalerCRInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "autoscalingpolicies.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAutoscalingPolicyInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "awsconnectors.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAwsConnectorInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "buckets.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewBucketInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "certificateauthorityrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewCertificateAuthorityRTInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "certificateauthorityconfigns.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewCertificateAuthorityConfigNInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "certificateconfigns.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewCertificateConfigNInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "certificaterequests.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewCertificateRequestInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "certificates.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewCertificateInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "clusterconfigfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewClusterConfigFolderInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "clusterconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewClusterConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "clusterfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewClusterFolderInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "clustersettingses.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewClusterSettingsInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "clusters.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewClusterInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "configmaps.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewConfigMapInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "configs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "connectionstatuses.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewConnectionStatusInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "datafolderdomainclusters.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDataFolderDomainClusterInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "datafolderdomainserviceversions.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDataFolderDomainServiceVersionInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "datafolderdomainservices.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDataFolderDomainServiceInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "datafolderdomains.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDataFolderDomainInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "datafolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDataFolderInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "datagroups.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDataGroupInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "datatemplates.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDataTemplateInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "databases.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDatabaseInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "dcregions.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDCRegionInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "dczones.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDCZoneInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "destinationrules.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDestinationRuleInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "directories.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDirectoryInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "dnsconfigfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDNSConfigFolderInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "dnsconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDNSConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "dnsprobeconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDNSProbeConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "dnsprobestatuses.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDNSProbeStatusInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "dnsprobesconfigfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDNSProbesConfigFolderInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "domainconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDomainConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "domains.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDomainInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "endpoints.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewEndpointsInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "envoyfilters.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewEnvoyFilterInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "externalaccountconfigns.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalAccountConfigNInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "externalauditstorages.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalAuditStorageInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "externaldnsconfigns.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalDNSConfigNInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "externaldnsinventoryhealthchecks.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalDNSInventoryHealthCheckInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "externaldnsinventoryprimarydomains.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalDNSInventoryPrimaryDomainInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "externaldnsinventoryrecords.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalDNSInventoryRecordInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "externaldnsinventoryzones.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalDNSInventoryZoneInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "externaldnsinventories.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalDNSInventoryInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "externaldnsruntimeendpoints.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalDNSRuntimeEndpointInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "externaldnsruntimeprimarydomains.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalDNSRuntimePrimaryDomainInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "externaldnsruntimes.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalDNSRuntimeInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "externaldnsruntimesubdomains.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalDNSRuntimeSubdomainInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "externallbconfigns.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalLBConfigNInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "externalplugincapabilities.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalPluginCapabilityInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "externalpluginconfigfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalPluginConfigFolderInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "externalpluginconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalPluginConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "externalplugininstanceconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalPluginInstanceConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "externalpluginmonitors.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalPluginMonitorInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "externalservicesrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalServicesRTInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "featureflags.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewFeatureFlagInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "gatewayconfiglistenercertificates.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGatewayConfigListenerCertificateInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGatewayConfigAdditionalListenersInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "gatewayconfiglistenerdestinationroutes.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGatewayConfigListenerDestinationRouteInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "gatewayconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGatewayConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "gateways.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGatewayInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "geodiscoveryrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGeoDiscoveryRTInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "geodiscoveries.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGeoDiscoveryInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "globalnses.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGlobalNsInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "globalregistrationservices.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGlobalRegistrationServiceInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "globalnamespaces.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGlobalNamespaceInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "gnsaccesscontrolpolicyrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGnsAccessControlPolicyRTInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "gnsaccesscontrolpolicies.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGnsAccessControlPolicyInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "gnsbindingrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGnsBindingRTInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "gnsendpointsconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGnsEndpointsConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "externalserviceconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalServiceConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "publicservicerouteconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewPublicServiceRouteConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "publicserviceconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewPublicServiceConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "gnsroutingconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGNSRoutingConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "gnsroutingruleconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGnsRoutingRuleConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "gnssegmentationpolicyrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGnsSegmentationPolicyRTInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "gnssegmentationpolicies.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGnsSegmentationPolicyInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "gnsserviceentryconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGnsServiceEntryConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "gnssvcgrouprts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGnsSvcGroupRTInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "gnssvcgroups.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGNSSvcGroupInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "sharedserviceconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSharedServiceConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "gnss.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGNSInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "haconfigv2s.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewHaConfigV2Informer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "haconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewHaConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "healthcheckconfigns.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewHealthCheckConfigNInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "hostconfigv2s.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewHostConfigV2Informer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "hostconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewHostConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "inboundauthenticationconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewInboundAuthenticationConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "inventories.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewInventoryInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "issuers.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewIssuerInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "jobconfigfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewJobConfigFolderInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "jobconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewJobConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "jobfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewJobFolderInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "jobs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewJobInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "knativeingresses.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewKnativeIngressInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "labelconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewLabelConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "localregistrationserviceclusters.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewLocalRegistrationServiceClusterInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "localregistrationserviceresources.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewLocalRegistrationServiceResourceInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "localregistrationservices.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewLocalRegistrationServiceInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "logfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewLogFolderInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "logs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewLogInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "networkattachmentdefinitionconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewNetworkAttachmentDefinitionConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "networkattachmentdefinitions.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewNetworkAttachmentDefinitionInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "nodedefinitions.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewNodeDefinitionInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "nodefolderclusters.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewNodeFolderClusterInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "nodefolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewNodeFolderInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "nodegroups.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewNodeGroupInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "nodestatuses.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewNodeStatusInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "nodetemplates.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewNodeTemplateInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "nodes.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewNodeInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "outboundauthenticationmodes.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewOutboundAuthenticationModeInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "peerauthentications.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewPeerAuthenticationInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "piidiscoveryrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewPiiDiscoveryRTInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "piidiscoveries.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewPiiDiscoveryInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "policyconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewPolicyConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "policytemplates.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewPolicyTemplateInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "accesscontrolpolicies.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAccessControlPolicyInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "progressiveupgrades.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewProgressiveUpgradeInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "progressiveupgradeconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewProgressiveUpgradeConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "progressiveupgradefolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewProgressiveUpgradeFolderInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "progressiveupgraderuntimes.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewProgressiveUpgradeRuntimeInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "projectconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewProjectConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "projectinventories.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewProjectInventoryInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "projectqueries.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewProjectQueryInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "projects.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewProjectInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "publicservicerts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewPublicServiceRTInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "remotegatewayserviceconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewRemoteGatewayServiceConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "resourcegrouprts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewResourceGroupRTInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "resourcegroups.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewResourceGroupInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "roots.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewRootInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "rpolicies.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewRPolicyInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "runtimes.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewRuntimeInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "schemaviolationdiscoveryrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSchemaViolationDiscoveryRTInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "gnsschemaviolationdiscoveries.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGnsSchemaViolationDiscoveryInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "secretrtconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSecretRTConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "secrethashes.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSecretHashInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "securitycontextconstraintsconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSecurityContextConstraintsConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "securitycontextconstraintses.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSecurityContextConstraintsInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "serviceconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "servicecronjobs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceCronJobInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "servicedaemonsets.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceDaemonSetInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "servicedeploymentcontainers.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceDeploymentContainerInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "servicedeployments.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceDeploymentInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "servicedirectoryentryconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceDirectoryEntryConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "servicedirectoryrtfolderentries.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceDirectoryRTFolderEntryInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "servicedirectoryrtfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceDirectoryRTFolderInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "servicedirectoryrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceDirectoryRTInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "servicedirectoryns.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceDirectoryNInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "serviceentryconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceEntryConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "serviceentries.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceEntryInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "svcgrouprts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSvcGroupRTInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "serviceinstancecontainers.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceInstanceContainerInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "serviceinstances.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceInstanceInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "servicejobs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceJobInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "servicelevelobjectivefolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceLevelObjectiveFolderInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "servicelevelobjectives.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceLevelObjectiveInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "servicereplicasets.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceReplicaSetInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "servicestatefulsets.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceStatefulSetInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "servicetemplateservicedefinitions.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceTemplateServiceDefinitionInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "servicetemplates.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceTemplateInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "serviceversionconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceVersionConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "metricmonitors.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewMetricMonitorInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "serviceversions.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceVersionInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "services.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "sloconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSloConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "sloserviceconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSloServiceConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "slofolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSLOFolderInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "federatedsloconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewFederatedSloConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "federatedsloserviceconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewFederatedSloServiceConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "slopolicies.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSLOPolicyInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "svcgroups.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSvcGroupInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "tables.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewTableInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "templategroups.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewTemplateGroupInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "templates.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewTemplateInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "tenantresources.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewTenantResourceInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "tenanttokens.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewTenantTokenInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "tenants.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewTenantInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "userdiscoveryrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewUserDiscoveryRTInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "userdiscoveries.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewUserDiscoveryInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "userfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewUserFolderInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "usergroups.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewUserGroupInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "userpreferences.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewUserPreferenceInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "users.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewUserInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "virtualservices.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewVirtualServiceInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "workloadentries.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewWorkloadEntryInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

}

func (c *Clientset) UnsubscribeAll() {
	subscriptionMap.Range(func(key, s interface{}) bool {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
		return true
	})
}

// NewForConfig returns Client which can be which can be used to connect to database
func NewForConfig(config *rest.Config) (*Clientset, error) {
	baseClient, err := baseClientset.NewForConfig(config)
	if err != nil {
		return nil, err
	}
	client := &Clientset{}
	client.baseClient = baseClient
	client.globalTsmV1 = newGlobalTsmV1(client)

	return client, nil
}

// NewFakeClient creates simple client which can be used for unit tests
func NewFakeClient() *Clientset {
	client := &Clientset{}
	client.baseClient = fakeBaseClienset.NewSimpleClientset()
	client.globalTsmV1 = newGlobalTsmV1(client)

	return client
}

type PatchOp struct {
	Op    string      `json:"op"`
	Path  string      `json:"path"`
	Value interface{} `json:"value,omitempty"`
}

type Patch []PatchOp

func (p Patch) Marshal() ([]byte, error) {
	return json.Marshal(p)
}

func (c *Clientset) Global() *GlobalTsmV1 {
	return c.globalTsmV1
}

type GlobalTsmV1 struct {
	client *Clientset
}

func newGlobalTsmV1(client *Clientset) *GlobalTsmV1 {
	return &GlobalTsmV1{
		client: client,
	}
}

// GetAccessTokenByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetAccessTokenByName(ctx context.Context, hashedName string) (*GlobalAccessToken, error) {
	key := "accesstokens.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.AccessToken)
		return &GlobalAccessToken{
			client:      group.client,
			AccessToken: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			AccessTokens().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalAccessToken{
			client:      group.client,
			AccessToken: result,
		}, nil
	}
}

// DeleteAccessTokenByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteAccessTokenByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AccessTokens().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		AccessTokens().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/accessTokenGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["userfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("userfolders.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		UserFolders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAccessTokenByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateAccessTokenByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AccessToken) (*GlobalAccessToken, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AccessTokens().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["userfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("userfolders.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"accessTokenGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"AccessToken\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		UserFolders().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalAccessToken{
		client:      group.client,
		AccessToken: result,
	}, nil
}

// UpdateAccessTokenByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateAccessTokenByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.AccessToken) (*GlobalAccessToken, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			AccessTokens().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueTtl :=
		objToUpdate.Spec.Ttl
	patchOpTtl := PatchOp{
		Op:    "replace",
		Path:  "/spec/ttl",
		Value: patchValueTtl,
	}
	patch = append(patch, patchOpTtl)

	patchValueCreated :=
		objToUpdate.Spec.Created
	patchOpCreated := PatchOp{
		Op:    "replace",
		Path:  "/spec/created",
		Value: patchValueCreated,
	}
	patch = append(patch, patchOpCreated)

	patchValueUserId :=
		objToUpdate.Spec.UserId
	patchOpUserId := PatchOp{
		Op:    "replace",
		Path:  "/spec/userId",
		Value: patchValueUserId,
	}
	patch = append(patch, patchOpUserId)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		AccessTokens().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalAccessToken{
		client:      group.client,
		AccessToken: result,
	}, nil
}

// ListAccessTokens returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListAccessTokens(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalAccessToken, err error) {
	key := "accesstokens.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalAccessToken, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.AccessToken)
			result[k] = &GlobalAccessToken{
				client:      group.client,
				AccessToken: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			AccessTokens().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalAccessToken, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalAccessToken{
				client:      group.client,
				AccessToken: &item,
			}
		}
	}
	return
}

type GlobalAccessToken struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.AccessToken
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalAccessToken) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteAccessTokenByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AccessToken = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalAccessToken) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateAccessTokenByName(ctx, obj.AccessToken)
	if err != nil {
		return err
	}
	obj.AccessToken = result.AccessToken
	return nil
}

func (obj *GlobalAccessToken) GetParent(ctx context.Context) (result *GlobalUserFolder, err error) {
	hashedName := helper.GetHashedName("userfolders.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["userfolders.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetUserFolderByName(ctx, hashedName)
}

type accesstokenGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *accesstokenGlobalTsmV1Chainer) Subscribe() {
	key := "accesstokens.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAccessTokenInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *accesstokenGlobalTsmV1Chainer) Unsubscribe() {
	key := "accesstokens.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *accesstokenGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "accesstokens.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetACPConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetACPConfigByName(ctx context.Context, hashedName string) (*GlobalACPConfig, error) {
	key := "acpconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ACPConfig)
		return &GlobalACPConfig{
			client:    group.client,
			ACPConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ACPConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalACPConfig{
			client:    group.client,
			ACPConfig: result,
		}, nil
	}
}

// DeleteACPConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteACPConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ACPConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ACPConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/policyConfigsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["accesscontrolpolicies.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("accesscontrolpolicies.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		AccessControlPolicies().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateACPConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateACPConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ACPConfig) (*GlobalACPConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.DestSvcGroupsGvk = nil
	objToCreate.Spec.SourceSvcGroupsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ACPConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["accesscontrolpolicies.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("accesscontrolpolicies.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"policyConfigsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ACPConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		AccessControlPolicies().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalACPConfig{
		client:    group.client,
		ACPConfig: result,
	}, nil
}

// UpdateACPConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateACPConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ACPConfig) (*GlobalACPConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ACPConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDisplayName :=
		objToUpdate.Spec.DisplayName
	patchOpDisplayName := PatchOp{
		Op:    "replace",
		Path:  "/spec/displayName",
		Value: patchValueDisplayName,
	}
	patch = append(patch, patchOpDisplayName)

	patchValueGns :=
		objToUpdate.Spec.Gns
	patchOpGns := PatchOp{
		Op:    "replace",
		Path:  "/spec/gns",
		Value: patchValueGns,
	}
	patch = append(patch, patchOpGns)

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	if objToUpdate.Spec.Tags != nil {
		patchValueTags :=
			objToUpdate.Spec.Tags
		patchOpTags := PatchOp{
			Op:    "replace",
			Path:  "/spec/tags",
			Value: patchValueTags,
		}
		patch = append(patch, patchOpTags)
	}

	patchValueProjectId :=
		objToUpdate.Spec.ProjectId
	patchOpProjectId := PatchOp{
		Op:    "replace",
		Path:  "/spec/projectId",
		Value: patchValueProjectId,
	}
	patch = append(patch, patchOpProjectId)

	patchValueDestGroups :=
		objToUpdate.Spec.DestGroups
	patchOpDestGroups := PatchOp{
		Op:    "replace",
		Path:  "/spec/destGroups",
		Value: patchValueDestGroups,
	}
	patch = append(patch, patchOpDestGroups)

	patchValueSourceGroups :=
		objToUpdate.Spec.SourceGroups
	patchOpSourceGroups := PatchOp{
		Op:    "replace",
		Path:  "/spec/sourceGroups",
		Value: patchValueSourceGroups,
	}
	patch = append(patch, patchOpSourceGroups)

	if objToUpdate.Spec.Conditions != nil {
		patchValueConditions :=
			objToUpdate.Spec.Conditions
		patchOpConditions := PatchOp{
			Op:    "replace",
			Path:  "/spec/conditions",
			Value: patchValueConditions,
		}
		patch = append(patch, patchOpConditions)
	}

	patchValueActions :=
		objToUpdate.Spec.Actions
	patchOpActions := PatchOp{
		Op:    "replace",
		Path:  "/spec/actions",
		Value: patchValueActions,
	}
	patch = append(patch, patchOpActions)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ACPConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalACPConfig{
		client:    group.client,
		ACPConfig: result,
	}, nil
}

// ListACPConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListACPConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalACPConfig, err error) {
	key := "acpconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalACPConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ACPConfig)
			result[k] = &GlobalACPConfig{
				client:    group.client,
				ACPConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ACPConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalACPConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalACPConfig{
				client:    group.client,
				ACPConfig: &item,
			}
		}
	}
	return
}

type GlobalACPConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ACPConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalACPConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteACPConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ACPConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalACPConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateACPConfigByName(ctx, obj.ACPConfig)
	if err != nil {
		return err
	}
	obj.ACPConfig = result.ACPConfig
	return nil
}

func (obj *GlobalACPConfig) GetParent(ctx context.Context) (result *GlobalAccessControlPolicy, err error) {
	hashedName := helper.GetHashedName("accesscontrolpolicies.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["accesscontrolpolicies.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetAccessControlPolicyByName(ctx, hashedName)
}

// GetAllDestSvcGroups returns all links of given type
func (obj *GlobalACPConfig) GetAllDestSvcGroups(ctx context.Context) (
	result []*GlobalSvcGroup, err error) {
	result = make([]*GlobalSvcGroup, 0, len(obj.Spec.DestSvcGroupsGvk))
	for _, v := range obj.Spec.DestSvcGroupsGvk {
		l, err := obj.client.Global().GetSvcGroupByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetDestSvcGroups returns link which has given displayName
func (obj *GlobalACPConfig) GetDestSvcGroups(ctx context.Context,
	displayName string) (result *GlobalSvcGroup, err error) {
	l, ok := obj.Spec.DestSvcGroupsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ACPConfig", "DestSvcGroups", displayName)
	}
	result, err = obj.client.Global().GetSvcGroupByName(ctx, l.Name)
	return
}

// LinkDestSvcGroups links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalACPConfig) LinkDestSvcGroups(ctx context.Context,
	linkToAdd *GlobalSvcGroup) error {

	payload := "{\"spec\": {\"destSvcGroupsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"SvcGroup\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ACPConfigs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ACPConfig = result
	return nil
}

// UnlinkDestSvcGroups unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalACPConfig) UnlinkDestSvcGroups(ctx context.Context,
	linkToRemove *GlobalSvcGroup) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/destSvcGroupsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ACPConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ACPConfig = result
	return nil

}

// GetAllSourceSvcGroups returns all links of given type
func (obj *GlobalACPConfig) GetAllSourceSvcGroups(ctx context.Context) (
	result []*GlobalSvcGroup, err error) {
	result = make([]*GlobalSvcGroup, 0, len(obj.Spec.SourceSvcGroupsGvk))
	for _, v := range obj.Spec.SourceSvcGroupsGvk {
		l, err := obj.client.Global().GetSvcGroupByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetSourceSvcGroups returns link which has given displayName
func (obj *GlobalACPConfig) GetSourceSvcGroups(ctx context.Context,
	displayName string) (result *GlobalSvcGroup, err error) {
	l, ok := obj.Spec.SourceSvcGroupsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ACPConfig", "SourceSvcGroups", displayName)
	}
	result, err = obj.client.Global().GetSvcGroupByName(ctx, l.Name)
	return
}

// LinkSourceSvcGroups links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalACPConfig) LinkSourceSvcGroups(ctx context.Context,
	linkToAdd *GlobalSvcGroup) error {

	payload := "{\"spec\": {\"sourceSvcGroupsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"SvcGroup\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ACPConfigs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ACPConfig = result
	return nil
}

// UnlinkSourceSvcGroups unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalACPConfig) UnlinkSourceSvcGroups(ctx context.Context,
	linkToRemove *GlobalSvcGroup) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/sourceSvcGroupsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ACPConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ACPConfig = result
	return nil

}

type acpconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *acpconfigGlobalTsmV1Chainer) Subscribe() {
	key := "acpconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewACPConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *acpconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "acpconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *acpconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "acpconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetAdditionalAttributesByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetAdditionalAttributesByName(ctx context.Context, hashedName string) (*GlobalAdditionalAttributes, error) {
	key := "additionalattributeses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.AdditionalAttributes)
		return &GlobalAdditionalAttributes{
			client:               group.client,
			AdditionalAttributes: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			AdditionalAttributeses().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalAdditionalAttributes{
			client:               group.client,
			AdditionalAttributes: result,
		}, nil
	}
}

// DeleteAdditionalAttributesByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteAdditionalAttributesByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AdditionalAttributeses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		AdditionalAttributeses().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/additionalAttributesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["services.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("services.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Services().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAdditionalAttributesByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateAdditionalAttributesByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AdditionalAttributes) (*GlobalAdditionalAttributes, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AdditionalAttributeses().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["services.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("services.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"additionalAttributesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"AdditionalAttributes\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Services().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalAdditionalAttributes{
		client:               group.client,
		AdditionalAttributes: result,
	}, nil
}

// UpdateAdditionalAttributesByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateAdditionalAttributesByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.AdditionalAttributes) (*GlobalAdditionalAttributes, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			AdditionalAttributeses().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueValue :=
		objToUpdate.Spec.Value
	patchOpValue := PatchOp{
		Op:    "replace",
		Path:  "/spec/value",
		Value: patchValueValue,
	}
	patch = append(patch, patchOpValue)

	patchValueContext :=
		objToUpdate.Spec.Context
	patchOpContext := PatchOp{
		Op:    "replace",
		Path:  "/spec/context",
		Value: patchValueContext,
	}
	patch = append(patch, patchOpContext)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		AdditionalAttributeses().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalAdditionalAttributes{
		client:               group.client,
		AdditionalAttributes: result,
	}, nil
}

// ListAdditionalAttributeses returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListAdditionalAttributeses(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalAdditionalAttributes, err error) {
	key := "additionalattributeses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalAdditionalAttributes, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.AdditionalAttributes)
			result[k] = &GlobalAdditionalAttributes{
				client:               group.client,
				AdditionalAttributes: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			AdditionalAttributeses().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalAdditionalAttributes, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalAdditionalAttributes{
				client:               group.client,
				AdditionalAttributes: &item,
			}
		}
	}
	return
}

type GlobalAdditionalAttributes struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.AdditionalAttributes
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalAdditionalAttributes) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteAdditionalAttributesByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AdditionalAttributes = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalAdditionalAttributes) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateAdditionalAttributesByName(ctx, obj.AdditionalAttributes)
	if err != nil {
		return err
	}
	obj.AdditionalAttributes = result.AdditionalAttributes
	return nil
}

func (obj *GlobalAdditionalAttributes) GetParent(ctx context.Context) (result *GlobalService, err error) {
	hashedName := helper.GetHashedName("services.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["services.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetServiceByName(ctx, hashedName)
}

type additionalattributesGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *additionalattributesGlobalTsmV1Chainer) Subscribe() {
	key := "additionalattributeses.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAdditionalAttributesInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *additionalattributesGlobalTsmV1Chainer) Unsubscribe() {
	key := "additionalattributeses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *additionalattributesGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "additionalattributeses.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetAllSparkServicesByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetAllSparkServicesByName(ctx context.Context, hashedName string) (*GlobalAllSparkServices, error) {
	key := "allsparkserviceses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.AllSparkServices)
		return &GlobalAllSparkServices{
			client:           group.client,
			AllSparkServices: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			AllSparkServiceses().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalAllSparkServices{
			client:           group.client,
			AllSparkServices: result,
		}, nil
	}
}

// DeleteAllSparkServicesByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteAllSparkServicesByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AllSparkServiceses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.GlobalRegistrationServiceGvk != nil {
		err := group.client.
			Global().
			DeleteGlobalRegistrationServiceByName(ctx, result.Spec.GlobalRegistrationServiceGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.LocalRegistrationServiceGvk != nil {
		err := group.client.
			Global().
			DeleteLocalRegistrationServiceByName(ctx, result.Spec.LocalRegistrationServiceGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.AwsConnectorGvk != nil {
		err := group.client.
			Global().
			DeleteAwsConnectorByName(ctx, result.Spec.AwsConnectorGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		AllSparkServiceses().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/allsparkServicesGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["runtimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAllSparkServicesByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateAllSparkServicesByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AllSparkServices) (*GlobalAllSparkServices, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.GlobalRegistrationServiceGvk = nil
	objToCreate.Spec.LocalRegistrationServiceGvk = nil
	objToCreate.Spec.AwsConnectorGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AllSparkServiceses().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["runtimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/allsparkServicesGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "AllSparkServices",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalAllSparkServices{
		client:           group.client,
		AllSparkServices: result,
	}, nil
}

// UpdateAllSparkServicesByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateAllSparkServicesByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.AllSparkServices) (*GlobalAllSparkServices, error) {
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			AllSparkServiceses().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		AllSparkServiceses().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalAllSparkServices{
		client:           group.client,
		AllSparkServices: result,
	}, nil
}

// ListAllSparkServiceses returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListAllSparkServiceses(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalAllSparkServices, err error) {
	key := "allsparkserviceses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalAllSparkServices, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.AllSparkServices)
			result[k] = &GlobalAllSparkServices{
				client:           group.client,
				AllSparkServices: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			AllSparkServiceses().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalAllSparkServices, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalAllSparkServices{
				client:           group.client,
				AllSparkServices: &item,
			}
		}
	}
	return
}

type GlobalAllSparkServices struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.AllSparkServices
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalAllSparkServices) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteAllSparkServicesByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AllSparkServices = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalAllSparkServices) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateAllSparkServicesByName(ctx, obj.AllSparkServices)
	if err != nil {
		return err
	}
	obj.AllSparkServices = result.AllSparkServices
	return nil
}

func (obj *GlobalAllSparkServices) GetParent(ctx context.Context) (result *GlobalRuntime, err error) {
	hashedName := helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["runtimes.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetRuntimeByName(ctx, hashedName)
}

// GetGlobalRegistrationService returns child of given type
func (obj *GlobalAllSparkServices) GetGlobalRegistrationService(ctx context.Context) (
	result *GlobalGlobalRegistrationService, err error) {
	if obj.Spec.GlobalRegistrationServiceGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.AllSparkServices", "GlobalRegistrationService")
	}
	return obj.client.Global().GetGlobalRegistrationServiceByName(ctx, obj.Spec.GlobalRegistrationServiceGvk.Name)
}

// AddGlobalRegistrationService calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalAllSparkServices) AddGlobalRegistrationService(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GlobalRegistrationService) (result *GlobalGlobalRegistrationService, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["allsparkserviceses.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["allsparkserviceses.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGlobalRegistrationServiceByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetAllSparkServicesByName(ctx, obj.GetName())
	if getErr == nil {
		obj.AllSparkServices = updatedObj.AllSparkServices
	}
	return
}

// DeleteGlobalRegistrationService calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalAllSparkServices) DeleteGlobalRegistrationService(ctx context.Context) (err error) {
	if obj.Spec.GlobalRegistrationServiceGvk != nil {
		err = obj.client.
			Global().DeleteGlobalRegistrationServiceByName(ctx, obj.Spec.GlobalRegistrationServiceGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetAllSparkServicesByName(ctx, obj.GetName())
	if err == nil {
		obj.AllSparkServices = updatedObj.AllSparkServices
	}
	return
}

// GetLocalRegistrationService returns child of given type
func (obj *GlobalAllSparkServices) GetLocalRegistrationService(ctx context.Context) (
	result *GlobalLocalRegistrationService, err error) {
	if obj.Spec.LocalRegistrationServiceGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.AllSparkServices", "LocalRegistrationService")
	}
	return obj.client.Global().GetLocalRegistrationServiceByName(ctx, obj.Spec.LocalRegistrationServiceGvk.Name)
}

// AddLocalRegistrationService calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalAllSparkServices) AddLocalRegistrationService(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.LocalRegistrationService) (result *GlobalLocalRegistrationService, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["allsparkserviceses.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["allsparkserviceses.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateLocalRegistrationServiceByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetAllSparkServicesByName(ctx, obj.GetName())
	if getErr == nil {
		obj.AllSparkServices = updatedObj.AllSparkServices
	}
	return
}

// DeleteLocalRegistrationService calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalAllSparkServices) DeleteLocalRegistrationService(ctx context.Context) (err error) {
	if obj.Spec.LocalRegistrationServiceGvk != nil {
		err = obj.client.
			Global().DeleteLocalRegistrationServiceByName(ctx, obj.Spec.LocalRegistrationServiceGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetAllSparkServicesByName(ctx, obj.GetName())
	if err == nil {
		obj.AllSparkServices = updatedObj.AllSparkServices
	}
	return
}

// GetAwsConnector returns child of given type
func (obj *GlobalAllSparkServices) GetAwsConnector(ctx context.Context) (
	result *GlobalAwsConnector, err error) {
	if obj.Spec.AwsConnectorGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.AllSparkServices", "AwsConnector")
	}
	return obj.client.Global().GetAwsConnectorByName(ctx, obj.Spec.AwsConnectorGvk.Name)
}

// AddAwsConnector calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalAllSparkServices) AddAwsConnector(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AwsConnector) (result *GlobalAwsConnector, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["allsparkserviceses.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["allsparkserviceses.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateAwsConnectorByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetAllSparkServicesByName(ctx, obj.GetName())
	if getErr == nil {
		obj.AllSparkServices = updatedObj.AllSparkServices
	}
	return
}

// DeleteAwsConnector calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalAllSparkServices) DeleteAwsConnector(ctx context.Context) (err error) {
	if obj.Spec.AwsConnectorGvk != nil {
		err = obj.client.
			Global().DeleteAwsConnectorByName(ctx, obj.Spec.AwsConnectorGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetAllSparkServicesByName(ctx, obj.GetName())
	if err == nil {
		obj.AllSparkServices = updatedObj.AllSparkServices
	}
	return
}

type allsparkservicesGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *allsparkservicesGlobalTsmV1Chainer) Subscribe() {
	key := "allsparkserviceses.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAllSparkServicesInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *allsparkservicesGlobalTsmV1Chainer) Unsubscribe() {
	key := "allsparkserviceses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *allsparkservicesGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "allsparkserviceses.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *allsparkservicesGlobalTsmV1Chainer) GlobalRegistrationService(name string) *globalregistrationserviceGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["globalregistrationservices.global.tsm.tanzu.vmware.com"] = name
	return &globalregistrationserviceGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGlobalRegistrationService calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *allsparkservicesGlobalTsmV1Chainer) GetGlobalRegistrationService(ctx context.Context, displayName string) (result *GlobalGlobalRegistrationService, err error) {
	hashedName := helper.GetHashedName("globalregistrationservices.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGlobalRegistrationServiceByName(ctx, hashedName)
}

// AddGlobalRegistrationService calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *allsparkservicesGlobalTsmV1Chainer) AddGlobalRegistrationService(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GlobalRegistrationService) (result *GlobalGlobalRegistrationService, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("globalregistrationservices.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGlobalRegistrationServiceByName(ctx, objToCreate)
}

// DeleteGlobalRegistrationService calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *allsparkservicesGlobalTsmV1Chainer) DeleteGlobalRegistrationService(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("globalregistrationservices.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGlobalRegistrationServiceByName(ctx, hashedName)
}

func (c *allsparkservicesGlobalTsmV1Chainer) LocalRegistrationService(name string) *localregistrationserviceGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["localregistrationservices.global.tsm.tanzu.vmware.com"] = name
	return &localregistrationserviceGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetLocalRegistrationService calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *allsparkservicesGlobalTsmV1Chainer) GetLocalRegistrationService(ctx context.Context, displayName string) (result *GlobalLocalRegistrationService, err error) {
	hashedName := helper.GetHashedName("localregistrationservices.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetLocalRegistrationServiceByName(ctx, hashedName)
}

// AddLocalRegistrationService calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *allsparkservicesGlobalTsmV1Chainer) AddLocalRegistrationService(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.LocalRegistrationService) (result *GlobalLocalRegistrationService, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("localregistrationservices.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateLocalRegistrationServiceByName(ctx, objToCreate)
}

// DeleteLocalRegistrationService calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *allsparkservicesGlobalTsmV1Chainer) DeleteLocalRegistrationService(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("localregistrationservices.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteLocalRegistrationServiceByName(ctx, hashedName)
}

func (c *allsparkservicesGlobalTsmV1Chainer) AwsConnector() *awsconnectorGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["awsconnectors.global.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &awsconnectorGlobalTsmV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetAwsConnector calculates hashed name of the object based on it's parents and returns the object
func (c *allsparkservicesGlobalTsmV1Chainer) GetAwsConnector(ctx context.Context) (result *GlobalAwsConnector, err error) {
	hashedName := helper.GetHashedName("awsconnectors.global.tsm.tanzu.vmware.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Global().GetAwsConnectorByName(ctx, hashedName)
}

// AddAwsConnector calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *allsparkservicesGlobalTsmV1Chainer) AddAwsConnector(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AwsConnector) (result *GlobalAwsConnector, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("awsconnectors.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateAwsConnectorByName(ctx, objToCreate)
}

// DeleteAwsConnector calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *allsparkservicesGlobalTsmV1Chainer) DeleteAwsConnector(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("awsconnectors.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteAwsConnectorByName(ctx, hashedName)
}

// GetAnnotationByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetAnnotationByName(ctx context.Context, hashedName string) (*GlobalAnnotation, error) {
	key := "annotations.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Annotation)
		return &GlobalAnnotation{
			client:     group.client,
			Annotation: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Annotations().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalAnnotation{
			client:     group.client,
			Annotation: result,
		}, nil
	}
}

// DeleteAnnotationByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteAnnotationByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Annotations().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Annotations().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/annotationsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["tenants.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("tenants.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Tenants().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAnnotationByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateAnnotationByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Annotation) (*GlobalAnnotation, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Annotations().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["tenants.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("tenants.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"annotationsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"Annotation\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Tenants().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalAnnotation{
		client:     group.client,
		Annotation: result,
	}, nil
}

// UpdateAnnotationByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateAnnotationByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Annotation) (*GlobalAnnotation, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Annotations().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueData :=
		objToUpdate.Spec.Data
	patchOpData := PatchOp{
		Op:    "replace",
		Path:  "/spec/data",
		Value: patchValueData,
	}
	patch = append(patch, patchOpData)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Annotations().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalAnnotation{
		client:     group.client,
		Annotation: result,
	}, nil
}

// ListAnnotations returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListAnnotations(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalAnnotation, err error) {
	key := "annotations.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalAnnotation, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Annotation)
			result[k] = &GlobalAnnotation{
				client:     group.client,
				Annotation: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Annotations().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalAnnotation, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalAnnotation{
				client:     group.client,
				Annotation: &item,
			}
		}
	}
	return
}

type GlobalAnnotation struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Annotation
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalAnnotation) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteAnnotationByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Annotation = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalAnnotation) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateAnnotationByName(ctx, obj.Annotation)
	if err != nil {
		return err
	}
	obj.Annotation = result.Annotation
	return nil
}

func (obj *GlobalAnnotation) GetParent(ctx context.Context) (result *GlobalTenant, err error) {
	hashedName := helper.GetHashedName("tenants.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["tenants.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetTenantByName(ctx, hashedName)
}

type annotationGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *annotationGlobalTsmV1Chainer) Subscribe() {
	key := "annotations.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAnnotationInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *annotationGlobalTsmV1Chainer) Unsubscribe() {
	key := "annotations.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *annotationGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "annotations.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetApiDiscoveryRTByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetApiDiscoveryRTByName(ctx context.Context, hashedName string) (*GlobalApiDiscoveryRT, error) {
	key := "apidiscoveryrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ApiDiscoveryRT)
		return &GlobalApiDiscoveryRT{
			client:         group.client,
			ApiDiscoveryRT: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ApiDiscoveryRTs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalApiDiscoveryRT{
			client:         group.client,
			ApiDiscoveryRT: result,
		}, nil
	}
}

// DeleteApiDiscoveryRTByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteApiDiscoveryRTByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ApiDiscoveryRTs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ApiDiscoveryRTs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/apiDiscoveryGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateApiDiscoveryRTByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateApiDiscoveryRTByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ApiDiscoveryRT) (*GlobalApiDiscoveryRT, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ApiDiscoveryRTs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"apiDiscoveryGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ApiDiscoveryRT\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalApiDiscoveryRT{
		client:         group.client,
		ApiDiscoveryRT: result,
	}, nil
}

// UpdateApiDiscoveryRTByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateApiDiscoveryRTByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ApiDiscoveryRT) (*GlobalApiDiscoveryRT, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ApiDiscoveryRTs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueGnsid :=
		objToUpdate.Spec.Gnsid
	patchOpGnsid := PatchOp{
		Op:    "replace",
		Path:  "/spec/gnsid",
		Value: patchValueGnsid,
	}
	patch = append(patch, patchOpGnsid)

	patchValueSelectors :=
		objToUpdate.Spec.Selectors
	patchOpSelectors := PatchOp{
		Op:    "replace",
		Path:  "/spec/selectors",
		Value: patchValueSelectors,
	}
	patch = append(patch, patchOpSelectors)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	patchValueCompressionEnabled :=
		objToUpdate.Spec.CompressionEnabled
	patchOpCompressionEnabled := PatchOp{
		Op:    "replace",
		Path:  "/spec/compressionEnabled",
		Value: patchValueCompressionEnabled,
	}
	patch = append(patch, patchOpCompressionEnabled)

	patchValueIsEndpointApiPrechecks :=
		objToUpdate.Spec.IsEndpointApiPrechecks
	patchOpIsEndpointApiPrechecks := PatchOp{
		Op:    "replace",
		Path:  "/spec/isEndpointApiPrechecks",
		Value: patchValueIsEndpointApiPrechecks,
	}
	patch = append(patch, patchOpIsEndpointApiPrechecks)

	patchValueProcessingToggles :=
		objToUpdate.Spec.ProcessingToggles
	patchOpProcessingToggles := PatchOp{
		Op:    "replace",
		Path:  "/spec/processingToggles",
		Value: patchValueProcessingToggles,
	}
	patch = append(patch, patchOpProcessingToggles)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ApiDiscoveryRTs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalApiDiscoveryRT{
		client:         group.client,
		ApiDiscoveryRT: result,
	}, nil
}

// ListApiDiscoveryRTs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListApiDiscoveryRTs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalApiDiscoveryRT, err error) {
	key := "apidiscoveryrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalApiDiscoveryRT, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ApiDiscoveryRT)
			result[k] = &GlobalApiDiscoveryRT{
				client:         group.client,
				ApiDiscoveryRT: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ApiDiscoveryRTs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalApiDiscoveryRT, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalApiDiscoveryRT{
				client:         group.client,
				ApiDiscoveryRT: &item,
			}
		}
	}
	return
}

type GlobalApiDiscoveryRT struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ApiDiscoveryRT
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalApiDiscoveryRT) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteApiDiscoveryRTByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ApiDiscoveryRT = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalApiDiscoveryRT) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateApiDiscoveryRTByName(ctx, obj.ApiDiscoveryRT)
	if err != nil {
		return err
	}
	obj.ApiDiscoveryRT = result.ApiDiscoveryRT
	return nil
}

func (obj *GlobalApiDiscoveryRT) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

type apidiscoveryrtGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *apidiscoveryrtGlobalTsmV1Chainer) Subscribe() {
	key := "apidiscoveryrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewApiDiscoveryRTInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *apidiscoveryrtGlobalTsmV1Chainer) Unsubscribe() {
	key := "apidiscoveryrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *apidiscoveryrtGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "apidiscoveryrts.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetApiDiscoveryByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetApiDiscoveryByName(ctx context.Context, hashedName string) (*GlobalApiDiscovery, error) {
	key := "apidiscoveries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ApiDiscovery)
		return &GlobalApiDiscovery{
			client:       group.client,
			ApiDiscovery: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ApiDiscoveries().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalApiDiscovery{
			client:       group.client,
			ApiDiscovery: result,
		}, nil
	}
}

// DeleteApiDiscoveryByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteApiDiscoveryByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ApiDiscoveries().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ApiDiscoveries().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/apiDiscoveryGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateApiDiscoveryByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateApiDiscoveryByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ApiDiscovery) (*GlobalApiDiscovery, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ApiDiscoveries().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"apiDiscoveryGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ApiDiscovery\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalApiDiscovery{
		client:       group.client,
		ApiDiscovery: result,
	}, nil
}

// UpdateApiDiscoveryByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateApiDiscoveryByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ApiDiscovery) (*GlobalApiDiscovery, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ApiDiscoveries().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ApiDiscoveries().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalApiDiscovery{
		client:       group.client,
		ApiDiscovery: result,
	}, nil
}

// ListApiDiscoveries returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListApiDiscoveries(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalApiDiscovery, err error) {
	key := "apidiscoveries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalApiDiscovery, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ApiDiscovery)
			result[k] = &GlobalApiDiscovery{
				client:       group.client,
				ApiDiscovery: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ApiDiscoveries().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalApiDiscovery, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalApiDiscovery{
				client:       group.client,
				ApiDiscovery: &item,
			}
		}
	}
	return
}

type GlobalApiDiscovery struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ApiDiscovery
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalApiDiscovery) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteApiDiscoveryByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ApiDiscovery = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalApiDiscovery) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateApiDiscoveryByName(ctx, obj.ApiDiscovery)
	if err != nil {
		return err
	}
	obj.ApiDiscovery = result.ApiDiscovery
	return nil
}

func (obj *GlobalApiDiscovery) GetParent(ctx context.Context) (result *GlobalGNS, err error) {
	hashedName := helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnss.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGNSByName(ctx, hashedName)
}

type apidiscoveryGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *apidiscoveryGlobalTsmV1Chainer) Subscribe() {
	key := "apidiscoveries.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewApiDiscoveryInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *apidiscoveryGlobalTsmV1Chainer) Unsubscribe() {
	key := "apidiscoveries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *apidiscoveryGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "apidiscoveries.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetAppFolderByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetAppFolderByName(ctx context.Context, hashedName string) (*GlobalAppFolder, error) {
	key := "appfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.AppFolder)
		return &GlobalAppFolder{
			client:    group.client,
			AppFolder: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			AppFolders().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalAppFolder{
			client:    group.client,
			AppFolder: result,
		}, nil
	}
}

// DeleteAppFolderByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteAppFolderByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AppFolders().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.AppGvk {
		err := group.client.
			Global().DeleteAppByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		AppFolders().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/appFolderGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["runtimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAppFolderByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateAppFolderByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AppFolder) (*GlobalAppFolder, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.AppGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AppFolders().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["runtimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/appFolderGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "AppFolder",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalAppFolder{
		client:    group.client,
		AppFolder: result,
	}, nil
}

// UpdateAppFolderByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateAppFolderByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.AppFolder) (*GlobalAppFolder, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			AppFolders().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		AppFolders().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalAppFolder{
		client:    group.client,
		AppFolder: result,
	}, nil
}

// ListAppFolders returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListAppFolders(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalAppFolder, err error) {
	key := "appfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalAppFolder, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.AppFolder)
			result[k] = &GlobalAppFolder{
				client:    group.client,
				AppFolder: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			AppFolders().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalAppFolder, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalAppFolder{
				client:    group.client,
				AppFolder: &item,
			}
		}
	}
	return
}

type GlobalAppFolder struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.AppFolder
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalAppFolder) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteAppFolderByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AppFolder = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalAppFolder) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateAppFolderByName(ctx, obj.AppFolder)
	if err != nil {
		return err
	}
	obj.AppFolder = result.AppFolder
	return nil
}

func (obj *GlobalAppFolder) GetParent(ctx context.Context) (result *GlobalRuntime, err error) {
	hashedName := helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["runtimes.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetRuntimeByName(ctx, hashedName)
}

// GetAllApp returns all children of given type
func (obj *GlobalAppFolder) GetAllApp(ctx context.Context) (
	result []*GlobalApp, err error) {
	result = make([]*GlobalApp, 0, len(obj.Spec.AppGvk))
	for _, v := range obj.Spec.AppGvk {
		l, err := obj.client.Global().GetAppByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetApp returns child which has given displayName
func (obj *GlobalAppFolder) GetApp(ctx context.Context,
	displayName string) (result *GlobalApp, err error) {
	l, ok := obj.Spec.AppGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.AppFolder", "App", displayName)
	}
	result, err = obj.client.Global().GetAppByName(ctx, l.Name)
	return
}

// AddApp calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalAppFolder) AddApp(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.App) (result *GlobalApp, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["appfolders.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["appfolders.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateAppByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetAppFolderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.AppFolder = updatedObj.AppFolder
	}
	return
}

// DeleteApp calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalAppFolder) DeleteApp(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.AppGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.AppFolder", "App", displayName)
	}
	err = obj.client.Global().DeleteAppByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetAppFolderByName(ctx, obj.GetName())
	if err == nil {
		obj.AppFolder = updatedObj.AppFolder
	}
	return
}

type appfolderGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *appfolderGlobalTsmV1Chainer) Subscribe() {
	key := "appfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAppFolderInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *appfolderGlobalTsmV1Chainer) Unsubscribe() {
	key := "appfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *appfolderGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "appfolders.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *appfolderGlobalTsmV1Chainer) App(name string) *appGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["apps.global.tsm.tanzu.vmware.com"] = name
	return &appGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetApp calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *appfolderGlobalTsmV1Chainer) GetApp(ctx context.Context, displayName string) (result *GlobalApp, err error) {
	hashedName := helper.GetHashedName("apps.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetAppByName(ctx, hashedName)
}

// AddApp calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *appfolderGlobalTsmV1Chainer) AddApp(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.App) (result *GlobalApp, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("apps.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateAppByName(ctx, objToCreate)
}

// DeleteApp calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *appfolderGlobalTsmV1Chainer) DeleteApp(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("apps.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteAppByName(ctx, hashedName)
}

// GetAppGroupByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetAppGroupByName(ctx context.Context, hashedName string) (*GlobalAppGroup, error) {
	key := "appgroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.AppGroup)
		return &GlobalAppGroup{
			client:   group.client,
			AppGroup: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			AppGroups().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalAppGroup{
			client:   group.client,
			AppGroup: result,
		}, nil
	}
}

// DeleteAppGroupByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteAppGroupByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AppGroups().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		AppGroups().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/appGroupsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["resourcegroups.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("resourcegroups.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ResourceGroups().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAppGroupByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateAppGroupByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AppGroup) (*GlobalAppGroup, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ServicesGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AppGroups().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["resourcegroups.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("resourcegroups.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"appGroupsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"AppGroup\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ResourceGroups().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalAppGroup{
		client:   group.client,
		AppGroup: result,
	}, nil
}

// UpdateAppGroupByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateAppGroupByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.AppGroup) (*GlobalAppGroup, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			AppGroups().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueRules :=
		objToUpdate.Spec.Rules
	patchOpRules := PatchOp{
		Op:    "replace",
		Path:  "/spec/rules",
		Value: patchValueRules,
	}
	patch = append(patch, patchOpRules)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		AppGroups().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalAppGroup{
		client:   group.client,
		AppGroup: result,
	}, nil
}

// ListAppGroups returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListAppGroups(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalAppGroup, err error) {
	key := "appgroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalAppGroup, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.AppGroup)
			result[k] = &GlobalAppGroup{
				client:   group.client,
				AppGroup: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			AppGroups().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalAppGroup, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalAppGroup{
				client:   group.client,
				AppGroup: &item,
			}
		}
	}
	return
}

type GlobalAppGroup struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.AppGroup
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalAppGroup) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteAppGroupByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AppGroup = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalAppGroup) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateAppGroupByName(ctx, obj.AppGroup)
	if err != nil {
		return err
	}
	obj.AppGroup = result.AppGroup
	return nil
}

func (obj *GlobalAppGroup) GetParent(ctx context.Context) (result *GlobalResourceGroup, err error) {
	hashedName := helper.GetHashedName("resourcegroups.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["resourcegroups.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetResourceGroupByName(ctx, hashedName)
}

// GetAllServices returns all links of given type
func (obj *GlobalAppGroup) GetAllServices(ctx context.Context) (
	result []*GlobalService, err error) {
	result = make([]*GlobalService, 0, len(obj.Spec.ServicesGvk))
	for _, v := range obj.Spec.ServicesGvk {
		l, err := obj.client.Global().GetServiceByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServices returns link which has given displayName
func (obj *GlobalAppGroup) GetServices(ctx context.Context,
	displayName string) (result *GlobalService, err error) {
	l, ok := obj.Spec.ServicesGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.AppGroup", "Services", displayName)
	}
	result, err = obj.client.Global().GetServiceByName(ctx, l.Name)
	return
}

// LinkServices links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalAppGroup) LinkServices(ctx context.Context,
	linkToAdd *GlobalService) error {

	payload := "{\"spec\": {\"servicesGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"Service\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().AppGroups().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.AppGroup = result
	return nil
}

// UnlinkServices unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalAppGroup) UnlinkServices(ctx context.Context,
	linkToRemove *GlobalService) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/servicesGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().AppGroups().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.AppGroup = result
	return nil

}

type appgroupGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *appgroupGlobalTsmV1Chainer) Subscribe() {
	key := "appgroups.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAppGroupInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *appgroupGlobalTsmV1Chainer) Unsubscribe() {
	key := "appgroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *appgroupGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "appgroups.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetAppTemplateServiceDefinitionByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetAppTemplateServiceDefinitionByName(ctx context.Context, hashedName string) (*GlobalAppTemplateServiceDefinition, error) {
	key := "apptemplateservicedefinitions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.AppTemplateServiceDefinition)
		return &GlobalAppTemplateServiceDefinition{
			client:                       group.client,
			AppTemplateServiceDefinition: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			AppTemplateServiceDefinitions().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalAppTemplateServiceDefinition{
			client:                       group.client,
			AppTemplateServiceDefinition: result,
		}, nil
	}
}

// DeleteAppTemplateServiceDefinitionByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteAppTemplateServiceDefinitionByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AppTemplateServiceDefinitions().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		AppTemplateServiceDefinitions().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceDefinitionsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["apptemplates.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("apptemplates.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		AppTemplates().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAppTemplateServiceDefinitionByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateAppTemplateServiceDefinitionByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AppTemplateServiceDefinition) (*GlobalAppTemplateServiceDefinition, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AppTemplateServiceDefinitions().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["apptemplates.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("apptemplates.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"serviceDefinitionsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"AppTemplateServiceDefinition\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		AppTemplates().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalAppTemplateServiceDefinition{
		client:                       group.client,
		AppTemplateServiceDefinition: result,
	}, nil
}

// UpdateAppTemplateServiceDefinitionByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateAppTemplateServiceDefinitionByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.AppTemplateServiceDefinition) (*GlobalAppTemplateServiceDefinition, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			AppTemplateServiceDefinitions().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueType :=
		objToUpdate.Spec.Type
	patchOpType := PatchOp{
		Op:    "replace",
		Path:  "/spec/type",
		Value: patchValueType,
	}
	patch = append(patch, patchOpType)

	patchValueVersion :=
		objToUpdate.Spec.Version
	patchOpVersion := PatchOp{
		Op:    "replace",
		Path:  "/spec/version",
		Value: patchValueVersion,
	}
	patch = append(patch, patchOpVersion)

	patchValueTemplate :=
		objToUpdate.Spec.Template
	patchOpTemplate := PatchOp{
		Op:    "replace",
		Path:  "/spec/template",
		Value: patchValueTemplate,
	}
	patch = append(patch, patchOpTemplate)

	if objToUpdate.Spec.TemplateArgs != nil {
		patchValueTemplateArgs :=
			objToUpdate.Spec.TemplateArgs
		patchOpTemplateArgs := PatchOp{
			Op:    "replace",
			Path:  "/spec/templateArgs",
			Value: patchValueTemplateArgs,
		}
		patch = append(patch, patchOpTemplateArgs)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		AppTemplateServiceDefinitions().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalAppTemplateServiceDefinition{
		client:                       group.client,
		AppTemplateServiceDefinition: result,
	}, nil
}

// ListAppTemplateServiceDefinitions returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListAppTemplateServiceDefinitions(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalAppTemplateServiceDefinition, err error) {
	key := "apptemplateservicedefinitions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalAppTemplateServiceDefinition, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.AppTemplateServiceDefinition)
			result[k] = &GlobalAppTemplateServiceDefinition{
				client:                       group.client,
				AppTemplateServiceDefinition: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			AppTemplateServiceDefinitions().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalAppTemplateServiceDefinition, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalAppTemplateServiceDefinition{
				client:                       group.client,
				AppTemplateServiceDefinition: &item,
			}
		}
	}
	return
}

type GlobalAppTemplateServiceDefinition struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.AppTemplateServiceDefinition
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalAppTemplateServiceDefinition) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteAppTemplateServiceDefinitionByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AppTemplateServiceDefinition = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalAppTemplateServiceDefinition) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateAppTemplateServiceDefinitionByName(ctx, obj.AppTemplateServiceDefinition)
	if err != nil {
		return err
	}
	obj.AppTemplateServiceDefinition = result.AppTemplateServiceDefinition
	return nil
}

func (obj *GlobalAppTemplateServiceDefinition) GetParent(ctx context.Context) (result *GlobalAppTemplate, err error) {
	hashedName := helper.GetHashedName("apptemplates.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["apptemplates.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetAppTemplateByName(ctx, hashedName)
}

type apptemplateservicedefinitionGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *apptemplateservicedefinitionGlobalTsmV1Chainer) Subscribe() {
	key := "apptemplateservicedefinitions.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAppTemplateServiceDefinitionInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *apptemplateservicedefinitionGlobalTsmV1Chainer) Unsubscribe() {
	key := "apptemplateservicedefinitions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *apptemplateservicedefinitionGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "apptemplateservicedefinitions.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetAppTemplateByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetAppTemplateByName(ctx context.Context, hashedName string) (*GlobalAppTemplate, error) {
	key := "apptemplates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.AppTemplate)
		return &GlobalAppTemplate{
			client:      group.client,
			AppTemplate: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			AppTemplates().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalAppTemplate{
			client:      group.client,
			AppTemplate: result,
		}, nil
	}
}

// DeleteAppTemplateByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteAppTemplateByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AppTemplates().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.ServiceDefinitionsGvk {
		err := group.client.
			Global().DeleteAppTemplateServiceDefinitionByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		AppTemplates().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/appTemplatesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["templategroups.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("templategroups.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		TemplateGroups().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAppTemplateByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateAppTemplateByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AppTemplate) (*GlobalAppTemplate, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ServiceDefinitionsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AppTemplates().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["templategroups.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("templategroups.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"appTemplatesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"AppTemplate\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		TemplateGroups().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalAppTemplate{
		client:      group.client,
		AppTemplate: result,
	}, nil
}

// UpdateAppTemplateByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateAppTemplateByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.AppTemplate) (*GlobalAppTemplate, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			AppTemplates().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueVersion :=
		objToUpdate.Spec.Version
	patchOpVersion := PatchOp{
		Op:    "replace",
		Path:  "/spec/version",
		Value: patchValueVersion,
	}
	patch = append(patch, patchOpVersion)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		AppTemplates().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalAppTemplate{
		client:      group.client,
		AppTemplate: result,
	}, nil
}

// ListAppTemplates returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListAppTemplates(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalAppTemplate, err error) {
	key := "apptemplates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalAppTemplate, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.AppTemplate)
			result[k] = &GlobalAppTemplate{
				client:      group.client,
				AppTemplate: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			AppTemplates().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalAppTemplate, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalAppTemplate{
				client:      group.client,
				AppTemplate: &item,
			}
		}
	}
	return
}

type GlobalAppTemplate struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.AppTemplate
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalAppTemplate) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteAppTemplateByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AppTemplate = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalAppTemplate) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateAppTemplateByName(ctx, obj.AppTemplate)
	if err != nil {
		return err
	}
	obj.AppTemplate = result.AppTemplate
	return nil
}

func (obj *GlobalAppTemplate) GetParent(ctx context.Context) (result *GlobalTemplateGroup, err error) {
	hashedName := helper.GetHashedName("templategroups.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["templategroups.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetTemplateGroupByName(ctx, hashedName)
}

// GetAllServiceDefinitions returns all children of given type
func (obj *GlobalAppTemplate) GetAllServiceDefinitions(ctx context.Context) (
	result []*GlobalAppTemplateServiceDefinition, err error) {
	result = make([]*GlobalAppTemplateServiceDefinition, 0, len(obj.Spec.ServiceDefinitionsGvk))
	for _, v := range obj.Spec.ServiceDefinitionsGvk {
		l, err := obj.client.Global().GetAppTemplateServiceDefinitionByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceDefinitions returns child which has given displayName
func (obj *GlobalAppTemplate) GetServiceDefinitions(ctx context.Context,
	displayName string) (result *GlobalAppTemplateServiceDefinition, err error) {
	l, ok := obj.Spec.ServiceDefinitionsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.AppTemplate", "ServiceDefinitions", displayName)
	}
	result, err = obj.client.Global().GetAppTemplateServiceDefinitionByName(ctx, l.Name)
	return
}

// AddServiceDefinitions calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalAppTemplate) AddServiceDefinitions(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AppTemplateServiceDefinition) (result *GlobalAppTemplateServiceDefinition, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["apptemplates.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["apptemplates.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateAppTemplateServiceDefinitionByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetAppTemplateByName(ctx, obj.GetName())
	if getErr == nil {
		obj.AppTemplate = updatedObj.AppTemplate
	}
	return
}

// DeleteServiceDefinitions calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalAppTemplate) DeleteServiceDefinitions(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ServiceDefinitionsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.AppTemplate", "ServiceDefinitions", displayName)
	}
	err = obj.client.Global().DeleteAppTemplateServiceDefinitionByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetAppTemplateByName(ctx, obj.GetName())
	if err == nil {
		obj.AppTemplate = updatedObj.AppTemplate
	}
	return
}

type apptemplateGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *apptemplateGlobalTsmV1Chainer) Subscribe() {
	key := "apptemplates.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAppTemplateInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *apptemplateGlobalTsmV1Chainer) Unsubscribe() {
	key := "apptemplates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *apptemplateGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "apptemplates.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *apptemplateGlobalTsmV1Chainer) ServiceDefinitions(name string) *apptemplateservicedefinitionGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["apptemplateservicedefinitions.global.tsm.tanzu.vmware.com"] = name
	return &apptemplateservicedefinitionGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetServiceDefinitions calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *apptemplateGlobalTsmV1Chainer) GetServiceDefinitions(ctx context.Context, displayName string) (result *GlobalAppTemplateServiceDefinition, err error) {
	hashedName := helper.GetHashedName("apptemplateservicedefinitions.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetAppTemplateServiceDefinitionByName(ctx, hashedName)
}

// AddServiceDefinitions calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *apptemplateGlobalTsmV1Chainer) AddServiceDefinitions(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AppTemplateServiceDefinition) (result *GlobalAppTemplateServiceDefinition, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("apptemplateservicedefinitions.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateAppTemplateServiceDefinitionByName(ctx, objToCreate)
}

// DeleteServiceDefinitions calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *apptemplateGlobalTsmV1Chainer) DeleteServiceDefinitions(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("apptemplateservicedefinitions.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteAppTemplateServiceDefinitionByName(ctx, hashedName)
}

// GetAppUserByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetAppUserByName(ctx context.Context, hashedName string) (*GlobalAppUser, error) {
	key := "appusers.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.AppUser)
		return &GlobalAppUser{
			client:  group.client,
			AppUser: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			AppUsers().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalAppUser{
			client:  group.client,
			AppUser: result,
		}, nil
	}
}

// DeleteAppUserByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteAppUserByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AppUsers().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		AppUsers().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/appUsersGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["userfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("userfolders.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		UserFolders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAppUserByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateAppUserByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AppUser) (*GlobalAppUser, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AppUsers().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["userfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("userfolders.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"appUsersGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"AppUser\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		UserFolders().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalAppUser{
		client:  group.client,
		AppUser: result,
	}, nil
}

// UpdateAppUserByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateAppUserByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.AppUser) (*GlobalAppUser, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			AppUsers().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		AppUsers().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalAppUser{
		client:  group.client,
		AppUser: result,
	}, nil
}

// ListAppUsers returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListAppUsers(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalAppUser, err error) {
	key := "appusers.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalAppUser, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.AppUser)
			result[k] = &GlobalAppUser{
				client:  group.client,
				AppUser: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			AppUsers().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalAppUser, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalAppUser{
				client:  group.client,
				AppUser: &item,
			}
		}
	}
	return
}

type GlobalAppUser struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.AppUser
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalAppUser) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteAppUserByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AppUser = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalAppUser) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateAppUserByName(ctx, obj.AppUser)
	if err != nil {
		return err
	}
	obj.AppUser = result.AppUser
	return nil
}

func (obj *GlobalAppUser) GetParent(ctx context.Context) (result *GlobalUserFolder, err error) {
	hashedName := helper.GetHashedName("userfolders.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["userfolders.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetUserFolderByName(ctx, hashedName)
}

type appuserGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *appuserGlobalTsmV1Chainer) Subscribe() {
	key := "appusers.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAppUserInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *appuserGlobalTsmV1Chainer) Unsubscribe() {
	key := "appusers.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *appuserGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "appusers.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetAppVersionByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetAppVersionByName(ctx context.Context, hashedName string) (*GlobalAppVersion, error) {
	key := "appversions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.AppVersion)
		return &GlobalAppVersion{
			client:     group.client,
			AppVersion: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			AppVersions().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalAppVersion{
			client:     group.client,
			AppVersion: result,
		}, nil
	}
}

// DeleteAppVersionByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteAppVersionByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AppVersions().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		AppVersions().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/versionGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["apps.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("apps.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Apps().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAppVersionByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateAppVersionByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AppVersion) (*GlobalAppVersion, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.TemplateGvk = nil
	objToCreate.Spec.InventoryGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AppVersions().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["apps.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("apps.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/versionGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "AppVersion",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Apps().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalAppVersion{
		client:     group.client,
		AppVersion: result,
	}, nil
}

// UpdateAppVersionByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateAppVersionByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.AppVersion) (*GlobalAppVersion, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			AppVersions().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		AppVersions().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalAppVersion{
		client:     group.client,
		AppVersion: result,
	}, nil
}

// ListAppVersions returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListAppVersions(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalAppVersion, err error) {
	key := "appversions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalAppVersion, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.AppVersion)
			result[k] = &GlobalAppVersion{
				client:     group.client,
				AppVersion: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			AppVersions().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalAppVersion, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalAppVersion{
				client:     group.client,
				AppVersion: &item,
			}
		}
	}
	return
}

type GlobalAppVersion struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.AppVersion
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalAppVersion) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteAppVersionByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AppVersion = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalAppVersion) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateAppVersionByName(ctx, obj.AppVersion)
	if err != nil {
		return err
	}
	obj.AppVersion = result.AppVersion
	return nil
}

func (obj *GlobalAppVersion) GetParent(ctx context.Context) (result *GlobalApp, err error) {
	hashedName := helper.GetHashedName("apps.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["apps.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetAppByName(ctx, hashedName)
}

// GetTemplate returns link of given type
func (obj *GlobalAppVersion) GetTemplate(ctx context.Context) (
	result *GlobalTemplate, err error) {
	if obj.Spec.TemplateGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.AppVersion", "Template")
	}
	return obj.client.Global().GetTemplateByName(ctx, obj.Spec.TemplateGvk.Name)
}

// LinkTemplate links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalAppVersion) LinkTemplate(ctx context.Context,
	linkToAdd *GlobalTemplate) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/templateGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "Template",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().AppVersions().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.AppVersion = result
	return nil
}

// UnlinkTemplate unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalAppVersion) UnlinkTemplate(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/templateGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().AppVersions().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.AppVersion = result
	return nil

}

// GetInventory returns link of given type
func (obj *GlobalAppVersion) GetInventory(ctx context.Context) (
	result *GlobalInventory, err error) {
	if obj.Spec.InventoryGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.AppVersion", "Inventory")
	}
	return obj.client.Global().GetInventoryByName(ctx, obj.Spec.InventoryGvk.Name)
}

// LinkInventory links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalAppVersion) LinkInventory(ctx context.Context,
	linkToAdd *GlobalInventory) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/inventoryGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "Inventory",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().AppVersions().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.AppVersion = result
	return nil
}

// UnlinkInventory unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalAppVersion) UnlinkInventory(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/inventoryGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().AppVersions().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.AppVersion = result
	return nil

}

type appversionGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *appversionGlobalTsmV1Chainer) Subscribe() {
	key := "appversions.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAppVersionInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *appversionGlobalTsmV1Chainer) Unsubscribe() {
	key := "appversions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *appversionGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "appversions.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetAppByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetAppByName(ctx context.Context, hashedName string) (*GlobalApp, error) {
	key := "apps.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.App)
		return &GlobalApp{
			client: group.client,
			App:    result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Apps().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalApp{
			client: group.client,
			App:    result,
		}, nil
	}
}

// DeleteAppByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteAppByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Apps().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.VersionGvk != nil {
		err := group.client.
			Global().
			DeleteAppVersionByName(ctx, result.Spec.VersionGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Apps().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/appGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["appfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("appfolders.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		AppFolders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAppByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateAppByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.App) (*GlobalApp, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.VersionGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Apps().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["appfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("appfolders.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"appGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"App\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		AppFolders().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalApp{
		client: group.client,
		App:    result,
	}, nil
}

// UpdateAppByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateAppByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.App) (*GlobalApp, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Apps().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Apps().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalApp{
		client: group.client,
		App:    result,
	}, nil
}

// ListApps returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListApps(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalApp, err error) {
	key := "apps.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalApp, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.App)
			result[k] = &GlobalApp{
				client: group.client,
				App:    item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Apps().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalApp, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalApp{
				client: group.client,
				App:    &item,
			}
		}
	}
	return
}

type GlobalApp struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.App
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalApp) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteAppByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.App = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalApp) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateAppByName(ctx, obj.App)
	if err != nil {
		return err
	}
	obj.App = result.App
	return nil
}

func (obj *GlobalApp) GetParent(ctx context.Context) (result *GlobalAppFolder, err error) {
	hashedName := helper.GetHashedName("appfolders.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["appfolders.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetAppFolderByName(ctx, hashedName)
}

// GetVersion returns child of given type
func (obj *GlobalApp) GetVersion(ctx context.Context) (
	result *GlobalAppVersion, err error) {
	if obj.Spec.VersionGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.App", "Version")
	}
	return obj.client.Global().GetAppVersionByName(ctx, obj.Spec.VersionGvk.Name)
}

// AddVersion calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalApp) AddVersion(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AppVersion) (result *GlobalAppVersion, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["apps.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["apps.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateAppVersionByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetAppByName(ctx, obj.GetName())
	if getErr == nil {
		obj.App = updatedObj.App
	}
	return
}

// DeleteVersion calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalApp) DeleteVersion(ctx context.Context) (err error) {
	if obj.Spec.VersionGvk != nil {
		err = obj.client.
			Global().DeleteAppVersionByName(ctx, obj.Spec.VersionGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetAppByName(ctx, obj.GetName())
	if err == nil {
		obj.App = updatedObj.App
	}
	return
}

type appGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *appGlobalTsmV1Chainer) Subscribe() {
	key := "apps.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAppInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *appGlobalTsmV1Chainer) Unsubscribe() {
	key := "apps.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *appGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "apps.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *appGlobalTsmV1Chainer) Version(name string) *appversionGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["appversions.global.tsm.tanzu.vmware.com"] = name
	return &appversionGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetVersion calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *appGlobalTsmV1Chainer) GetVersion(ctx context.Context, displayName string) (result *GlobalAppVersion, err error) {
	hashedName := helper.GetHashedName("appversions.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetAppVersionByName(ctx, hashedName)
}

// AddVersion calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *appGlobalTsmV1Chainer) AddVersion(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AppVersion) (result *GlobalAppVersion, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("appversions.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateAppVersionByName(ctx, objToCreate)
}

// DeleteVersion calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *appGlobalTsmV1Chainer) DeleteVersion(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("appversions.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteAppVersionByName(ctx, hashedName)
}

// GetApplicationInfoByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetApplicationInfoByName(ctx context.Context, hashedName string) (*GlobalApplicationInfo, error) {
	key := "applicationinfos.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ApplicationInfo)
		return &GlobalApplicationInfo{
			client:          group.client,
			ApplicationInfo: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ApplicationInfos().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalApplicationInfo{
			client:          group.client,
			ApplicationInfo: result,
		}, nil
	}
}

// DeleteApplicationInfoByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteApplicationInfoByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ApplicationInfos().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ApplicationInfos().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/appsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["clusters.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusters.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Clusters().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateApplicationInfoByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateApplicationInfoByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ApplicationInfo) (*GlobalApplicationInfo, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ApplicationInfos().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["clusters.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusters.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"appsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ApplicationInfo\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Clusters().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalApplicationInfo{
		client:          group.client,
		ApplicationInfo: result,
	}, nil
}

// UpdateApplicationInfoByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateApplicationInfoByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ApplicationInfo) (*GlobalApplicationInfo, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ApplicationInfos().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueApp :=
		objToUpdate.Spec.App
	patchOpApp := PatchOp{
		Op:    "replace",
		Path:  "/spec/app",
		Value: patchValueApp,
	}
	patch = append(patch, patchOpApp)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ApplicationInfos().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalApplicationInfo{
		client:          group.client,
		ApplicationInfo: result,
	}, nil
}

// ListApplicationInfos returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListApplicationInfos(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalApplicationInfo, err error) {
	key := "applicationinfos.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalApplicationInfo, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ApplicationInfo)
			result[k] = &GlobalApplicationInfo{
				client:          group.client,
				ApplicationInfo: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ApplicationInfos().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalApplicationInfo, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalApplicationInfo{
				client:          group.client,
				ApplicationInfo: &item,
			}
		}
	}
	return
}

type GlobalApplicationInfo struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ApplicationInfo
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalApplicationInfo) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteApplicationInfoByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ApplicationInfo = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalApplicationInfo) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateApplicationInfoByName(ctx, obj.ApplicationInfo)
	if err != nil {
		return err
	}
	obj.ApplicationInfo = result.ApplicationInfo
	return nil
}

func (obj *GlobalApplicationInfo) GetParent(ctx context.Context) (result *GlobalCluster, err error) {
	hashedName := helper.GetHashedName("clusters.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["clusters.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetClusterByName(ctx, hashedName)
}

type applicationinfoGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *applicationinfoGlobalTsmV1Chainer) Subscribe() {
	key := "applicationinfos.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewApplicationInfoInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *applicationinfoGlobalTsmV1Chainer) Unsubscribe() {
	key := "applicationinfos.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *applicationinfoGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "applicationinfos.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetAttackDiscoveryRTByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetAttackDiscoveryRTByName(ctx context.Context, hashedName string) (*GlobalAttackDiscoveryRT, error) {
	key := "attackdiscoveryrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.AttackDiscoveryRT)
		return &GlobalAttackDiscoveryRT{
			client:            group.client,
			AttackDiscoveryRT: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			AttackDiscoveryRTs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalAttackDiscoveryRT{
			client:            group.client,
			AttackDiscoveryRT: result,
		}, nil
	}
}

// DeleteAttackDiscoveryRTByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteAttackDiscoveryRTByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AttackDiscoveryRTs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		AttackDiscoveryRTs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/attackDiscoveryGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAttackDiscoveryRTByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateAttackDiscoveryRTByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AttackDiscoveryRT) (*GlobalAttackDiscoveryRT, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AttackDiscoveryRTs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"attackDiscoveryGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"AttackDiscoveryRT\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalAttackDiscoveryRT{
		client:            group.client,
		AttackDiscoveryRT: result,
	}, nil
}

// UpdateAttackDiscoveryRTByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateAttackDiscoveryRTByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.AttackDiscoveryRT) (*GlobalAttackDiscoveryRT, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			AttackDiscoveryRTs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueGnsid :=
		objToUpdate.Spec.Gnsid
	patchOpGnsid := PatchOp{
		Op:    "replace",
		Path:  "/spec/gnsid",
		Value: patchValueGnsid,
	}
	patch = append(patch, patchOpGnsid)

	patchValueSelectors :=
		objToUpdate.Spec.Selectors
	patchOpSelectors := PatchOp{
		Op:    "replace",
		Path:  "/spec/selectors",
		Value: patchValueSelectors,
	}
	patch = append(patch, patchOpSelectors)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		AttackDiscoveryRTs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalAttackDiscoveryRT{
		client:            group.client,
		AttackDiscoveryRT: result,
	}, nil
}

// ListAttackDiscoveryRTs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListAttackDiscoveryRTs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalAttackDiscoveryRT, err error) {
	key := "attackdiscoveryrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalAttackDiscoveryRT, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.AttackDiscoveryRT)
			result[k] = &GlobalAttackDiscoveryRT{
				client:            group.client,
				AttackDiscoveryRT: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			AttackDiscoveryRTs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalAttackDiscoveryRT, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalAttackDiscoveryRT{
				client:            group.client,
				AttackDiscoveryRT: &item,
			}
		}
	}
	return
}

type GlobalAttackDiscoveryRT struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.AttackDiscoveryRT
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalAttackDiscoveryRT) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteAttackDiscoveryRTByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AttackDiscoveryRT = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalAttackDiscoveryRT) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateAttackDiscoveryRTByName(ctx, obj.AttackDiscoveryRT)
	if err != nil {
		return err
	}
	obj.AttackDiscoveryRT = result.AttackDiscoveryRT
	return nil
}

func (obj *GlobalAttackDiscoveryRT) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

type attackdiscoveryrtGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *attackdiscoveryrtGlobalTsmV1Chainer) Subscribe() {
	key := "attackdiscoveryrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAttackDiscoveryRTInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *attackdiscoveryrtGlobalTsmV1Chainer) Unsubscribe() {
	key := "attackdiscoveryrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *attackdiscoveryrtGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "attackdiscoveryrts.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetAttackDiscoveryByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetAttackDiscoveryByName(ctx context.Context, hashedName string) (*GlobalAttackDiscovery, error) {
	key := "attackdiscoveries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.AttackDiscovery)
		return &GlobalAttackDiscovery{
			client:          group.client,
			AttackDiscovery: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			AttackDiscoveries().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalAttackDiscovery{
			client:          group.client,
			AttackDiscovery: result,
		}, nil
	}
}

// DeleteAttackDiscoveryByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteAttackDiscoveryByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AttackDiscoveries().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		AttackDiscoveries().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/attackDiscoveryGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAttackDiscoveryByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateAttackDiscoveryByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AttackDiscovery) (*GlobalAttackDiscovery, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AttackDiscoveries().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"attackDiscoveryGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"AttackDiscovery\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalAttackDiscovery{
		client:          group.client,
		AttackDiscovery: result,
	}, nil
}

// UpdateAttackDiscoveryByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateAttackDiscoveryByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.AttackDiscovery) (*GlobalAttackDiscovery, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			AttackDiscoveries().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		AttackDiscoveries().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalAttackDiscovery{
		client:          group.client,
		AttackDiscovery: result,
	}, nil
}

// ListAttackDiscoveries returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListAttackDiscoveries(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalAttackDiscovery, err error) {
	key := "attackdiscoveries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalAttackDiscovery, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.AttackDiscovery)
			result[k] = &GlobalAttackDiscovery{
				client:          group.client,
				AttackDiscovery: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			AttackDiscoveries().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalAttackDiscovery, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalAttackDiscovery{
				client:          group.client,
				AttackDiscovery: &item,
			}
		}
	}
	return
}

type GlobalAttackDiscovery struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.AttackDiscovery
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalAttackDiscovery) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteAttackDiscoveryByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AttackDiscovery = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalAttackDiscovery) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateAttackDiscoveryByName(ctx, obj.AttackDiscovery)
	if err != nil {
		return err
	}
	obj.AttackDiscovery = result.AttackDiscovery
	return nil
}

func (obj *GlobalAttackDiscovery) GetParent(ctx context.Context) (result *GlobalGNS, err error) {
	hashedName := helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnss.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGNSByName(ctx, hashedName)
}

type attackdiscoveryGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *attackdiscoveryGlobalTsmV1Chainer) Subscribe() {
	key := "attackdiscoveries.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAttackDiscoveryInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *attackdiscoveryGlobalTsmV1Chainer) Unsubscribe() {
	key := "attackdiscoveries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *attackdiscoveryGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "attackdiscoveries.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetAuthenticationPolicyByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetAuthenticationPolicyByName(ctx context.Context, hashedName string) (*GlobalAuthenticationPolicy, error) {
	key := "authenticationpolicies.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.AuthenticationPolicy)
		return &GlobalAuthenticationPolicy{
			client:               group.client,
			AuthenticationPolicy: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			AuthenticationPolicies().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalAuthenticationPolicy{
			client:               group.client,
			AuthenticationPolicy: result,
		}, nil
	}
}

// DeleteAuthenticationPolicyByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteAuthenticationPolicyByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AuthenticationPolicies().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		AuthenticationPolicies().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/authenticationPoliciesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAuthenticationPolicyByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateAuthenticationPolicyByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AuthenticationPolicy) (*GlobalAuthenticationPolicy, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AuthenticationPolicies().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"authenticationPoliciesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"AuthenticationPolicy\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalAuthenticationPolicy{
		client:               group.client,
		AuthenticationPolicy: result,
	}, nil
}

// UpdateAuthenticationPolicyByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateAuthenticationPolicyByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.AuthenticationPolicy) (*GlobalAuthenticationPolicy, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			AuthenticationPolicies().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueAnnotations :=
		objToUpdate.Spec.Annotations
	patchOpAnnotations := PatchOp{
		Op:    "replace",
		Path:  "/spec/annotations",
		Value: patchValueAnnotations,
	}
	patch = append(patch, patchOpAnnotations)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		AuthenticationPolicies().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalAuthenticationPolicy{
		client:               group.client,
		AuthenticationPolicy: result,
	}, nil
}

// ListAuthenticationPolicies returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListAuthenticationPolicies(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalAuthenticationPolicy, err error) {
	key := "authenticationpolicies.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalAuthenticationPolicy, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.AuthenticationPolicy)
			result[k] = &GlobalAuthenticationPolicy{
				client:               group.client,
				AuthenticationPolicy: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			AuthenticationPolicies().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalAuthenticationPolicy, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalAuthenticationPolicy{
				client:               group.client,
				AuthenticationPolicy: &item,
			}
		}
	}
	return
}

type GlobalAuthenticationPolicy struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.AuthenticationPolicy
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalAuthenticationPolicy) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteAuthenticationPolicyByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AuthenticationPolicy = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalAuthenticationPolicy) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateAuthenticationPolicyByName(ctx, obj.AuthenticationPolicy)
	if err != nil {
		return err
	}
	obj.AuthenticationPolicy = result.AuthenticationPolicy
	return nil
}

func (obj *GlobalAuthenticationPolicy) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

type authenticationpolicyGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *authenticationpolicyGlobalTsmV1Chainer) Subscribe() {
	key := "authenticationpolicies.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAuthenticationPolicyInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *authenticationpolicyGlobalTsmV1Chainer) Unsubscribe() {
	key := "authenticationpolicies.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *authenticationpolicyGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "authenticationpolicies.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetAutoscalerFolderByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetAutoscalerFolderByName(ctx context.Context, hashedName string) (*GlobalAutoscalerFolder, error) {
	key := "autoscalerfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.AutoscalerFolder)
		return &GlobalAutoscalerFolder{
			client:           group.client,
			AutoscalerFolder: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			AutoscalerFolders().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalAutoscalerFolder{
			client:           group.client,
			AutoscalerFolder: result,
		}, nil
	}
}

// DeleteAutoscalerFolderByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteAutoscalerFolderByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AutoscalerFolders().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.AutoscalersGvk {
		err := group.client.
			Global().DeleteAutoscalerByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		AutoscalerFolders().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/autoscalerFolderGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAutoscalerFolderByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateAutoscalerFolderByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AutoscalerFolder) (*GlobalAutoscalerFolder, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.AutoscalersGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AutoscalerFolders().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/autoscalerFolderGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "AutoscalerFolder",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalAutoscalerFolder{
		client:           group.client,
		AutoscalerFolder: result,
	}, nil
}

// UpdateAutoscalerFolderByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateAutoscalerFolderByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.AutoscalerFolder) (*GlobalAutoscalerFolder, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			AutoscalerFolders().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		AutoscalerFolders().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalAutoscalerFolder{
		client:           group.client,
		AutoscalerFolder: result,
	}, nil
}

// ListAutoscalerFolders returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListAutoscalerFolders(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalAutoscalerFolder, err error) {
	key := "autoscalerfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalAutoscalerFolder, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.AutoscalerFolder)
			result[k] = &GlobalAutoscalerFolder{
				client:           group.client,
				AutoscalerFolder: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			AutoscalerFolders().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalAutoscalerFolder, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalAutoscalerFolder{
				client:           group.client,
				AutoscalerFolder: &item,
			}
		}
	}
	return
}

type GlobalAutoscalerFolder struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.AutoscalerFolder
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalAutoscalerFolder) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteAutoscalerFolderByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AutoscalerFolder = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalAutoscalerFolder) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateAutoscalerFolderByName(ctx, obj.AutoscalerFolder)
	if err != nil {
		return err
	}
	obj.AutoscalerFolder = result.AutoscalerFolder
	return nil
}

func (obj *GlobalAutoscalerFolder) GetParent(ctx context.Context) (result *GlobalConfig, err error) {
	hashedName := helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetConfigByName(ctx, hashedName)
}

// GetAllAutoscalers returns all children of given type
func (obj *GlobalAutoscalerFolder) GetAllAutoscalers(ctx context.Context) (
	result []*GlobalAutoscaler, err error) {
	result = make([]*GlobalAutoscaler, 0, len(obj.Spec.AutoscalersGvk))
	for _, v := range obj.Spec.AutoscalersGvk {
		l, err := obj.client.Global().GetAutoscalerByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetAutoscalers returns child which has given displayName
func (obj *GlobalAutoscalerFolder) GetAutoscalers(ctx context.Context,
	displayName string) (result *GlobalAutoscaler, err error) {
	l, ok := obj.Spec.AutoscalersGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.AutoscalerFolder", "Autoscalers", displayName)
	}
	result, err = obj.client.Global().GetAutoscalerByName(ctx, l.Name)
	return
}

// AddAutoscalers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalAutoscalerFolder) AddAutoscalers(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Autoscaler) (result *GlobalAutoscaler, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["autoscalerfolders.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["autoscalerfolders.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateAutoscalerByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetAutoscalerFolderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.AutoscalerFolder = updatedObj.AutoscalerFolder
	}
	return
}

// DeleteAutoscalers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalAutoscalerFolder) DeleteAutoscalers(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.AutoscalersGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.AutoscalerFolder", "Autoscalers", displayName)
	}
	err = obj.client.Global().DeleteAutoscalerByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetAutoscalerFolderByName(ctx, obj.GetName())
	if err == nil {
		obj.AutoscalerFolder = updatedObj.AutoscalerFolder
	}
	return
}

type autoscalerfolderGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *autoscalerfolderGlobalTsmV1Chainer) Subscribe() {
	key := "autoscalerfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAutoscalerFolderInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *autoscalerfolderGlobalTsmV1Chainer) Unsubscribe() {
	key := "autoscalerfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *autoscalerfolderGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "autoscalerfolders.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *autoscalerfolderGlobalTsmV1Chainer) Autoscalers(name string) *autoscalerGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["autoscalers.global.tsm.tanzu.vmware.com"] = name
	return &autoscalerGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetAutoscalers calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *autoscalerfolderGlobalTsmV1Chainer) GetAutoscalers(ctx context.Context, displayName string) (result *GlobalAutoscaler, err error) {
	hashedName := helper.GetHashedName("autoscalers.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetAutoscalerByName(ctx, hashedName)
}

// AddAutoscalers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *autoscalerfolderGlobalTsmV1Chainer) AddAutoscalers(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Autoscaler) (result *GlobalAutoscaler, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("autoscalers.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateAutoscalerByName(ctx, objToCreate)
}

// DeleteAutoscalers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *autoscalerfolderGlobalTsmV1Chainer) DeleteAutoscalers(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("autoscalers.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteAutoscalerByName(ctx, hashedName)
}

// GetAutoscalerConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetAutoscalerConfigByName(ctx context.Context, hashedName string) (*GlobalAutoscalerConfig, error) {
	key := "autoscalerconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.AutoscalerConfig)
		return &GlobalAutoscalerConfig{
			client:           group.client,
			AutoscalerConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			AutoscalerConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalAutoscalerConfig{
			client:           group.client,
			AutoscalerConfig: result,
		}, nil
	}
}

// DeleteAutoscalerConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteAutoscalerConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AutoscalerConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		AutoscalerConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/autoscalersGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAutoscalerConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateAutoscalerConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AutoscalerConfig) (*GlobalAutoscalerConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AutoscalerConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"autoscalersGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"AutoscalerConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalAutoscalerConfig{
		client:           group.client,
		AutoscalerConfig: result,
	}, nil
}

// UpdateAutoscalerConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateAutoscalerConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.AutoscalerConfig) (*GlobalAutoscalerConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			AutoscalerConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueConfigSource :=
		objToUpdate.Spec.ConfigSource
	patchOpConfigSource := PatchOp{
		Op:    "replace",
		Path:  "/spec/configSource",
		Value: patchValueConfigSource,
	}
	patch = append(patch, patchOpConfigSource)

	patchValueDesiredState :=
		objToUpdate.Spec.DesiredState
	patchOpDesiredState := PatchOp{
		Op:    "replace",
		Path:  "/spec/desiredState",
		Value: patchValueDesiredState,
	}
	patch = append(patch, patchOpDesiredState)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		AutoscalerConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalAutoscalerConfig{
		client:           group.client,
		AutoscalerConfig: result,
	}, nil
}

// ListAutoscalerConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListAutoscalerConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalAutoscalerConfig, err error) {
	key := "autoscalerconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalAutoscalerConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.AutoscalerConfig)
			result[k] = &GlobalAutoscalerConfig{
				client:           group.client,
				AutoscalerConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			AutoscalerConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalAutoscalerConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalAutoscalerConfig{
				client:           group.client,
				AutoscalerConfig: &item,
			}
		}
	}
	return
}

type GlobalAutoscalerConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.AutoscalerConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalAutoscalerConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteAutoscalerConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AutoscalerConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalAutoscalerConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateAutoscalerConfigByName(ctx, obj.AutoscalerConfig)
	if err != nil {
		return err
	}
	obj.AutoscalerConfig = result.AutoscalerConfig
	return nil
}

func (obj *GlobalAutoscalerConfig) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

type autoscalerconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *autoscalerconfigGlobalTsmV1Chainer) Subscribe() {
	key := "autoscalerconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAutoscalerConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *autoscalerconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "autoscalerconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *autoscalerconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "autoscalerconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetAutoscalerByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetAutoscalerByName(ctx context.Context, hashedName string) (*GlobalAutoscaler, error) {
	key := "autoscalers.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Autoscaler)
		return &GlobalAutoscaler{
			client:     group.client,
			Autoscaler: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Autoscalers().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalAutoscaler{
			client:     group.client,
			Autoscaler: result,
		}, nil
	}
}

// DeleteAutoscalerByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteAutoscalerByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Autoscalers().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Autoscalers().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/autoscalersGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["autoscalerfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("autoscalerfolders.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		AutoscalerFolders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAutoscalerByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateAutoscalerByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Autoscaler) (*GlobalAutoscaler, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.AutoscalerGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Autoscalers().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["autoscalerfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("autoscalerfolders.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"autoscalersGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"Autoscaler\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		AutoscalerFolders().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalAutoscaler{
		client:     group.client,
		Autoscaler: result,
	}, nil
}

// UpdateAutoscalerByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateAutoscalerByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Autoscaler) (*GlobalAutoscaler, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Autoscalers().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueProjectId :=
		objToUpdate.Spec.ProjectId
	patchOpProjectId := PatchOp{
		Op:    "replace",
		Path:  "/spec/projectId",
		Value: patchValueProjectId,
	}
	patch = append(patch, patchOpProjectId)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Autoscalers().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalAutoscaler{
		client:     group.client,
		Autoscaler: result,
	}, nil
}

// ListAutoscalers returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListAutoscalers(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalAutoscaler, err error) {
	key := "autoscalers.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalAutoscaler, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Autoscaler)
			result[k] = &GlobalAutoscaler{
				client:     group.client,
				Autoscaler: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Autoscalers().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalAutoscaler, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalAutoscaler{
				client:     group.client,
				Autoscaler: &item,
			}
		}
	}
	return
}

type GlobalAutoscaler struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Autoscaler
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalAutoscaler) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteAutoscalerByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Autoscaler = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalAutoscaler) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateAutoscalerByName(ctx, obj.Autoscaler)
	if err != nil {
		return err
	}
	obj.Autoscaler = result.Autoscaler
	return nil
}

func (obj *GlobalAutoscaler) GetParent(ctx context.Context) (result *GlobalAutoscalerFolder, err error) {
	hashedName := helper.GetHashedName("autoscalerfolders.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["autoscalerfolders.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetAutoscalerFolderByName(ctx, hashedName)
}

// GetAutoscaler returns link of given type
func (obj *GlobalAutoscaler) GetAutoscaler(ctx context.Context) (
	result *GlobalAutoscalerCR, err error) {
	if obj.Spec.AutoscalerGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.Autoscaler", "Autoscaler")
	}
	return obj.client.Global().GetAutoscalerCRByName(ctx, obj.Spec.AutoscalerGvk.Name)
}

// LinkAutoscaler links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalAutoscaler) LinkAutoscaler(ctx context.Context,
	linkToAdd *GlobalAutoscalerCR) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/autoscalerGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "AutoscalerCR",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Autoscalers().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Autoscaler = result
	return nil
}

// UnlinkAutoscaler unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalAutoscaler) UnlinkAutoscaler(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/autoscalerGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Autoscalers().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Autoscaler = result
	return nil

}

type autoscalerGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *autoscalerGlobalTsmV1Chainer) Subscribe() {
	key := "autoscalers.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAutoscalerInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *autoscalerGlobalTsmV1Chainer) Unsubscribe() {
	key := "autoscalers.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *autoscalerGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "autoscalers.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetAutoscalerCRByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetAutoscalerCRByName(ctx context.Context, hashedName string) (*GlobalAutoscalerCR, error) {
	key := "autoscalercrs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.AutoscalerCR)
		return &GlobalAutoscalerCR{
			client:       group.client,
			AutoscalerCR: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			AutoscalerCRs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalAutoscalerCR{
			client:       group.client,
			AutoscalerCR: result,
		}, nil
	}
}

// DeleteAutoscalerCRByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteAutoscalerCRByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AutoscalerCRs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		AutoscalerCRs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/autoscalersGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAutoscalerCRByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateAutoscalerCRByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AutoscalerCR) (*GlobalAutoscalerCR, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AutoscalerCRs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"autoscalersGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"AutoscalerCR\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalAutoscalerCR{
		client:       group.client,
		AutoscalerCR: result,
	}, nil
}

// UpdateAutoscalerCRByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateAutoscalerCRByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.AutoscalerCR) (*GlobalAutoscalerCR, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			AutoscalerCRs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueAutoscalingDefinition :=
		objToUpdate.Spec.AutoscalingDefinition
	patchOpAutoscalingDefinition := PatchOp{
		Op:    "replace",
		Path:  "/spec/autoscalingDefinition",
		Value: patchValueAutoscalingDefinition,
	}
	patch = append(patch, patchOpAutoscalingDefinition)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		AutoscalerCRs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalAutoscalerCR{
		client:       group.client,
		AutoscalerCR: result,
	}, nil
}

// ListAutoscalerCRs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListAutoscalerCRs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalAutoscalerCR, err error) {
	key := "autoscalercrs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalAutoscalerCR, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.AutoscalerCR)
			result[k] = &GlobalAutoscalerCR{
				client:       group.client,
				AutoscalerCR: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			AutoscalerCRs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalAutoscalerCR, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalAutoscalerCR{
				client:       group.client,
				AutoscalerCR: &item,
			}
		}
	}
	return
}

type GlobalAutoscalerCR struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.AutoscalerCR
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalAutoscalerCR) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteAutoscalerCRByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AutoscalerCR = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalAutoscalerCR) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateAutoscalerCRByName(ctx, obj.AutoscalerCR)
	if err != nil {
		return err
	}
	obj.AutoscalerCR = result.AutoscalerCR
	return nil
}

func (obj *GlobalAutoscalerCR) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

type autoscalercrGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *autoscalercrGlobalTsmV1Chainer) Subscribe() {
	key := "autoscalercrs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAutoscalerCRInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *autoscalercrGlobalTsmV1Chainer) Unsubscribe() {
	key := "autoscalercrs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *autoscalercrGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "autoscalercrs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetAutoscalingPolicyByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetAutoscalingPolicyByName(ctx context.Context, hashedName string) (*GlobalAutoscalingPolicy, error) {
	key := "autoscalingpolicies.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.AutoscalingPolicy)
		return &GlobalAutoscalingPolicy{
			client:            group.client,
			AutoscalingPolicy: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			AutoscalingPolicies().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalAutoscalingPolicy{
			client:            group.client,
			AutoscalingPolicy: result,
		}, nil
	}
}

// DeleteAutoscalingPolicyByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteAutoscalingPolicyByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AutoscalingPolicies().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		AutoscalingPolicies().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/autoscalingPoliciesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAutoscalingPolicyByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateAutoscalingPolicyByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AutoscalingPolicy) (*GlobalAutoscalingPolicy, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AutoscalingPolicies().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"autoscalingPoliciesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"AutoscalingPolicy\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalAutoscalingPolicy{
		client:            group.client,
		AutoscalingPolicy: result,
	}, nil
}

// UpdateAutoscalingPolicyByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateAutoscalingPolicyByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.AutoscalingPolicy) (*GlobalAutoscalingPolicy, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			AutoscalingPolicies().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueServiceName :=
		objToUpdate.Spec.ServiceName
	patchOpServiceName := PatchOp{
		Op:    "replace",
		Path:  "/spec/serviceName",
		Value: patchValueServiceName,
	}
	patch = append(patch, patchOpServiceName)

	patchValueAutoscalerSpec :=
		objToUpdate.Spec.AutoscalerSpec
	patchOpAutoscalerSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/autoscalerSpec",
		Value: patchValueAutoscalerSpec,
	}
	patch = append(patch, patchOpAutoscalerSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		AutoscalingPolicies().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalAutoscalingPolicy{
		client:            group.client,
		AutoscalingPolicy: result,
	}, nil
}

// ListAutoscalingPolicies returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListAutoscalingPolicies(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalAutoscalingPolicy, err error) {
	key := "autoscalingpolicies.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalAutoscalingPolicy, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.AutoscalingPolicy)
			result[k] = &GlobalAutoscalingPolicy{
				client:            group.client,
				AutoscalingPolicy: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			AutoscalingPolicies().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalAutoscalingPolicy, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalAutoscalingPolicy{
				client:            group.client,
				AutoscalingPolicy: &item,
			}
		}
	}
	return
}

type GlobalAutoscalingPolicy struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.AutoscalingPolicy
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalAutoscalingPolicy) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteAutoscalingPolicyByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AutoscalingPolicy = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalAutoscalingPolicy) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateAutoscalingPolicyByName(ctx, obj.AutoscalingPolicy)
	if err != nil {
		return err
	}
	obj.AutoscalingPolicy = result.AutoscalingPolicy
	return nil
}

func (obj *GlobalAutoscalingPolicy) GetParent(ctx context.Context) (result *GlobalGNS, err error) {
	hashedName := helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnss.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGNSByName(ctx, hashedName)
}

type autoscalingpolicyGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *autoscalingpolicyGlobalTsmV1Chainer) Subscribe() {
	key := "autoscalingpolicies.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAutoscalingPolicyInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *autoscalingpolicyGlobalTsmV1Chainer) Unsubscribe() {
	key := "autoscalingpolicies.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *autoscalingpolicyGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "autoscalingpolicies.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetAwsConnectorByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetAwsConnectorByName(ctx context.Context, hashedName string) (*GlobalAwsConnector, error) {
	key := "awsconnectors.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.AwsConnector)
		return &GlobalAwsConnector{
			client:       group.client,
			AwsConnector: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			AwsConnectors().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalAwsConnector{
			client:       group.client,
			AwsConnector: result,
		}, nil
	}
}

// DeleteAwsConnectorByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteAwsConnectorByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AwsConnectors().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.GnsGvk {
		err := group.client.
			Global().DeleteGlobalNsByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		AwsConnectors().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/awsConnectorGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["allsparkserviceses.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("allsparkserviceses.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		AllSparkServiceses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAwsConnectorByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateAwsConnectorByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AwsConnector) (*GlobalAwsConnector, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.GnsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AwsConnectors().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["allsparkserviceses.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("allsparkserviceses.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/awsConnectorGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "AwsConnector",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		AllSparkServiceses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalAwsConnector{
		client:       group.client,
		AwsConnector: result,
	}, nil
}

// UpdateAwsConnectorByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateAwsConnectorByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.AwsConnector) (*GlobalAwsConnector, error) {
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			AwsConnectors().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		AwsConnectors().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalAwsConnector{
		client:       group.client,
		AwsConnector: result,
	}, nil
}

// ListAwsConnectors returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListAwsConnectors(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalAwsConnector, err error) {
	key := "awsconnectors.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalAwsConnector, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.AwsConnector)
			result[k] = &GlobalAwsConnector{
				client:       group.client,
				AwsConnector: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			AwsConnectors().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalAwsConnector, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalAwsConnector{
				client:       group.client,
				AwsConnector: &item,
			}
		}
	}
	return
}

type GlobalAwsConnector struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.AwsConnector
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalAwsConnector) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteAwsConnectorByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AwsConnector = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalAwsConnector) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateAwsConnectorByName(ctx, obj.AwsConnector)
	if err != nil {
		return err
	}
	obj.AwsConnector = result.AwsConnector
	return nil
}

func (obj *GlobalAwsConnector) GetParent(ctx context.Context) (result *GlobalAllSparkServices, err error) {
	hashedName := helper.GetHashedName("allsparkserviceses.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["allsparkserviceses.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetAllSparkServicesByName(ctx, hashedName)
}

// GetAllGns returns all children of given type
func (obj *GlobalAwsConnector) GetAllGns(ctx context.Context) (
	result []*GlobalGlobalNs, err error) {
	result = make([]*GlobalGlobalNs, 0, len(obj.Spec.GnsGvk))
	for _, v := range obj.Spec.GnsGvk {
		l, err := obj.client.Global().GetGlobalNsByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGns returns child which has given displayName
func (obj *GlobalAwsConnector) GetGns(ctx context.Context,
	displayName string) (result *GlobalGlobalNs, err error) {
	l, ok := obj.Spec.GnsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.AwsConnector", "Gns", displayName)
	}
	result, err = obj.client.Global().GetGlobalNsByName(ctx, l.Name)
	return
}

// AddGns calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalAwsConnector) AddGns(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GlobalNs) (result *GlobalGlobalNs, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["awsconnectors.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["awsconnectors.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGlobalNsByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetAwsConnectorByName(ctx, obj.GetName())
	if getErr == nil {
		obj.AwsConnector = updatedObj.AwsConnector
	}
	return
}

// DeleteGns calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalAwsConnector) DeleteGns(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.GnsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.AwsConnector", "Gns", displayName)
	}
	err = obj.client.Global().DeleteGlobalNsByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetAwsConnectorByName(ctx, obj.GetName())
	if err == nil {
		obj.AwsConnector = updatedObj.AwsConnector
	}
	return
}

type awsconnectorGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *awsconnectorGlobalTsmV1Chainer) Subscribe() {
	key := "awsconnectors.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAwsConnectorInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *awsconnectorGlobalTsmV1Chainer) Unsubscribe() {
	key := "awsconnectors.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *awsconnectorGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "awsconnectors.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *awsconnectorGlobalTsmV1Chainer) Gns(name string) *globalnsGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["globalnses.global.tsm.tanzu.vmware.com"] = name
	return &globalnsGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGns calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *awsconnectorGlobalTsmV1Chainer) GetGns(ctx context.Context, displayName string) (result *GlobalGlobalNs, err error) {
	hashedName := helper.GetHashedName("globalnses.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGlobalNsByName(ctx, hashedName)
}

// AddGns calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *awsconnectorGlobalTsmV1Chainer) AddGns(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GlobalNs) (result *GlobalGlobalNs, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("globalnses.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGlobalNsByName(ctx, objToCreate)
}

// DeleteGns calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *awsconnectorGlobalTsmV1Chainer) DeleteGns(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("globalnses.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGlobalNsByName(ctx, hashedName)
}

// GetBucketByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetBucketByName(ctx context.Context, hashedName string) (*GlobalBucket, error) {
	key := "buckets.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Bucket)
		return &GlobalBucket{
			client: group.client,
			Bucket: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Buckets().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalBucket{
			client: group.client,
			Bucket: result,
		}, nil
	}
}

// DeleteBucketByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteBucketByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Buckets().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Buckets().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/bucketsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["databases.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("databases.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Databases().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateBucketByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateBucketByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Bucket) (*GlobalBucket, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.TemplateGvk = nil
	objToCreate.Spec.InventoryGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Buckets().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["databases.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("databases.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"bucketsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"Bucket\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Databases().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalBucket{
		client: group.client,
		Bucket: result,
	}, nil
}

// UpdateBucketByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateBucketByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Bucket) (*GlobalBucket, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Buckets().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Buckets().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalBucket{
		client: group.client,
		Bucket: result,
	}, nil
}

// ListBuckets returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListBuckets(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalBucket, err error) {
	key := "buckets.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalBucket, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Bucket)
			result[k] = &GlobalBucket{
				client: group.client,
				Bucket: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Buckets().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalBucket, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalBucket{
				client: group.client,
				Bucket: &item,
			}
		}
	}
	return
}

type GlobalBucket struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Bucket
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalBucket) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteBucketByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Bucket = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalBucket) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateBucketByName(ctx, obj.Bucket)
	if err != nil {
		return err
	}
	obj.Bucket = result.Bucket
	return nil
}

func (obj *GlobalBucket) GetParent(ctx context.Context) (result *GlobalDatabase, err error) {
	hashedName := helper.GetHashedName("databases.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["databases.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDatabaseByName(ctx, hashedName)
}

// GetTemplate returns link of given type
func (obj *GlobalBucket) GetTemplate(ctx context.Context) (
	result *GlobalTemplate, err error) {
	if obj.Spec.TemplateGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.Bucket", "Template")
	}
	return obj.client.Global().GetTemplateByName(ctx, obj.Spec.TemplateGvk.Name)
}

// LinkTemplate links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalBucket) LinkTemplate(ctx context.Context,
	linkToAdd *GlobalTemplate) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/templateGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "Template",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Buckets().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Bucket = result
	return nil
}

// UnlinkTemplate unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalBucket) UnlinkTemplate(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/templateGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Buckets().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Bucket = result
	return nil

}

// GetInventory returns link of given type
func (obj *GlobalBucket) GetInventory(ctx context.Context) (
	result *GlobalInventory, err error) {
	if obj.Spec.InventoryGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.Bucket", "Inventory")
	}
	return obj.client.Global().GetInventoryByName(ctx, obj.Spec.InventoryGvk.Name)
}

// LinkInventory links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalBucket) LinkInventory(ctx context.Context,
	linkToAdd *GlobalInventory) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/inventoryGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "Inventory",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Buckets().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Bucket = result
	return nil
}

// UnlinkInventory unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalBucket) UnlinkInventory(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/inventoryGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Buckets().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Bucket = result
	return nil

}

type bucketGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *bucketGlobalTsmV1Chainer) Subscribe() {
	key := "buckets.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewBucketInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *bucketGlobalTsmV1Chainer) Unsubscribe() {
	key := "buckets.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *bucketGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "buckets.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetCertificateAuthorityRTByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetCertificateAuthorityRTByName(ctx context.Context, hashedName string) (*GlobalCertificateAuthorityRT, error) {
	key := "certificateauthorityrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.CertificateAuthorityRT)
		return &GlobalCertificateAuthorityRT{
			client:                 group.client,
			CertificateAuthorityRT: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			CertificateAuthorityRTs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalCertificateAuthorityRT{
			client:                 group.client,
			CertificateAuthorityRT: result,
		}, nil
	}
}

// DeleteCertificateAuthorityRTByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteCertificateAuthorityRTByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		CertificateAuthorityRTs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		CertificateAuthorityRTs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/certificateAuthorityGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateCertificateAuthorityRTByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateCertificateAuthorityRTByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.CertificateAuthorityRT) (*GlobalCertificateAuthorityRT, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		CertificateAuthorityRTs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"certificateAuthorityGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"CertificateAuthorityRT\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalCertificateAuthorityRT{
		client:                 group.client,
		CertificateAuthorityRT: result,
	}, nil
}

// UpdateCertificateAuthorityRTByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateCertificateAuthorityRTByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.CertificateAuthorityRT) (*GlobalCertificateAuthorityRT, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			CertificateAuthorityRTs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueUrl :=
		objToUpdate.Spec.Url
	patchOpUrl := PatchOp{
		Op:    "replace",
		Path:  "/spec/url",
		Value: patchValueUrl,
	}
	patch = append(patch, patchOpUrl)

	patchValueType :=
		objToUpdate.Spec.Type
	patchOpType := PatchOp{
		Op:    "replace",
		Path:  "/spec/type",
		Value: patchValueType,
	}
	patch = append(patch, patchOpType)

	patchValueTemplatePath :=
		objToUpdate.Spec.TemplatePath
	patchOpTemplatePath := PatchOp{
		Op:    "replace",
		Path:  "/spec/templatePath",
		Value: patchValueTemplatePath,
	}
	patch = append(patch, patchOpTemplatePath)

	patchValueSecretRef :=
		objToUpdate.Spec.SecretRef
	patchOpSecretRef := PatchOp{
		Op:    "replace",
		Path:  "/spec/secretRef",
		Value: patchValueSecretRef,
	}
	patch = append(patch, patchOpSecretRef)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		CertificateAuthorityRTs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalCertificateAuthorityRT{
		client:                 group.client,
		CertificateAuthorityRT: result,
	}, nil
}

// ListCertificateAuthorityRTs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListCertificateAuthorityRTs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalCertificateAuthorityRT, err error) {
	key := "certificateauthorityrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalCertificateAuthorityRT, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.CertificateAuthorityRT)
			result[k] = &GlobalCertificateAuthorityRT{
				client:                 group.client,
				CertificateAuthorityRT: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			CertificateAuthorityRTs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalCertificateAuthorityRT, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalCertificateAuthorityRT{
				client:                 group.client,
				CertificateAuthorityRT: &item,
			}
		}
	}
	return
}

type GlobalCertificateAuthorityRT struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.CertificateAuthorityRT
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalCertificateAuthorityRT) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteCertificateAuthorityRTByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.CertificateAuthorityRT = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalCertificateAuthorityRT) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateCertificateAuthorityRTByName(ctx, obj.CertificateAuthorityRT)
	if err != nil {
		return err
	}
	obj.CertificateAuthorityRT = result.CertificateAuthorityRT
	return nil
}

func (obj *GlobalCertificateAuthorityRT) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

type certificateauthorityrtGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *certificateauthorityrtGlobalTsmV1Chainer) Subscribe() {
	key := "certificateauthorityrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewCertificateAuthorityRTInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *certificateauthorityrtGlobalTsmV1Chainer) Unsubscribe() {
	key := "certificateauthorityrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *certificateauthorityrtGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "certificateauthorityrts.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetCertificateAuthorityConfigNByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetCertificateAuthorityConfigNByName(ctx context.Context, hashedName string) (*GlobalCertificateAuthorityConfigN, error) {
	key := "certificateauthorityconfigns.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.CertificateAuthorityConfigN)
		return &GlobalCertificateAuthorityConfigN{
			client:                      group.client,
			CertificateAuthorityConfigN: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			CertificateAuthorityConfigNs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalCertificateAuthorityConfigN{
			client:                      group.client,
			CertificateAuthorityConfigN: result,
		}, nil
	}
}

// DeleteCertificateAuthorityConfigNByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteCertificateAuthorityConfigNByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		CertificateAuthorityConfigNs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		CertificateAuthorityConfigNs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/certificateAuthoritiesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["projectconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("projectconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ProjectConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateCertificateAuthorityConfigNByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateCertificateAuthorityConfigNByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.CertificateAuthorityConfigN) (*GlobalCertificateAuthorityConfigN, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		CertificateAuthorityConfigNs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["projectconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("projectconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"certificateAuthoritiesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"CertificateAuthorityConfigN\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ProjectConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalCertificateAuthorityConfigN{
		client:                      group.client,
		CertificateAuthorityConfigN: result,
	}, nil
}

// UpdateCertificateAuthorityConfigNByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateCertificateAuthorityConfigNByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.CertificateAuthorityConfigN) (*GlobalCertificateAuthorityConfigN, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			CertificateAuthorityConfigNs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueConfig :=
		objToUpdate.Spec.Config
	patchOpConfig := PatchOp{
		Op:    "replace",
		Path:  "/spec/config",
		Value: patchValueConfig,
	}
	patch = append(patch, patchOpConfig)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		CertificateAuthorityConfigNs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalCertificateAuthorityConfigN{
		client:                      group.client,
		CertificateAuthorityConfigN: result,
	}, nil
}

// ListCertificateAuthorityConfigNs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListCertificateAuthorityConfigNs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalCertificateAuthorityConfigN, err error) {
	key := "certificateauthorityconfigns.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalCertificateAuthorityConfigN, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.CertificateAuthorityConfigN)
			result[k] = &GlobalCertificateAuthorityConfigN{
				client:                      group.client,
				CertificateAuthorityConfigN: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			CertificateAuthorityConfigNs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalCertificateAuthorityConfigN, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalCertificateAuthorityConfigN{
				client:                      group.client,
				CertificateAuthorityConfigN: &item,
			}
		}
	}
	return
}

type GlobalCertificateAuthorityConfigN struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.CertificateAuthorityConfigN
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalCertificateAuthorityConfigN) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteCertificateAuthorityConfigNByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.CertificateAuthorityConfigN = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalCertificateAuthorityConfigN) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateCertificateAuthorityConfigNByName(ctx, obj.CertificateAuthorityConfigN)
	if err != nil {
		return err
	}
	obj.CertificateAuthorityConfigN = result.CertificateAuthorityConfigN
	return nil
}

func (obj *GlobalCertificateAuthorityConfigN) GetParent(ctx context.Context) (result *GlobalProjectConfig, err error) {
	hashedName := helper.GetHashedName("projectconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["projectconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetProjectConfigByName(ctx, hashedName)
}

type certificateauthorityconfignGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *certificateauthorityconfignGlobalTsmV1Chainer) Subscribe() {
	key := "certificateauthorityconfigns.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewCertificateAuthorityConfigNInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *certificateauthorityconfignGlobalTsmV1Chainer) Unsubscribe() {
	key := "certificateauthorityconfigns.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *certificateauthorityconfignGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "certificateauthorityconfigns.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetCertificateConfigNByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetCertificateConfigNByName(ctx context.Context, hashedName string) (*GlobalCertificateConfigN, error) {
	key := "certificateconfigns.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.CertificateConfigN)
		return &GlobalCertificateConfigN{
			client:             group.client,
			CertificateConfigN: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			CertificateConfigNs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalCertificateConfigN{
			client:             group.client,
			CertificateConfigN: result,
		}, nil
	}
}

// DeleteCertificateConfigNByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteCertificateConfigNByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		CertificateConfigNs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		CertificateConfigNs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/certificatesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateCertificateConfigNByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateCertificateConfigNByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.CertificateConfigN) (*GlobalCertificateConfigN, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		CertificateConfigNs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"certificatesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"CertificateConfigN\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalCertificateConfigN{
		client:             group.client,
		CertificateConfigN: result,
	}, nil
}

// UpdateCertificateConfigNByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateCertificateConfigNByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.CertificateConfigN) (*GlobalCertificateConfigN, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			CertificateConfigNs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueProjectId :=
		objToUpdate.Spec.ProjectId
	patchOpProjectId := PatchOp{
		Op:    "replace",
		Path:  "/spec/projectId",
		Value: patchValueProjectId,
	}
	patch = append(patch, patchOpProjectId)

	patchValueBeginsOn :=
		objToUpdate.Spec.BeginsOn
	patchOpBeginsOn := PatchOp{
		Op:    "replace",
		Path:  "/spec/beginsOn",
		Value: patchValueBeginsOn,
	}
	patch = append(patch, patchOpBeginsOn)

	patchValueExpiresOn :=
		objToUpdate.Spec.ExpiresOn
	patchOpExpiresOn := PatchOp{
		Op:    "replace",
		Path:  "/spec/expiresOn",
		Value: patchValueExpiresOn,
	}
	patch = append(patch, patchOpExpiresOn)

	patchValueIssuedToCN :=
		objToUpdate.Spec.IssuedToCN
	patchOpIssuedToCN := PatchOp{
		Op:    "replace",
		Path:  "/spec/issuedToCN",
		Value: patchValueIssuedToCN,
	}
	patch = append(patch, patchOpIssuedToCN)

	patchValueConfig :=
		objToUpdate.Spec.Config
	patchOpConfig := PatchOp{
		Op:    "replace",
		Path:  "/spec/config",
		Value: patchValueConfig,
	}
	patch = append(patch, patchOpConfig)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		CertificateConfigNs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalCertificateConfigN{
		client:             group.client,
		CertificateConfigN: result,
	}, nil
}

// ListCertificateConfigNs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListCertificateConfigNs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalCertificateConfigN, err error) {
	key := "certificateconfigns.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalCertificateConfigN, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.CertificateConfigN)
			result[k] = &GlobalCertificateConfigN{
				client:             group.client,
				CertificateConfigN: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			CertificateConfigNs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalCertificateConfigN, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalCertificateConfigN{
				client:             group.client,
				CertificateConfigN: &item,
			}
		}
	}
	return
}

type GlobalCertificateConfigN struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.CertificateConfigN
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalCertificateConfigN) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteCertificateConfigNByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.CertificateConfigN = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalCertificateConfigN) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateCertificateConfigNByName(ctx, obj.CertificateConfigN)
	if err != nil {
		return err
	}
	obj.CertificateConfigN = result.CertificateConfigN
	return nil
}

func (obj *GlobalCertificateConfigN) GetParent(ctx context.Context) (result *GlobalConfig, err error) {
	hashedName := helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetConfigByName(ctx, hashedName)
}

type certificateconfignGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *certificateconfignGlobalTsmV1Chainer) Subscribe() {
	key := "certificateconfigns.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewCertificateConfigNInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *certificateconfignGlobalTsmV1Chainer) Unsubscribe() {
	key := "certificateconfigns.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *certificateconfignGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "certificateconfigns.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetCertificateRequestByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetCertificateRequestByName(ctx context.Context, hashedName string) (*GlobalCertificateRequest, error) {
	key := "certificaterequests.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.CertificateRequest)
		return &GlobalCertificateRequest{
			client:             group.client,
			CertificateRequest: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			CertificateRequests().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalCertificateRequest{
			client:             group.client,
			CertificateRequest: result,
		}, nil
	}
}

// DeleteCertificateRequestByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteCertificateRequestByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		CertificateRequests().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		CertificateRequests().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/certificateRequestsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateCertificateRequestByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateCertificateRequestByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.CertificateRequest) (*GlobalCertificateRequest, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		CertificateRequests().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"certificateRequestsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"CertificateRequest\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalCertificateRequest{
		client:             group.client,
		CertificateRequest: result,
	}, nil
}

// UpdateCertificateRequestByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateCertificateRequestByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.CertificateRequest) (*GlobalCertificateRequest, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			CertificateRequests().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueMetadata :=
		objToUpdate.Spec.Metadata
	patchOpMetadata := PatchOp{
		Op:    "replace",
		Path:  "/spec/metadata",
		Value: patchValueMetadata,
	}
	patch = append(patch, patchOpMetadata)

	patchValueIssuerRef :=
		objToUpdate.Spec.IssuerRef
	patchOpIssuerRef := PatchOp{
		Op:    "replace",
		Path:  "/spec/issuerRef",
		Value: patchValueIssuerRef,
	}
	patch = append(patch, patchOpIssuerRef)

	patchValueRequest :=
		objToUpdate.Spec.Request
	patchOpRequest := PatchOp{
		Op:    "replace",
		Path:  "/spec/request",
		Value: patchValueRequest,
	}
	patch = append(patch, patchOpRequest)

	patchValueDuration :=
		objToUpdate.Spec.Duration
	patchOpDuration := PatchOp{
		Op:    "replace",
		Path:  "/spec/duration",
		Value: patchValueDuration,
	}
	patch = append(patch, patchOpDuration)

	patchValueUid :=
		objToUpdate.Spec.Uid
	patchOpUid := PatchOp{
		Op:    "replace",
		Path:  "/spec/uid",
		Value: patchValueUid,
	}
	patch = append(patch, patchOpUid)

	patchValueIsCA :=
		objToUpdate.Spec.IsCA
	patchOpIsCA := PatchOp{
		Op:    "replace",
		Path:  "/spec/isCA",
		Value: patchValueIsCA,
	}
	patch = append(patch, patchOpIsCA)

	patchValueUsername :=
		objToUpdate.Spec.Username
	patchOpUsername := PatchOp{
		Op:    "replace",
		Path:  "/spec/username",
		Value: patchValueUsername,
	}
	patch = append(patch, patchOpUsername)

	patchValueUsages :=
		objToUpdate.Spec.Usages
	patchOpUsages := PatchOp{
		Op:    "replace",
		Path:  "/spec/usages",
		Value: patchValueUsages,
	}
	patch = append(patch, patchOpUsages)

	patchValueGroups :=
		objToUpdate.Spec.Groups
	patchOpGroups := PatchOp{
		Op:    "replace",
		Path:  "/spec/groups",
		Value: patchValueGroups,
	}
	patch = append(patch, patchOpGroups)

	patchValueExtra :=
		objToUpdate.Spec.Extra
	patchOpExtra := PatchOp{
		Op:    "replace",
		Path:  "/spec/extra",
		Value: patchValueExtra,
	}
	patch = append(patch, patchOpExtra)

	patchValueStatus :=
		objToUpdate.Spec.Status
	patchOpStatus := PatchOp{
		Op:    "replace",
		Path:  "/spec/status",
		Value: patchValueStatus,
	}
	patch = append(patch, patchOpStatus)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		CertificateRequests().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalCertificateRequest{
		client:             group.client,
		CertificateRequest: result,
	}, nil
}

// ListCertificateRequests returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListCertificateRequests(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalCertificateRequest, err error) {
	key := "certificaterequests.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalCertificateRequest, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.CertificateRequest)
			result[k] = &GlobalCertificateRequest{
				client:             group.client,
				CertificateRequest: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			CertificateRequests().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalCertificateRequest, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalCertificateRequest{
				client:             group.client,
				CertificateRequest: &item,
			}
		}
	}
	return
}

type GlobalCertificateRequest struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.CertificateRequest
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalCertificateRequest) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteCertificateRequestByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.CertificateRequest = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalCertificateRequest) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateCertificateRequestByName(ctx, obj.CertificateRequest)
	if err != nil {
		return err
	}
	obj.CertificateRequest = result.CertificateRequest
	return nil
}

func (obj *GlobalCertificateRequest) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

type certificaterequestGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *certificaterequestGlobalTsmV1Chainer) Subscribe() {
	key := "certificaterequests.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewCertificateRequestInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *certificaterequestGlobalTsmV1Chainer) Unsubscribe() {
	key := "certificaterequests.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *certificaterequestGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "certificaterequests.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetCertificateByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetCertificateByName(ctx context.Context, hashedName string) (*GlobalCertificate, error) {
	key := "certificates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Certificate)
		return &GlobalCertificate{
			client:      group.client,
			Certificate: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Certificates().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalCertificate{
			client:      group.client,
			Certificate: result,
		}, nil
	}
}

// DeleteCertificateByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteCertificateByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Certificates().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Certificates().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/certificatesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateCertificateByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateCertificateByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Certificate) (*GlobalCertificate, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Certificates().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"certificatesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"Certificate\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalCertificate{
		client:      group.client,
		Certificate: result,
	}, nil
}

// UpdateCertificateByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateCertificateByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Certificate) (*GlobalCertificate, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Certificates().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueMetadata :=
		objToUpdate.Spec.Metadata
	patchOpMetadata := PatchOp{
		Op:    "replace",
		Path:  "/spec/metadata",
		Value: patchValueMetadata,
	}
	patch = append(patch, patchOpMetadata)

	patchValueIssuerRef :=
		objToUpdate.Spec.IssuerRef
	patchOpIssuerRef := PatchOp{
		Op:    "replace",
		Path:  "/spec/issuerRef",
		Value: patchValueIssuerRef,
	}
	patch = append(patch, patchOpIssuerRef)

	patchValuePrivateKey :=
		objToUpdate.Spec.PrivateKey
	patchOpPrivateKey := PatchOp{
		Op:    "replace",
		Path:  "/spec/privateKey",
		Value: patchValuePrivateKey,
	}
	patch = append(patch, patchOpPrivateKey)

	patchValueSubject :=
		objToUpdate.Spec.Subject
	patchOpSubject := PatchOp{
		Op:    "replace",
		Path:  "/spec/subject",
		Value: patchValueSubject,
	}
	patch = append(patch, patchOpSubject)

	patchValueCommonName :=
		objToUpdate.Spec.CommonName
	patchOpCommonName := PatchOp{
		Op:    "replace",
		Path:  "/spec/commonName",
		Value: patchValueCommonName,
	}
	patch = append(patch, patchOpCommonName)

	patchValueDuration :=
		objToUpdate.Spec.Duration
	patchOpDuration := PatchOp{
		Op:    "replace",
		Path:  "/spec/duration",
		Value: patchValueDuration,
	}
	patch = append(patch, patchOpDuration)

	if objToUpdate.Spec.DnsNames != nil {
		patchValueDnsNames :=
			objToUpdate.Spec.DnsNames
		patchOpDnsNames := PatchOp{
			Op:    "replace",
			Path:  "/spec/dnsNames",
			Value: patchValueDnsNames,
		}
		patch = append(patch, patchOpDnsNames)
	}

	if objToUpdate.Spec.IpAddresses != nil {
		patchValueIpAddresses :=
			objToUpdate.Spec.IpAddresses
		patchOpIpAddresses := PatchOp{
			Op:    "replace",
			Path:  "/spec/ipAddresses",
			Value: patchValueIpAddresses,
		}
		patch = append(patch, patchOpIpAddresses)
	}

	patchValueSecretName :=
		objToUpdate.Spec.SecretName
	patchOpSecretName := PatchOp{
		Op:    "replace",
		Path:  "/spec/secretName",
		Value: patchValueSecretName,
	}
	patch = append(patch, patchOpSecretName)

	patchValueRenewBefore :=
		objToUpdate.Spec.RenewBefore
	patchOpRenewBefore := PatchOp{
		Op:    "replace",
		Path:  "/spec/renewBefore",
		Value: patchValueRenewBefore,
	}
	patch = append(patch, patchOpRenewBefore)

	if objToUpdate.Spec.EmailAddresses != nil {
		patchValueEmailAddresses :=
			objToUpdate.Spec.EmailAddresses
		patchOpEmailAddresses := PatchOp{
			Op:    "replace",
			Path:  "/spec/emailAddresses",
			Value: patchValueEmailAddresses,
		}
		patch = append(patch, patchOpEmailAddresses)
	}

	if objToUpdate.Spec.Uris != nil {
		patchValueUris :=
			objToUpdate.Spec.Uris
		patchOpUris := PatchOp{
			Op:    "replace",
			Path:  "/spec/uris",
			Value: patchValueUris,
		}
		patch = append(patch, patchOpUris)
	}

	patchValueSecretTemplate :=
		objToUpdate.Spec.SecretTemplate
	patchOpSecretTemplate := PatchOp{
		Op:    "replace",
		Path:  "/spec/secretTemplate",
		Value: patchValueSecretTemplate,
	}
	patch = append(patch, patchOpSecretTemplate)

	patchValueKeyStores :=
		objToUpdate.Spec.KeyStores
	patchOpKeyStores := PatchOp{
		Op:    "replace",
		Path:  "/spec/keyStores",
		Value: patchValueKeyStores,
	}
	patch = append(patch, patchOpKeyStores)

	patchValueIsCA :=
		objToUpdate.Spec.IsCA
	patchOpIsCA := PatchOp{
		Op:    "replace",
		Path:  "/spec/isCA",
		Value: patchValueIsCA,
	}
	patch = append(patch, patchOpIsCA)

	patchValueEncodeUsagesInRequest :=
		objToUpdate.Spec.EncodeUsagesInRequest
	patchOpEncodeUsagesInRequest := PatchOp{
		Op:    "replace",
		Path:  "/spec/encodeUsagesInRequest",
		Value: patchValueEncodeUsagesInRequest,
	}
	patch = append(patch, patchOpEncodeUsagesInRequest)

	patchValueUsages :=
		objToUpdate.Spec.Usages
	patchOpUsages := PatchOp{
		Op:    "replace",
		Path:  "/spec/usages",
		Value: patchValueUsages,
	}
	patch = append(patch, patchOpUsages)

	patchValueRevisionHistoryLimit :=
		objToUpdate.Spec.RevisionHistoryLimit
	patchOpRevisionHistoryLimit := PatchOp{
		Op:    "replace",
		Path:  "/spec/revisionHistoryLimit",
		Value: patchValueRevisionHistoryLimit,
	}
	patch = append(patch, patchOpRevisionHistoryLimit)

	patchValueAdditionalOutputFormats :=
		objToUpdate.Spec.AdditionalOutputFormats
	patchOpAdditionalOutputFormats := PatchOp{
		Op:    "replace",
		Path:  "/spec/additionalOutputFormats",
		Value: patchValueAdditionalOutputFormats,
	}
	patch = append(patch, patchOpAdditionalOutputFormats)

	patchValueStatus :=
		objToUpdate.Spec.Status
	patchOpStatus := PatchOp{
		Op:    "replace",
		Path:  "/spec/status",
		Value: patchValueStatus,
	}
	patch = append(patch, patchOpStatus)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Certificates().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalCertificate{
		client:      group.client,
		Certificate: result,
	}, nil
}

// ListCertificates returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListCertificates(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalCertificate, err error) {
	key := "certificates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalCertificate, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Certificate)
			result[k] = &GlobalCertificate{
				client:      group.client,
				Certificate: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Certificates().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalCertificate, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalCertificate{
				client:      group.client,
				Certificate: &item,
			}
		}
	}
	return
}

type GlobalCertificate struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Certificate
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalCertificate) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteCertificateByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Certificate = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalCertificate) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateCertificateByName(ctx, obj.Certificate)
	if err != nil {
		return err
	}
	obj.Certificate = result.Certificate
	return nil
}

func (obj *GlobalCertificate) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

type certificateGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *certificateGlobalTsmV1Chainer) Subscribe() {
	key := "certificates.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewCertificateInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *certificateGlobalTsmV1Chainer) Unsubscribe() {
	key := "certificates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *certificateGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "certificates.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetClusterConfigFolderByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetClusterConfigFolderByName(ctx context.Context, hashedName string) (*GlobalClusterConfigFolder, error) {
	key := "clusterconfigfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ClusterConfigFolder)
		return &GlobalClusterConfigFolder{
			client:              group.client,
			ClusterConfigFolder: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ClusterConfigFolders().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalClusterConfigFolder{
			client:              group.client,
			ClusterConfigFolder: result,
		}, nil
	}
}

// DeleteClusterConfigFolderByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteClusterConfigFolderByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigFolders().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.ClustersGvk {
		err := group.client.
			Global().DeleteClusterSettingsByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigFolders().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/clustersGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateClusterConfigFolderByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateClusterConfigFolderByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ClusterConfigFolder) (*GlobalClusterConfigFolder, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ClustersGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigFolders().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/clustersGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "ClusterConfigFolder",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalClusterConfigFolder{
		client:              group.client,
		ClusterConfigFolder: result,
	}, nil
}

// UpdateClusterConfigFolderByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateClusterConfigFolderByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ClusterConfigFolder) (*GlobalClusterConfigFolder, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ClusterConfigFolders().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigFolders().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalClusterConfigFolder{
		client:              group.client,
		ClusterConfigFolder: result,
	}, nil
}

// ListClusterConfigFolders returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListClusterConfigFolders(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalClusterConfigFolder, err error) {
	key := "clusterconfigfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalClusterConfigFolder, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ClusterConfigFolder)
			result[k] = &GlobalClusterConfigFolder{
				client:              group.client,
				ClusterConfigFolder: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ClusterConfigFolders().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalClusterConfigFolder, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalClusterConfigFolder{
				client:              group.client,
				ClusterConfigFolder: &item,
			}
		}
	}
	return
}

type GlobalClusterConfigFolder struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ClusterConfigFolder
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalClusterConfigFolder) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteClusterConfigFolderByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ClusterConfigFolder = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalClusterConfigFolder) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateClusterConfigFolderByName(ctx, obj.ClusterConfigFolder)
	if err != nil {
		return err
	}
	obj.ClusterConfigFolder = result.ClusterConfigFolder
	return nil
}

func (obj *GlobalClusterConfigFolder) GetParent(ctx context.Context) (result *GlobalConfig, err error) {
	hashedName := helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetConfigByName(ctx, hashedName)
}

// GetAllClusters returns all children of given type
func (obj *GlobalClusterConfigFolder) GetAllClusters(ctx context.Context) (
	result []*GlobalClusterSettings, err error) {
	result = make([]*GlobalClusterSettings, 0, len(obj.Spec.ClustersGvk))
	for _, v := range obj.Spec.ClustersGvk {
		l, err := obj.client.Global().GetClusterSettingsByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetClusters returns child which has given displayName
func (obj *GlobalClusterConfigFolder) GetClusters(ctx context.Context,
	displayName string) (result *GlobalClusterSettings, err error) {
	l, ok := obj.Spec.ClustersGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ClusterConfigFolder", "Clusters", displayName)
	}
	result, err = obj.client.Global().GetClusterSettingsByName(ctx, l.Name)
	return
}

// AddClusters calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalClusterConfigFolder) AddClusters(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ClusterSettings) (result *GlobalClusterSettings, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["clusterconfigfolders.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["clusterconfigfolders.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateClusterSettingsByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetClusterConfigFolderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ClusterConfigFolder = updatedObj.ClusterConfigFolder
	}
	return
}

// DeleteClusters calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalClusterConfigFolder) DeleteClusters(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ClustersGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ClusterConfigFolder", "Clusters", displayName)
	}
	err = obj.client.Global().DeleteClusterSettingsByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetClusterConfigFolderByName(ctx, obj.GetName())
	if err == nil {
		obj.ClusterConfigFolder = updatedObj.ClusterConfigFolder
	}
	return
}

type clusterconfigfolderGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *clusterconfigfolderGlobalTsmV1Chainer) Subscribe() {
	key := "clusterconfigfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewClusterConfigFolderInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *clusterconfigfolderGlobalTsmV1Chainer) Unsubscribe() {
	key := "clusterconfigfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *clusterconfigfolderGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "clusterconfigfolders.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *clusterconfigfolderGlobalTsmV1Chainer) Clusters(name string) *clustersettingsGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["clustersettingses.global.tsm.tanzu.vmware.com"] = name
	return &clustersettingsGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetClusters calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *clusterconfigfolderGlobalTsmV1Chainer) GetClusters(ctx context.Context, displayName string) (result *GlobalClusterSettings, err error) {
	hashedName := helper.GetHashedName("clustersettingses.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetClusterSettingsByName(ctx, hashedName)
}

// AddClusters calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *clusterconfigfolderGlobalTsmV1Chainer) AddClusters(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ClusterSettings) (result *GlobalClusterSettings, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("clustersettingses.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateClusterSettingsByName(ctx, objToCreate)
}

// DeleteClusters calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *clusterconfigfolderGlobalTsmV1Chainer) DeleteClusters(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("clustersettingses.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteClusterSettingsByName(ctx, hashedName)
}

// GetClusterConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetClusterConfigByName(ctx context.Context, hashedName string) (*GlobalClusterConfig, error) {
	key := "clusterconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ClusterConfig)
		return &GlobalClusterConfig{
			client:        group.client,
			ClusterConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ClusterConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalClusterConfig{
			client:        group.client,
			ClusterConfig: result,
		}, nil
	}
}

// DeleteClusterConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteClusterConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.DomainsGvk {
		err := group.client.
			Global().DeleteDomainConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.HostConfigGvk {
		err := group.client.
			Global().DeleteHostConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.DnsConfigFolderGvk != nil {
		err := group.client.
			Global().
			DeleteDNSConfigFolderByName(ctx, result.Spec.DnsConfigFolderGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.DnsProbesConfigFolderGvk != nil {
		err := group.client.
			Global().
			DeleteDNSProbesConfigFolderByName(ctx, result.Spec.DnsProbesConfigFolderGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.LogFolderGvk != nil {
		err := group.client.
			Global().
			DeleteLogFolderByName(ctx, result.Spec.LogFolderGvk.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.GnsBindingGvk {
		err := group.client.
			Global().DeleteGnsBindingRTByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.SecurityContextConstraintsGvk {
		err := group.client.
			Global().DeleteSecurityContextConstraintsConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.ResourceGroupGvk != nil {
		err := group.client.
			Global().
			DeleteResourceGroupRTByName(ctx, result.Spec.ResourceGroupGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/clustersGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["clusterfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusterfolders.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ClusterFolders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateClusterConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateClusterConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ClusterConfig) (*GlobalClusterConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.DomainsGvk = nil
	objToCreate.Spec.HostConfigGvk = nil
	objToCreate.Spec.DnsConfigFolderGvk = nil
	objToCreate.Spec.DnsProbesConfigFolderGvk = nil
	objToCreate.Spec.LogFolderGvk = nil
	objToCreate.Spec.GnsBindingGvk = nil
	objToCreate.Spec.SecurityContextConstraintsGvk = nil
	objToCreate.Spec.ResourceGroupGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["clusterfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusterfolders.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"clustersGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ClusterConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ClusterFolders().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalClusterConfig{
		client:        group.client,
		ClusterConfig: result,
	}, nil
}

// UpdateClusterConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateClusterConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ClusterConfig) (*GlobalClusterConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ClusterConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalClusterConfig{
		client:        group.client,
		ClusterConfig: result,
	}, nil
}

// ListClusterConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListClusterConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalClusterConfig, err error) {
	key := "clusterconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalClusterConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ClusterConfig)
			result[k] = &GlobalClusterConfig{
				client:        group.client,
				ClusterConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ClusterConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalClusterConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalClusterConfig{
				client:        group.client,
				ClusterConfig: &item,
			}
		}
	}
	return
}

type GlobalClusterConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ClusterConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalClusterConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteClusterConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ClusterConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalClusterConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateClusterConfigByName(ctx, obj.ClusterConfig)
	if err != nil {
		return err
	}
	obj.ClusterConfig = result.ClusterConfig
	return nil
}

func (obj *GlobalClusterConfig) GetParent(ctx context.Context) (result *GlobalClusterFolder, err error) {
	hashedName := helper.GetHashedName("clusterfolders.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["clusterfolders.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetClusterFolderByName(ctx, hashedName)
}

// GetAllDomains returns all children of given type
func (obj *GlobalClusterConfig) GetAllDomains(ctx context.Context) (
	result []*GlobalDomainConfig, err error) {
	result = make([]*GlobalDomainConfig, 0, len(obj.Spec.DomainsGvk))
	for _, v := range obj.Spec.DomainsGvk {
		l, err := obj.client.Global().GetDomainConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetDomains returns child which has given displayName
func (obj *GlobalClusterConfig) GetDomains(ctx context.Context,
	displayName string) (result *GlobalDomainConfig, err error) {
	l, ok := obj.Spec.DomainsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ClusterConfig", "Domains", displayName)
	}
	result, err = obj.client.Global().GetDomainConfigByName(ctx, l.Name)
	return
}

// AddDomains calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalClusterConfig) AddDomains(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DomainConfig) (result *GlobalDomainConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["clusterconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["clusterconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateDomainConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetClusterConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ClusterConfig = updatedObj.ClusterConfig
	}
	return
}

// DeleteDomains calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalClusterConfig) DeleteDomains(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.DomainsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ClusterConfig", "Domains", displayName)
	}
	err = obj.client.Global().DeleteDomainConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetClusterConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.ClusterConfig = updatedObj.ClusterConfig
	}
	return
}

// GetAllHostConfig returns all children of given type
func (obj *GlobalClusterConfig) GetAllHostConfig(ctx context.Context) (
	result []*GlobalHostConfig, err error) {
	result = make([]*GlobalHostConfig, 0, len(obj.Spec.HostConfigGvk))
	for _, v := range obj.Spec.HostConfigGvk {
		l, err := obj.client.Global().GetHostConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetHostConfig returns child which has given displayName
func (obj *GlobalClusterConfig) GetHostConfig(ctx context.Context,
	displayName string) (result *GlobalHostConfig, err error) {
	l, ok := obj.Spec.HostConfigGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ClusterConfig", "HostConfig", displayName)
	}
	result, err = obj.client.Global().GetHostConfigByName(ctx, l.Name)
	return
}

// AddHostConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalClusterConfig) AddHostConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.HostConfig) (result *GlobalHostConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["clusterconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["clusterconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateHostConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetClusterConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ClusterConfig = updatedObj.ClusterConfig
	}
	return
}

// DeleteHostConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalClusterConfig) DeleteHostConfig(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.HostConfigGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ClusterConfig", "HostConfig", displayName)
	}
	err = obj.client.Global().DeleteHostConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetClusterConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.ClusterConfig = updatedObj.ClusterConfig
	}
	return
}

// GetDnsConfigFolder returns child of given type
func (obj *GlobalClusterConfig) GetDnsConfigFolder(ctx context.Context) (
	result *GlobalDNSConfigFolder, err error) {
	if obj.Spec.DnsConfigFolderGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ClusterConfig", "DnsConfigFolder")
	}
	return obj.client.Global().GetDNSConfigFolderByName(ctx, obj.Spec.DnsConfigFolderGvk.Name)
}

// AddDnsConfigFolder calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalClusterConfig) AddDnsConfigFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DNSConfigFolder) (result *GlobalDNSConfigFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["clusterconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["clusterconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateDNSConfigFolderByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetClusterConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ClusterConfig = updatedObj.ClusterConfig
	}
	return
}

// DeleteDnsConfigFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalClusterConfig) DeleteDnsConfigFolder(ctx context.Context) (err error) {
	if obj.Spec.DnsConfigFolderGvk != nil {
		err = obj.client.
			Global().DeleteDNSConfigFolderByName(ctx, obj.Spec.DnsConfigFolderGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetClusterConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.ClusterConfig = updatedObj.ClusterConfig
	}
	return
}

// GetDnsProbesConfigFolder returns child of given type
func (obj *GlobalClusterConfig) GetDnsProbesConfigFolder(ctx context.Context) (
	result *GlobalDNSProbesConfigFolder, err error) {
	if obj.Spec.DnsProbesConfigFolderGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ClusterConfig", "DnsProbesConfigFolder")
	}
	return obj.client.Global().GetDNSProbesConfigFolderByName(ctx, obj.Spec.DnsProbesConfigFolderGvk.Name)
}

// AddDnsProbesConfigFolder calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalClusterConfig) AddDnsProbesConfigFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DNSProbesConfigFolder) (result *GlobalDNSProbesConfigFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["clusterconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["clusterconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateDNSProbesConfigFolderByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetClusterConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ClusterConfig = updatedObj.ClusterConfig
	}
	return
}

// DeleteDnsProbesConfigFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalClusterConfig) DeleteDnsProbesConfigFolder(ctx context.Context) (err error) {
	if obj.Spec.DnsProbesConfigFolderGvk != nil {
		err = obj.client.
			Global().DeleteDNSProbesConfigFolderByName(ctx, obj.Spec.DnsProbesConfigFolderGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetClusterConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.ClusterConfig = updatedObj.ClusterConfig
	}
	return
}

// GetLogFolder returns child of given type
func (obj *GlobalClusterConfig) GetLogFolder(ctx context.Context) (
	result *GlobalLogFolder, err error) {
	if obj.Spec.LogFolderGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ClusterConfig", "LogFolder")
	}
	return obj.client.Global().GetLogFolderByName(ctx, obj.Spec.LogFolderGvk.Name)
}

// AddLogFolder calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalClusterConfig) AddLogFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.LogFolder) (result *GlobalLogFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["clusterconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["clusterconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateLogFolderByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetClusterConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ClusterConfig = updatedObj.ClusterConfig
	}
	return
}

// DeleteLogFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalClusterConfig) DeleteLogFolder(ctx context.Context) (err error) {
	if obj.Spec.LogFolderGvk != nil {
		err = obj.client.
			Global().DeleteLogFolderByName(ctx, obj.Spec.LogFolderGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetClusterConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.ClusterConfig = updatedObj.ClusterConfig
	}
	return
}

// GetAllGnsBinding returns all children of given type
func (obj *GlobalClusterConfig) GetAllGnsBinding(ctx context.Context) (
	result []*GlobalGnsBindingRT, err error) {
	result = make([]*GlobalGnsBindingRT, 0, len(obj.Spec.GnsBindingGvk))
	for _, v := range obj.Spec.GnsBindingGvk {
		l, err := obj.client.Global().GetGnsBindingRTByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGnsBinding returns child which has given displayName
func (obj *GlobalClusterConfig) GetGnsBinding(ctx context.Context,
	displayName string) (result *GlobalGnsBindingRT, err error) {
	l, ok := obj.Spec.GnsBindingGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ClusterConfig", "GnsBinding", displayName)
	}
	result, err = obj.client.Global().GetGnsBindingRTByName(ctx, l.Name)
	return
}

// AddGnsBinding calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalClusterConfig) AddGnsBinding(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsBindingRT) (result *GlobalGnsBindingRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["clusterconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["clusterconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGnsBindingRTByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetClusterConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ClusterConfig = updatedObj.ClusterConfig
	}
	return
}

// DeleteGnsBinding calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalClusterConfig) DeleteGnsBinding(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.GnsBindingGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ClusterConfig", "GnsBinding", displayName)
	}
	err = obj.client.Global().DeleteGnsBindingRTByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetClusterConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.ClusterConfig = updatedObj.ClusterConfig
	}
	return
}

// GetAllSecurityContextConstraints returns all children of given type
func (obj *GlobalClusterConfig) GetAllSecurityContextConstraints(ctx context.Context) (
	result []*GlobalSecurityContextConstraintsConfig, err error) {
	result = make([]*GlobalSecurityContextConstraintsConfig, 0, len(obj.Spec.SecurityContextConstraintsGvk))
	for _, v := range obj.Spec.SecurityContextConstraintsGvk {
		l, err := obj.client.Global().GetSecurityContextConstraintsConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetSecurityContextConstraints returns child which has given displayName
func (obj *GlobalClusterConfig) GetSecurityContextConstraints(ctx context.Context,
	displayName string) (result *GlobalSecurityContextConstraintsConfig, err error) {
	l, ok := obj.Spec.SecurityContextConstraintsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ClusterConfig", "SecurityContextConstraints", displayName)
	}
	result, err = obj.client.Global().GetSecurityContextConstraintsConfigByName(ctx, l.Name)
	return
}

// AddSecurityContextConstraints calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalClusterConfig) AddSecurityContextConstraints(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SecurityContextConstraintsConfig) (result *GlobalSecurityContextConstraintsConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["clusterconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["clusterconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateSecurityContextConstraintsConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetClusterConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ClusterConfig = updatedObj.ClusterConfig
	}
	return
}

// DeleteSecurityContextConstraints calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalClusterConfig) DeleteSecurityContextConstraints(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.SecurityContextConstraintsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ClusterConfig", "SecurityContextConstraints", displayName)
	}
	err = obj.client.Global().DeleteSecurityContextConstraintsConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetClusterConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.ClusterConfig = updatedObj.ClusterConfig
	}
	return
}

// GetResourceGroup returns child of given type
func (obj *GlobalClusterConfig) GetResourceGroup(ctx context.Context) (
	result *GlobalResourceGroupRT, err error) {
	if obj.Spec.ResourceGroupGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ClusterConfig", "ResourceGroup")
	}
	return obj.client.Global().GetResourceGroupRTByName(ctx, obj.Spec.ResourceGroupGvk.Name)
}

// AddResourceGroup calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalClusterConfig) AddResourceGroup(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ResourceGroupRT) (result *GlobalResourceGroupRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["clusterconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["clusterconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateResourceGroupRTByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetClusterConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ClusterConfig = updatedObj.ClusterConfig
	}
	return
}

// DeleteResourceGroup calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalClusterConfig) DeleteResourceGroup(ctx context.Context) (err error) {
	if obj.Spec.ResourceGroupGvk != nil {
		err = obj.client.
			Global().DeleteResourceGroupRTByName(ctx, obj.Spec.ResourceGroupGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetClusterConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.ClusterConfig = updatedObj.ClusterConfig
	}
	return
}

type clusterconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *clusterconfigGlobalTsmV1Chainer) Subscribe() {
	key := "clusterconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewClusterConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *clusterconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "clusterconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *clusterconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "clusterconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *clusterconfigGlobalTsmV1Chainer) Domains(name string) *domainconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["domainconfigs.global.tsm.tanzu.vmware.com"] = name
	return &domainconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetDomains calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *clusterconfigGlobalTsmV1Chainer) GetDomains(ctx context.Context, displayName string) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetDomainConfigByName(ctx, hashedName)
}

// AddDomains calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *clusterconfigGlobalTsmV1Chainer) AddDomains(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DomainConfig) (result *GlobalDomainConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateDomainConfigByName(ctx, objToCreate)
}

// DeleteDomains calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *clusterconfigGlobalTsmV1Chainer) DeleteDomains(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteDomainConfigByName(ctx, hashedName)
}

func (c *clusterconfigGlobalTsmV1Chainer) HostConfig(name string) *hostconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["hostconfigs.global.tsm.tanzu.vmware.com"] = name
	return &hostconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetHostConfig calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *clusterconfigGlobalTsmV1Chainer) GetHostConfig(ctx context.Context, displayName string) (result *GlobalHostConfig, err error) {
	hashedName := helper.GetHashedName("hostconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetHostConfigByName(ctx, hashedName)
}

// AddHostConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *clusterconfigGlobalTsmV1Chainer) AddHostConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.HostConfig) (result *GlobalHostConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("hostconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateHostConfigByName(ctx, objToCreate)
}

// DeleteHostConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *clusterconfigGlobalTsmV1Chainer) DeleteHostConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("hostconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteHostConfigByName(ctx, hashedName)
}

func (c *clusterconfigGlobalTsmV1Chainer) DnsConfigFolder(name string) *dnsconfigfolderGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["dnsconfigfolders.global.tsm.tanzu.vmware.com"] = name
	return &dnsconfigfolderGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetDnsConfigFolder calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *clusterconfigGlobalTsmV1Chainer) GetDnsConfigFolder(ctx context.Context, displayName string) (result *GlobalDNSConfigFolder, err error) {
	hashedName := helper.GetHashedName("dnsconfigfolders.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetDNSConfigFolderByName(ctx, hashedName)
}

// AddDnsConfigFolder calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *clusterconfigGlobalTsmV1Chainer) AddDnsConfigFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DNSConfigFolder) (result *GlobalDNSConfigFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("dnsconfigfolders.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateDNSConfigFolderByName(ctx, objToCreate)
}

// DeleteDnsConfigFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *clusterconfigGlobalTsmV1Chainer) DeleteDnsConfigFolder(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("dnsconfigfolders.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteDNSConfigFolderByName(ctx, hashedName)
}

func (c *clusterconfigGlobalTsmV1Chainer) DnsProbesConfigFolder() *dnsprobesconfigfolderGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["dnsprobesconfigfolders.global.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &dnsprobesconfigfolderGlobalTsmV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetDnsProbesConfigFolder calculates hashed name of the object based on it's parents and returns the object
func (c *clusterconfigGlobalTsmV1Chainer) GetDnsProbesConfigFolder(ctx context.Context) (result *GlobalDNSProbesConfigFolder, err error) {
	hashedName := helper.GetHashedName("dnsprobesconfigfolders.global.tsm.tanzu.vmware.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Global().GetDNSProbesConfigFolderByName(ctx, hashedName)
}

// AddDnsProbesConfigFolder calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *clusterconfigGlobalTsmV1Chainer) AddDnsProbesConfigFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DNSProbesConfigFolder) (result *GlobalDNSProbesConfigFolder, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("dnsprobesconfigfolders.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateDNSProbesConfigFolderByName(ctx, objToCreate)
}

// DeleteDnsProbesConfigFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *clusterconfigGlobalTsmV1Chainer) DeleteDnsProbesConfigFolder(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("dnsprobesconfigfolders.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteDNSProbesConfigFolderByName(ctx, hashedName)
}

func (c *clusterconfigGlobalTsmV1Chainer) LogFolder(name string) *logfolderGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["logfolders.global.tsm.tanzu.vmware.com"] = name
	return &logfolderGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetLogFolder calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *clusterconfigGlobalTsmV1Chainer) GetLogFolder(ctx context.Context, displayName string) (result *GlobalLogFolder, err error) {
	hashedName := helper.GetHashedName("logfolders.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetLogFolderByName(ctx, hashedName)
}

// AddLogFolder calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *clusterconfigGlobalTsmV1Chainer) AddLogFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.LogFolder) (result *GlobalLogFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("logfolders.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateLogFolderByName(ctx, objToCreate)
}

// DeleteLogFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *clusterconfigGlobalTsmV1Chainer) DeleteLogFolder(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("logfolders.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteLogFolderByName(ctx, hashedName)
}

func (c *clusterconfigGlobalTsmV1Chainer) GnsBinding(name string) *gnsbindingrtGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gnsbindingrts.global.tsm.tanzu.vmware.com"] = name
	return &gnsbindingrtGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGnsBinding calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *clusterconfigGlobalTsmV1Chainer) GetGnsBinding(ctx context.Context, displayName string) (result *GlobalGnsBindingRT, err error) {
	hashedName := helper.GetHashedName("gnsbindingrts.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGnsBindingRTByName(ctx, hashedName)
}

// AddGnsBinding calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *clusterconfigGlobalTsmV1Chainer) AddGnsBinding(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsBindingRT) (result *GlobalGnsBindingRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gnsbindingrts.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGnsBindingRTByName(ctx, objToCreate)
}

// DeleteGnsBinding calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *clusterconfigGlobalTsmV1Chainer) DeleteGnsBinding(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gnsbindingrts.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGnsBindingRTByName(ctx, hashedName)
}

func (c *clusterconfigGlobalTsmV1Chainer) SecurityContextConstraints(name string) *securitycontextconstraintsconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["securitycontextconstraintsconfigs.global.tsm.tanzu.vmware.com"] = name
	return &securitycontextconstraintsconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetSecurityContextConstraints calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *clusterconfigGlobalTsmV1Chainer) GetSecurityContextConstraints(ctx context.Context, displayName string) (result *GlobalSecurityContextConstraintsConfig, err error) {
	hashedName := helper.GetHashedName("securitycontextconstraintsconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetSecurityContextConstraintsConfigByName(ctx, hashedName)
}

// AddSecurityContextConstraints calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *clusterconfigGlobalTsmV1Chainer) AddSecurityContextConstraints(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SecurityContextConstraintsConfig) (result *GlobalSecurityContextConstraintsConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("securitycontextconstraintsconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateSecurityContextConstraintsConfigByName(ctx, objToCreate)
}

// DeleteSecurityContextConstraints calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *clusterconfigGlobalTsmV1Chainer) DeleteSecurityContextConstraints(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("securitycontextconstraintsconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteSecurityContextConstraintsConfigByName(ctx, hashedName)
}

func (c *clusterconfigGlobalTsmV1Chainer) ResourceGroup(name string) *resourcegrouprtGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["resourcegrouprts.global.tsm.tanzu.vmware.com"] = name
	return &resourcegrouprtGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetResourceGroup calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *clusterconfigGlobalTsmV1Chainer) GetResourceGroup(ctx context.Context, displayName string) (result *GlobalResourceGroupRT, err error) {
	hashedName := helper.GetHashedName("resourcegrouprts.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetResourceGroupRTByName(ctx, hashedName)
}

// AddResourceGroup calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *clusterconfigGlobalTsmV1Chainer) AddResourceGroup(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ResourceGroupRT) (result *GlobalResourceGroupRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("resourcegrouprts.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateResourceGroupRTByName(ctx, objToCreate)
}

// DeleteResourceGroup calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *clusterconfigGlobalTsmV1Chainer) DeleteResourceGroup(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("resourcegrouprts.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteResourceGroupRTByName(ctx, hashedName)
}

// GetClusterFolderByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetClusterFolderByName(ctx context.Context, hashedName string) (*GlobalClusterFolder, error) {
	key := "clusterfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ClusterFolder)
		return &GlobalClusterFolder{
			client:        group.client,
			ClusterFolder: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ClusterFolders().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalClusterFolder{
			client:        group.client,
			ClusterFolder: result,
		}, nil
	}
}

// DeleteClusterFolderByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteClusterFolderByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ClusterFolders().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.ClustersGvk {
		err := group.client.
			Global().DeleteClusterConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.RemoteGatewayServiceConfigsGvk {
		err := group.client.
			Global().DeleteRemoteGatewayServiceConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ClusterFolders().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/clusterFolderGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["runtimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateClusterFolderByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateClusterFolderByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ClusterFolder) (*GlobalClusterFolder, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ClustersGvk = nil
	objToCreate.Spec.RemoteGatewayServiceConfigsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ClusterFolders().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["runtimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/clusterFolderGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "ClusterFolder",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalClusterFolder{
		client:        group.client,
		ClusterFolder: result,
	}, nil
}

// UpdateClusterFolderByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateClusterFolderByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ClusterFolder) (*GlobalClusterFolder, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ClusterFolders().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ClusterFolders().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalClusterFolder{
		client:        group.client,
		ClusterFolder: result,
	}, nil
}

// ListClusterFolders returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListClusterFolders(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalClusterFolder, err error) {
	key := "clusterfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalClusterFolder, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ClusterFolder)
			result[k] = &GlobalClusterFolder{
				client:        group.client,
				ClusterFolder: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ClusterFolders().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalClusterFolder, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalClusterFolder{
				client:        group.client,
				ClusterFolder: &item,
			}
		}
	}
	return
}

type GlobalClusterFolder struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ClusterFolder
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalClusterFolder) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteClusterFolderByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ClusterFolder = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalClusterFolder) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateClusterFolderByName(ctx, obj.ClusterFolder)
	if err != nil {
		return err
	}
	obj.ClusterFolder = result.ClusterFolder
	return nil
}

func (obj *GlobalClusterFolder) GetParent(ctx context.Context) (result *GlobalRuntime, err error) {
	hashedName := helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["runtimes.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetRuntimeByName(ctx, hashedName)
}

// GetAllClusters returns all children of given type
func (obj *GlobalClusterFolder) GetAllClusters(ctx context.Context) (
	result []*GlobalClusterConfig, err error) {
	result = make([]*GlobalClusterConfig, 0, len(obj.Spec.ClustersGvk))
	for _, v := range obj.Spec.ClustersGvk {
		l, err := obj.client.Global().GetClusterConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetClusters returns child which has given displayName
func (obj *GlobalClusterFolder) GetClusters(ctx context.Context,
	displayName string) (result *GlobalClusterConfig, err error) {
	l, ok := obj.Spec.ClustersGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ClusterFolder", "Clusters", displayName)
	}
	result, err = obj.client.Global().GetClusterConfigByName(ctx, l.Name)
	return
}

// AddClusters calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalClusterFolder) AddClusters(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ClusterConfig) (result *GlobalClusterConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["clusterfolders.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["clusterfolders.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateClusterConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetClusterFolderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ClusterFolder = updatedObj.ClusterFolder
	}
	return
}

// DeleteClusters calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalClusterFolder) DeleteClusters(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ClustersGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ClusterFolder", "Clusters", displayName)
	}
	err = obj.client.Global().DeleteClusterConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetClusterFolderByName(ctx, obj.GetName())
	if err == nil {
		obj.ClusterFolder = updatedObj.ClusterFolder
	}
	return
}

// GetAllRemoteGatewayServiceConfigs returns all children of given type
func (obj *GlobalClusterFolder) GetAllRemoteGatewayServiceConfigs(ctx context.Context) (
	result []*GlobalRemoteGatewayServiceConfig, err error) {
	result = make([]*GlobalRemoteGatewayServiceConfig, 0, len(obj.Spec.RemoteGatewayServiceConfigsGvk))
	for _, v := range obj.Spec.RemoteGatewayServiceConfigsGvk {
		l, err := obj.client.Global().GetRemoteGatewayServiceConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetRemoteGatewayServiceConfigs returns child which has given displayName
func (obj *GlobalClusterFolder) GetRemoteGatewayServiceConfigs(ctx context.Context,
	displayName string) (result *GlobalRemoteGatewayServiceConfig, err error) {
	l, ok := obj.Spec.RemoteGatewayServiceConfigsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ClusterFolder", "RemoteGatewayServiceConfigs", displayName)
	}
	result, err = obj.client.Global().GetRemoteGatewayServiceConfigByName(ctx, l.Name)
	return
}

// AddRemoteGatewayServiceConfigs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalClusterFolder) AddRemoteGatewayServiceConfigs(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.RemoteGatewayServiceConfig) (result *GlobalRemoteGatewayServiceConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["clusterfolders.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["clusterfolders.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateRemoteGatewayServiceConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetClusterFolderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ClusterFolder = updatedObj.ClusterFolder
	}
	return
}

// DeleteRemoteGatewayServiceConfigs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalClusterFolder) DeleteRemoteGatewayServiceConfigs(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.RemoteGatewayServiceConfigsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ClusterFolder", "RemoteGatewayServiceConfigs", displayName)
	}
	err = obj.client.Global().DeleteRemoteGatewayServiceConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetClusterFolderByName(ctx, obj.GetName())
	if err == nil {
		obj.ClusterFolder = updatedObj.ClusterFolder
	}
	return
}

type clusterfolderGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *clusterfolderGlobalTsmV1Chainer) Subscribe() {
	key := "clusterfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewClusterFolderInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *clusterfolderGlobalTsmV1Chainer) Unsubscribe() {
	key := "clusterfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *clusterfolderGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "clusterfolders.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *clusterfolderGlobalTsmV1Chainer) Clusters(name string) *clusterconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["clusterconfigs.global.tsm.tanzu.vmware.com"] = name
	return &clusterconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetClusters calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *clusterfolderGlobalTsmV1Chainer) GetClusters(ctx context.Context, displayName string) (result *GlobalClusterConfig, err error) {
	hashedName := helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetClusterConfigByName(ctx, hashedName)
}

// AddClusters calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *clusterfolderGlobalTsmV1Chainer) AddClusters(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ClusterConfig) (result *GlobalClusterConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateClusterConfigByName(ctx, objToCreate)
}

// DeleteClusters calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *clusterfolderGlobalTsmV1Chainer) DeleteClusters(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteClusterConfigByName(ctx, hashedName)
}

func (c *clusterfolderGlobalTsmV1Chainer) RemoteGatewayServiceConfigs(name string) *remotegatewayserviceconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["remotegatewayserviceconfigs.global.tsm.tanzu.vmware.com"] = name
	return &remotegatewayserviceconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetRemoteGatewayServiceConfigs calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *clusterfolderGlobalTsmV1Chainer) GetRemoteGatewayServiceConfigs(ctx context.Context, displayName string) (result *GlobalRemoteGatewayServiceConfig, err error) {
	hashedName := helper.GetHashedName("remotegatewayserviceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetRemoteGatewayServiceConfigByName(ctx, hashedName)
}

// AddRemoteGatewayServiceConfigs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *clusterfolderGlobalTsmV1Chainer) AddRemoteGatewayServiceConfigs(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.RemoteGatewayServiceConfig) (result *GlobalRemoteGatewayServiceConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("remotegatewayserviceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateRemoteGatewayServiceConfigByName(ctx, objToCreate)
}

// DeleteRemoteGatewayServiceConfigs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *clusterfolderGlobalTsmV1Chainer) DeleteRemoteGatewayServiceConfigs(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("remotegatewayserviceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteRemoteGatewayServiceConfigByName(ctx, hashedName)
}

// GetClusterSettingsByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetClusterSettingsByName(ctx context.Context, hashedName string) (*GlobalClusterSettings, error) {
	key := "clustersettingses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ClusterSettings)
		return &GlobalClusterSettings{
			client:          group.client,
			ClusterSettings: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ClusterSettingses().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalClusterSettings{
			client:          group.client,
			ClusterSettings: result,
		}, nil
	}
}

// DeleteClusterSettingsByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteClusterSettingsByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ClusterSettingses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ClusterSettingses().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/clustersGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["clusterconfigfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusterconfigfolders.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigFolders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateClusterSettingsByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateClusterSettingsByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ClusterSettings) (*GlobalClusterSettings, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ClusterSettingses().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["clusterconfigfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusterconfigfolders.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"clustersGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ClusterSettings\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigFolders().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalClusterSettings{
		client:          group.client,
		ClusterSettings: result,
	}, nil
}

// UpdateClusterSettingsByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateClusterSettingsByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ClusterSettings) (*GlobalClusterSettings, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ClusterSettingses().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueProjectId :=
		objToUpdate.Spec.ProjectId
	patchOpProjectId := PatchOp{
		Op:    "replace",
		Path:  "/spec/projectId",
		Value: patchValueProjectId,
	}
	patch = append(patch, patchOpProjectId)

	patchValueDisplayName :=
		objToUpdate.Spec.DisplayName
	patchOpDisplayName := PatchOp{
		Op:    "replace",
		Path:  "/spec/displayName",
		Value: patchValueDisplayName,
	}
	patch = append(patch, patchOpDisplayName)

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueTags :=
		objToUpdate.Spec.Tags
	patchOpTags := PatchOp{
		Op:    "replace",
		Path:  "/spec/tags",
		Value: patchValueTags,
	}
	patch = append(patch, patchOpTags)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueAutoInstallServiceMesh :=
		objToUpdate.Spec.AutoInstallServiceMesh
	patchOpAutoInstallServiceMesh := PatchOp{
		Op:    "replace",
		Path:  "/spec/autoInstallServiceMesh",
		Value: patchValueAutoInstallServiceMesh,
	}
	patch = append(patch, patchOpAutoInstallServiceMesh)

	patchValueEnableNamespaceExclusions :=
		objToUpdate.Spec.EnableNamespaceExclusions
	patchOpEnableNamespaceExclusions := PatchOp{
		Op:    "replace",
		Path:  "/spec/enableNamespaceExclusions",
		Value: patchValueEnableNamespaceExclusions,
	}
	patch = append(patch, patchOpEnableNamespaceExclusions)

	patchValueNamespaceExclusions :=
		objToUpdate.Spec.NamespaceExclusions
	patchOpNamespaceExclusions := PatchOp{
		Op:    "replace",
		Path:  "/spec/namespaceExclusions",
		Value: patchValueNamespaceExclusions,
	}
	patch = append(patch, patchOpNamespaceExclusions)

	patchValueSystemNamespaceExclusions :=
		objToUpdate.Spec.SystemNamespaceExclusions
	patchOpSystemNamespaceExclusions := PatchOp{
		Op:    "replace",
		Path:  "/spec/systemNamespaceExclusions",
		Value: patchValueSystemNamespaceExclusions,
	}
	patch = append(patch, patchOpSystemNamespaceExclusions)

	patchValueAgentDomain :=
		objToUpdate.Spec.AgentDomain
	patchOpAgentDomain := PatchOp{
		Op:    "replace",
		Path:  "/spec/agentDomain",
		Value: patchValueAgentDomain,
	}
	patch = append(patch, patchOpAgentDomain)

	patchValueProxyConfig :=
		objToUpdate.Spec.ProxyConfig
	patchOpProxyConfig := PatchOp{
		Op:    "replace",
		Path:  "/spec/proxyConfig",
		Value: patchValueProxyConfig,
	}
	patch = append(patch, patchOpProxyConfig)

	patchValueAutoInstallServiceMeshConfig :=
		objToUpdate.Spec.AutoInstallServiceMeshConfig
	patchOpAutoInstallServiceMeshConfig := PatchOp{
		Op:    "replace",
		Path:  "/spec/autoInstallServiceMeshConfig",
		Value: patchValueAutoInstallServiceMeshConfig,
	}
	patch = append(patch, patchOpAutoInstallServiceMeshConfig)

	patchValueRegistryAccount :=
		objToUpdate.Spec.RegistryAccount
	patchOpRegistryAccount := PatchOp{
		Op:    "replace",
		Path:  "/spec/registryAccount",
		Value: patchValueRegistryAccount,
	}
	patch = append(patch, patchOpRegistryAccount)

	patchValueCaLabels :=
		objToUpdate.Spec.CaLabels
	patchOpCaLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/caLabels",
		Value: patchValueCaLabels,
	}
	patch = append(patch, patchOpCaLabels)

	patchValueEnableInternalGateway :=
		objToUpdate.Spec.EnableInternalGateway
	patchOpEnableInternalGateway := PatchOp{
		Op:    "replace",
		Path:  "/spec/enableInternalGateway",
		Value: patchValueEnableInternalGateway,
	}
	patch = append(patch, patchOpEnableInternalGateway)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ClusterSettingses().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalClusterSettings{
		client:          group.client,
		ClusterSettings: result,
	}, nil
}

// ListClusterSettingses returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListClusterSettingses(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalClusterSettings, err error) {
	key := "clustersettingses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalClusterSettings, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ClusterSettings)
			result[k] = &GlobalClusterSettings{
				client:          group.client,
				ClusterSettings: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ClusterSettingses().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalClusterSettings, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalClusterSettings{
				client:          group.client,
				ClusterSettings: &item,
			}
		}
	}
	return
}

type GlobalClusterSettings struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ClusterSettings
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalClusterSettings) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteClusterSettingsByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ClusterSettings = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalClusterSettings) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateClusterSettingsByName(ctx, obj.ClusterSettings)
	if err != nil {
		return err
	}
	obj.ClusterSettings = result.ClusterSettings
	return nil
}

func (obj *GlobalClusterSettings) GetParent(ctx context.Context) (result *GlobalClusterConfigFolder, err error) {
	hashedName := helper.GetHashedName("clusterconfigfolders.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["clusterconfigfolders.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetClusterConfigFolderByName(ctx, hashedName)
}

type clustersettingsGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *clustersettingsGlobalTsmV1Chainer) Subscribe() {
	key := "clustersettingses.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewClusterSettingsInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *clustersettingsGlobalTsmV1Chainer) Unsubscribe() {
	key := "clustersettingses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *clustersettingsGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "clustersettingses.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetClusterByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetClusterByName(ctx context.Context, hashedName string) (*GlobalCluster, error) {
	key := "clusters.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Cluster)
		return &GlobalCluster{
			client:  group.client,
			Cluster: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Clusters().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalCluster{
			client:  group.client,
			Cluster: result,
		}, nil
	}
}

// DeleteClusterByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteClusterByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Clusters().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.ConnectionStatusGvk != nil {
		err := group.client.
			Global().
			DeleteConnectionStatusByName(ctx, result.Spec.ConnectionStatusGvk.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.AppsGvk {
		err := group.client.
			Global().DeleteApplicationInfoByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.DnsProbeStatusGvk {
		err := group.client.
			Global().DeleteDNSProbeStatusByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.SecurityContextConstraintsGvk {
		err := group.client.
			Global().DeleteSecurityContextConstraintsByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.DomainsGvk {
		err := group.client.
			Global().DeleteDomainByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.NodesGvk {
		err := group.client.
			Global().DeleteNodeByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Clusters().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/clustersGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["inventories.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("inventories.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Inventories().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateClusterByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateClusterByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Cluster) (*GlobalCluster, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ConnectionStatusGvk = nil
	objToCreate.Spec.AppsGvk = nil
	objToCreate.Spec.DnsProbeStatusGvk = nil
	objToCreate.Spec.SecurityContextConstraintsGvk = nil
	objToCreate.Spec.DomainsGvk = nil
	objToCreate.Spec.NodesGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Clusters().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["inventories.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("inventories.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"clustersGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"Cluster\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Inventories().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalCluster{
		client:  group.client,
		Cluster: result,
	}, nil
}

// UpdateClusterByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateClusterByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Cluster) (*GlobalCluster, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Clusters().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueUuid :=
		objToUpdate.Spec.Uuid
	patchOpUuid := PatchOp{
		Op:    "replace",
		Path:  "/spec/uuid",
		Value: patchValueUuid,
	}
	patch = append(patch, patchOpUuid)

	patchValueConnected :=
		objToUpdate.Spec.Connected
	patchOpConnected := PatchOp{
		Op:    "replace",
		Path:  "/spec/connected",
		Value: patchValueConnected,
	}
	patch = append(patch, patchOpConnected)

	patchValueIstioState :=
		objToUpdate.Spec.IstioState
	patchOpIstioState := PatchOp{
		Op:    "replace",
		Path:  "/spec/istioState",
		Value: patchValueIstioState,
	}
	patch = append(patch, patchOpIstioState)

	patchValueStatus :=
		objToUpdate.Spec.Status
	patchOpStatus := PatchOp{
		Op:    "replace",
		Path:  "/spec/status",
		Value: patchValueStatus,
	}
	patch = append(patch, patchOpStatus)

	patchValueStatusHistory :=
		objToUpdate.Spec.StatusHistory
	patchOpStatusHistory := PatchOp{
		Op:    "replace",
		Path:  "/spec/statusHistory",
		Value: patchValueStatusHistory,
	}
	patch = append(patch, patchOpStatusHistory)

	patchValueCastatus :=
		objToUpdate.Spec.Castatus
	patchOpCastatus := PatchOp{
		Op:    "replace",
		Path:  "/spec/castatus",
		Value: patchValueCastatus,
	}
	patch = append(patch, patchOpCastatus)

	patchValueCaStatusHistory :=
		objToUpdate.Spec.CaStatusHistory
	patchOpCaStatusHistory := PatchOp{
		Op:    "replace",
		Path:  "/spec/caStatusHistory",
		Value: patchValueCaStatusHistory,
	}
	patch = append(patch, patchOpCaStatusHistory)

	patchValueComponentStatuses :=
		objToUpdate.Spec.ComponentStatuses
	patchOpComponentStatuses := PatchOp{
		Op:    "replace",
		Path:  "/spec/componentStatuses",
		Value: patchValueComponentStatuses,
	}
	patch = append(patch, patchOpComponentStatuses)

	patchValueComponentStatusesHistory :=
		objToUpdate.Spec.ComponentStatusesHistory
	patchOpComponentStatusesHistory := PatchOp{
		Op:    "replace",
		Path:  "/spec/componentStatusesHistory",
		Value: patchValueComponentStatusesHistory,
	}
	patch = append(patch, patchOpComponentStatusesHistory)

	patchValueType :=
		objToUpdate.Spec.Type
	patchOpType := PatchOp{
		Op:    "replace",
		Path:  "/spec/type",
		Value: patchValueType,
	}
	patch = append(patch, patchOpType)

	patchValueProjectId :=
		objToUpdate.Spec.ProjectId
	patchOpProjectId := PatchOp{
		Op:    "replace",
		Path:  "/spec/projectId",
		Value: patchValueProjectId,
	}
	patch = append(patch, patchOpProjectId)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Clusters().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalCluster{
		client:  group.client,
		Cluster: result,
	}, nil
}

// ListClusters returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListClusters(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalCluster, err error) {
	key := "clusters.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalCluster, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Cluster)
			result[k] = &GlobalCluster{
				client:  group.client,
				Cluster: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Clusters().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalCluster, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalCluster{
				client:  group.client,
				Cluster: &item,
			}
		}
	}
	return
}

type GlobalCluster struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Cluster
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalCluster) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteClusterByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Cluster = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalCluster) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateClusterByName(ctx, obj.Cluster)
	if err != nil {
		return err
	}
	obj.Cluster = result.Cluster
	return nil
}

func (obj *GlobalCluster) GetParent(ctx context.Context) (result *GlobalInventory, err error) {
	hashedName := helper.GetHashedName("inventories.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["inventories.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetInventoryByName(ctx, hashedName)
}

// GetConnectionStatus returns child of given type
func (obj *GlobalCluster) GetConnectionStatus(ctx context.Context) (
	result *GlobalConnectionStatus, err error) {
	if obj.Spec.ConnectionStatusGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Cluster", "ConnectionStatus")
	}
	return obj.client.Global().GetConnectionStatusByName(ctx, obj.Spec.ConnectionStatusGvk.Name)
}

// AddConnectionStatus calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalCluster) AddConnectionStatus(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ConnectionStatus) (result *GlobalConnectionStatus, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["clusters.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["clusters.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateConnectionStatusByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetClusterByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Cluster = updatedObj.Cluster
	}
	return
}

// DeleteConnectionStatus calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalCluster) DeleteConnectionStatus(ctx context.Context) (err error) {
	if obj.Spec.ConnectionStatusGvk != nil {
		err = obj.client.
			Global().DeleteConnectionStatusByName(ctx, obj.Spec.ConnectionStatusGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetClusterByName(ctx, obj.GetName())
	if err == nil {
		obj.Cluster = updatedObj.Cluster
	}
	return
}

// GetAllApps returns all children of given type
func (obj *GlobalCluster) GetAllApps(ctx context.Context) (
	result []*GlobalApplicationInfo, err error) {
	result = make([]*GlobalApplicationInfo, 0, len(obj.Spec.AppsGvk))
	for _, v := range obj.Spec.AppsGvk {
		l, err := obj.client.Global().GetApplicationInfoByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetApps returns child which has given displayName
func (obj *GlobalCluster) GetApps(ctx context.Context,
	displayName string) (result *GlobalApplicationInfo, err error) {
	l, ok := obj.Spec.AppsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Cluster", "Apps", displayName)
	}
	result, err = obj.client.Global().GetApplicationInfoByName(ctx, l.Name)
	return
}

// AddApps calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalCluster) AddApps(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ApplicationInfo) (result *GlobalApplicationInfo, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["clusters.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["clusters.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateApplicationInfoByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetClusterByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Cluster = updatedObj.Cluster
	}
	return
}

// DeleteApps calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalCluster) DeleteApps(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.AppsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Cluster", "Apps", displayName)
	}
	err = obj.client.Global().DeleteApplicationInfoByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetClusterByName(ctx, obj.GetName())
	if err == nil {
		obj.Cluster = updatedObj.Cluster
	}
	return
}

// GetAllDnsProbeStatus returns all children of given type
func (obj *GlobalCluster) GetAllDnsProbeStatus(ctx context.Context) (
	result []*GlobalDNSProbeStatus, err error) {
	result = make([]*GlobalDNSProbeStatus, 0, len(obj.Spec.DnsProbeStatusGvk))
	for _, v := range obj.Spec.DnsProbeStatusGvk {
		l, err := obj.client.Global().GetDNSProbeStatusByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetDnsProbeStatus returns child which has given displayName
func (obj *GlobalCluster) GetDnsProbeStatus(ctx context.Context,
	displayName string) (result *GlobalDNSProbeStatus, err error) {
	l, ok := obj.Spec.DnsProbeStatusGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Cluster", "DnsProbeStatus", displayName)
	}
	result, err = obj.client.Global().GetDNSProbeStatusByName(ctx, l.Name)
	return
}

// AddDnsProbeStatus calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalCluster) AddDnsProbeStatus(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DNSProbeStatus) (result *GlobalDNSProbeStatus, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["clusters.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["clusters.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateDNSProbeStatusByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetClusterByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Cluster = updatedObj.Cluster
	}
	return
}

// DeleteDnsProbeStatus calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalCluster) DeleteDnsProbeStatus(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.DnsProbeStatusGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Cluster", "DnsProbeStatus", displayName)
	}
	err = obj.client.Global().DeleteDNSProbeStatusByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetClusterByName(ctx, obj.GetName())
	if err == nil {
		obj.Cluster = updatedObj.Cluster
	}
	return
}

// GetAllSecurityContextConstraints returns all children of given type
func (obj *GlobalCluster) GetAllSecurityContextConstraints(ctx context.Context) (
	result []*GlobalSecurityContextConstraints, err error) {
	result = make([]*GlobalSecurityContextConstraints, 0, len(obj.Spec.SecurityContextConstraintsGvk))
	for _, v := range obj.Spec.SecurityContextConstraintsGvk {
		l, err := obj.client.Global().GetSecurityContextConstraintsByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetSecurityContextConstraints returns child which has given displayName
func (obj *GlobalCluster) GetSecurityContextConstraints(ctx context.Context,
	displayName string) (result *GlobalSecurityContextConstraints, err error) {
	l, ok := obj.Spec.SecurityContextConstraintsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Cluster", "SecurityContextConstraints", displayName)
	}
	result, err = obj.client.Global().GetSecurityContextConstraintsByName(ctx, l.Name)
	return
}

// AddSecurityContextConstraints calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalCluster) AddSecurityContextConstraints(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SecurityContextConstraints) (result *GlobalSecurityContextConstraints, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["clusters.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["clusters.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateSecurityContextConstraintsByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetClusterByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Cluster = updatedObj.Cluster
	}
	return
}

// DeleteSecurityContextConstraints calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalCluster) DeleteSecurityContextConstraints(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.SecurityContextConstraintsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Cluster", "SecurityContextConstraints", displayName)
	}
	err = obj.client.Global().DeleteSecurityContextConstraintsByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetClusterByName(ctx, obj.GetName())
	if err == nil {
		obj.Cluster = updatedObj.Cluster
	}
	return
}

// GetAllDomains returns all children of given type
func (obj *GlobalCluster) GetAllDomains(ctx context.Context) (
	result []*GlobalDomain, err error) {
	result = make([]*GlobalDomain, 0, len(obj.Spec.DomainsGvk))
	for _, v := range obj.Spec.DomainsGvk {
		l, err := obj.client.Global().GetDomainByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetDomains returns child which has given displayName
func (obj *GlobalCluster) GetDomains(ctx context.Context,
	displayName string) (result *GlobalDomain, err error) {
	l, ok := obj.Spec.DomainsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Cluster", "Domains", displayName)
	}
	result, err = obj.client.Global().GetDomainByName(ctx, l.Name)
	return
}

// AddDomains calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalCluster) AddDomains(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Domain) (result *GlobalDomain, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["clusters.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["clusters.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateDomainByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetClusterByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Cluster = updatedObj.Cluster
	}
	return
}

// DeleteDomains calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalCluster) DeleteDomains(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.DomainsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Cluster", "Domains", displayName)
	}
	err = obj.client.Global().DeleteDomainByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetClusterByName(ctx, obj.GetName())
	if err == nil {
		obj.Cluster = updatedObj.Cluster
	}
	return
}

// GetAllNodes returns all children of given type
func (obj *GlobalCluster) GetAllNodes(ctx context.Context) (
	result []*GlobalNode, err error) {
	result = make([]*GlobalNode, 0, len(obj.Spec.NodesGvk))
	for _, v := range obj.Spec.NodesGvk {
		l, err := obj.client.Global().GetNodeByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetNodes returns child which has given displayName
func (obj *GlobalCluster) GetNodes(ctx context.Context,
	displayName string) (result *GlobalNode, err error) {
	l, ok := obj.Spec.NodesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Cluster", "Nodes", displayName)
	}
	result, err = obj.client.Global().GetNodeByName(ctx, l.Name)
	return
}

// AddNodes calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalCluster) AddNodes(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Node) (result *GlobalNode, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["clusters.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["clusters.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateNodeByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetClusterByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Cluster = updatedObj.Cluster
	}
	return
}

// DeleteNodes calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalCluster) DeleteNodes(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.NodesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Cluster", "Nodes", displayName)
	}
	err = obj.client.Global().DeleteNodeByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetClusterByName(ctx, obj.GetName())
	if err == nil {
		obj.Cluster = updatedObj.Cluster
	}
	return
}

type clusterGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *clusterGlobalTsmV1Chainer) Subscribe() {
	key := "clusters.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewClusterInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *clusterGlobalTsmV1Chainer) Unsubscribe() {
	key := "clusters.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *clusterGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "clusters.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *clusterGlobalTsmV1Chainer) ConnectionStatus(name string) *connectionstatusGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["connectionstatuses.global.tsm.tanzu.vmware.com"] = name
	return &connectionstatusGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetConnectionStatus calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *clusterGlobalTsmV1Chainer) GetConnectionStatus(ctx context.Context, displayName string) (result *GlobalConnectionStatus, err error) {
	hashedName := helper.GetHashedName("connectionstatuses.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetConnectionStatusByName(ctx, hashedName)
}

// AddConnectionStatus calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *clusterGlobalTsmV1Chainer) AddConnectionStatus(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ConnectionStatus) (result *GlobalConnectionStatus, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("connectionstatuses.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateConnectionStatusByName(ctx, objToCreate)
}

// DeleteConnectionStatus calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *clusterGlobalTsmV1Chainer) DeleteConnectionStatus(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("connectionstatuses.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteConnectionStatusByName(ctx, hashedName)
}

func (c *clusterGlobalTsmV1Chainer) Apps(name string) *applicationinfoGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["applicationinfos.global.tsm.tanzu.vmware.com"] = name
	return &applicationinfoGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetApps calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *clusterGlobalTsmV1Chainer) GetApps(ctx context.Context, displayName string) (result *GlobalApplicationInfo, err error) {
	hashedName := helper.GetHashedName("applicationinfos.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetApplicationInfoByName(ctx, hashedName)
}

// AddApps calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *clusterGlobalTsmV1Chainer) AddApps(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ApplicationInfo) (result *GlobalApplicationInfo, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("applicationinfos.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateApplicationInfoByName(ctx, objToCreate)
}

// DeleteApps calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *clusterGlobalTsmV1Chainer) DeleteApps(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("applicationinfos.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteApplicationInfoByName(ctx, hashedName)
}

func (c *clusterGlobalTsmV1Chainer) DnsProbeStatus(name string) *dnsprobestatusGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["dnsprobestatuses.global.tsm.tanzu.vmware.com"] = name
	return &dnsprobestatusGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetDnsProbeStatus calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *clusterGlobalTsmV1Chainer) GetDnsProbeStatus(ctx context.Context, displayName string) (result *GlobalDNSProbeStatus, err error) {
	hashedName := helper.GetHashedName("dnsprobestatuses.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetDNSProbeStatusByName(ctx, hashedName)
}

// AddDnsProbeStatus calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *clusterGlobalTsmV1Chainer) AddDnsProbeStatus(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DNSProbeStatus) (result *GlobalDNSProbeStatus, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("dnsprobestatuses.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateDNSProbeStatusByName(ctx, objToCreate)
}

// DeleteDnsProbeStatus calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *clusterGlobalTsmV1Chainer) DeleteDnsProbeStatus(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("dnsprobestatuses.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteDNSProbeStatusByName(ctx, hashedName)
}

func (c *clusterGlobalTsmV1Chainer) SecurityContextConstraints(name string) *securitycontextconstraintsGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["securitycontextconstraintses.global.tsm.tanzu.vmware.com"] = name
	return &securitycontextconstraintsGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetSecurityContextConstraints calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *clusterGlobalTsmV1Chainer) GetSecurityContextConstraints(ctx context.Context, displayName string) (result *GlobalSecurityContextConstraints, err error) {
	hashedName := helper.GetHashedName("securitycontextconstraintses.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetSecurityContextConstraintsByName(ctx, hashedName)
}

// AddSecurityContextConstraints calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *clusterGlobalTsmV1Chainer) AddSecurityContextConstraints(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SecurityContextConstraints) (result *GlobalSecurityContextConstraints, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("securitycontextconstraintses.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateSecurityContextConstraintsByName(ctx, objToCreate)
}

// DeleteSecurityContextConstraints calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *clusterGlobalTsmV1Chainer) DeleteSecurityContextConstraints(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("securitycontextconstraintses.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteSecurityContextConstraintsByName(ctx, hashedName)
}

func (c *clusterGlobalTsmV1Chainer) Domains(name string) *domainGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["domains.global.tsm.tanzu.vmware.com"] = name
	return &domainGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetDomains calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *clusterGlobalTsmV1Chainer) GetDomains(ctx context.Context, displayName string) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetDomainByName(ctx, hashedName)
}

// AddDomains calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *clusterGlobalTsmV1Chainer) AddDomains(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Domain) (result *GlobalDomain, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateDomainByName(ctx, objToCreate)
}

// DeleteDomains calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *clusterGlobalTsmV1Chainer) DeleteDomains(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteDomainByName(ctx, hashedName)
}

func (c *clusterGlobalTsmV1Chainer) Nodes(name string) *nodeGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["nodes.global.tsm.tanzu.vmware.com"] = name
	return &nodeGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetNodes calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *clusterGlobalTsmV1Chainer) GetNodes(ctx context.Context, displayName string) (result *GlobalNode, err error) {
	hashedName := helper.GetHashedName("nodes.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetNodeByName(ctx, hashedName)
}

// AddNodes calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *clusterGlobalTsmV1Chainer) AddNodes(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Node) (result *GlobalNode, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("nodes.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateNodeByName(ctx, objToCreate)
}

// DeleteNodes calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *clusterGlobalTsmV1Chainer) DeleteNodes(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("nodes.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteNodeByName(ctx, hashedName)
}

// GetConfigMapByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetConfigMapByName(ctx context.Context, hashedName string) (*GlobalConfigMap, error) {
	key := "configmaps.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ConfigMap)
		return &GlobalConfigMap{
			client:    group.client,
			ConfigMap: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ConfigMaps().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalConfigMap{
			client:    group.client,
			ConfigMap: result,
		}, nil
	}
}

// DeleteConfigMapByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteConfigMapByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ConfigMaps().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ConfigMaps().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/configmapGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateConfigMapByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateConfigMapByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ConfigMap) (*GlobalConfigMap, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ConfigMaps().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"configmapGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ConfigMap\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalConfigMap{
		client:    group.client,
		ConfigMap: result,
	}, nil
}

// UpdateConfigMapByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateConfigMapByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ConfigMap) (*GlobalConfigMap, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ConfigMaps().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueAnnotations :=
		objToUpdate.Spec.Annotations
	patchOpAnnotations := PatchOp{
		Op:    "replace",
		Path:  "/spec/annotations",
		Value: patchValueAnnotations,
	}
	patch = append(patch, patchOpAnnotations)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueMetadata :=
		objToUpdate.Spec.Metadata
	patchOpMetadata := PatchOp{
		Op:    "replace",
		Path:  "/spec/metadata",
		Value: patchValueMetadata,
	}
	patch = append(patch, patchOpMetadata)

	patchValueData :=
		objToUpdate.Spec.Data
	patchOpData := PatchOp{
		Op:    "replace",
		Path:  "/spec/data",
		Value: patchValueData,
	}
	patch = append(patch, patchOpData)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ConfigMaps().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalConfigMap{
		client:    group.client,
		ConfigMap: result,
	}, nil
}

// ListConfigMaps returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListConfigMaps(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalConfigMap, err error) {
	key := "configmaps.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalConfigMap, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ConfigMap)
			result[k] = &GlobalConfigMap{
				client:    group.client,
				ConfigMap: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ConfigMaps().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalConfigMap, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalConfigMap{
				client:    group.client,
				ConfigMap: &item,
			}
		}
	}
	return
}

type GlobalConfigMap struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ConfigMap
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalConfigMap) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteConfigMapByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ConfigMap = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalConfigMap) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateConfigMapByName(ctx, obj.ConfigMap)
	if err != nil {
		return err
	}
	obj.ConfigMap = result.ConfigMap
	return nil
}

func (obj *GlobalConfigMap) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

type configmapGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *configmapGlobalTsmV1Chainer) Subscribe() {
	key := "configmaps.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewConfigMapInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *configmapGlobalTsmV1Chainer) Unsubscribe() {
	key := "configmaps.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *configmapGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "configmaps.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetConfigByName(ctx context.Context, hashedName string) (*GlobalConfig, error) {
	key := "configs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Config)
		return &GlobalConfig{
			client: group.client,
			Config: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Configs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalConfig{
			client: group.client,
			Config: result,
		}, nil
	}
}

// DeleteConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Configs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.ResourceGroupsGvk != nil {
		err := group.client.
			Global().
			DeleteResourceGroupByName(ctx, result.Spec.ResourceGroupsGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.GlobalNamespaceGvk != nil {
		err := group.client.
			Global().
			DeleteGlobalNamespaceByName(ctx, result.Spec.GlobalNamespaceGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.PolicyGvk != nil {
		err := group.client.
			Global().
			DeleteAccessControlPolicyByName(ctx, result.Spec.PolicyGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.TemplatesGvk != nil {
		err := group.client.
			Global().
			DeleteTemplateByName(ctx, result.Spec.TemplatesGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.ProgressiveUpgradeGvk != nil {
		err := group.client.
			Global().
			DeleteProgressiveUpgradeByName(ctx, result.Spec.ProgressiveUpgradeGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.ExternalPluginsGvk != nil {
		err := group.client.
			Global().
			DeleteExternalPluginConfigFolderByName(ctx, result.Spec.ExternalPluginsGvk.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.CertificatesGvk {
		err := group.client.
			Global().DeleteCertificateConfigNByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ExternalAccountsGvk {
		err := group.client.
			Global().DeleteExternalAccountConfigNByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.ExternalAuditStorageGvk != nil {
		err := group.client.
			Global().
			DeleteExternalAuditStorageByName(ctx, result.Spec.ExternalAuditStorageGvk.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ExternalDNSGvk {
		err := group.client.
			Global().DeleteExternalDNSConfigNByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ExternalLBGvk {
		err := group.client.
			Global().DeleteExternalLBConfigNByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.AutoscalerFolderGvk != nil {
		err := group.client.
			Global().
			DeleteAutoscalerFolderByName(ctx, result.Spec.AutoscalerFolderGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.ClustersGvk != nil {
		err := group.client.
			Global().
			DeleteClusterConfigFolderByName(ctx, result.Spec.ClustersGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.ServiceLevelObjectiveGvk != nil {
		err := group.client.
			Global().
			DeleteServiceLevelObjectiveFolderByName(ctx, result.Spec.ServiceLevelObjectiveGvk.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.FeatureFlagsGvk {
		err := group.client.
			Global().DeleteFeatureFlagByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ProjectsGvk {
		err := group.client.
			Global().DeleteProjectByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ServiceDirectoryGvk {
		err := group.client.
			Global().DeleteServiceDirectoryNByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/configGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["roots.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("roots.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Roots().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Config) (*GlobalConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.ResourceGroupsGvk = nil
	objToCreate.Spec.GlobalNamespaceGvk = nil
	objToCreate.Spec.PolicyGvk = nil
	objToCreate.Spec.TemplatesGvk = nil
	objToCreate.Spec.ProgressiveUpgradeGvk = nil
	objToCreate.Spec.ExternalPluginsGvk = nil
	objToCreate.Spec.CertificatesGvk = nil
	objToCreate.Spec.ExternalAccountsGvk = nil
	objToCreate.Spec.ExternalAuditStorageGvk = nil
	objToCreate.Spec.ExternalDNSGvk = nil
	objToCreate.Spec.ExternalLBGvk = nil
	objToCreate.Spec.AutoscalerFolderGvk = nil
	objToCreate.Spec.ClustersGvk = nil
	objToCreate.Spec.ServiceLevelObjectiveGvk = nil
	objToCreate.Spec.FeatureFlagsGvk = nil
	objToCreate.Spec.ProjectsGvk = nil
	objToCreate.Spec.ServiceDirectoryGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Configs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["roots.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("roots.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/configGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "Config",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Roots().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalConfig{
		client: group.client,
		Config: result,
	}, nil
}

// UpdateConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Config) (*GlobalConfig, error) {
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Configs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalConfig{
		client: group.client,
		Config: result,
	}, nil
}

// ListConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalConfig, err error) {
	key := "configs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Config)
			result[k] = &GlobalConfig{
				client: group.client,
				Config: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Configs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalConfig{
				client: group.client,
				Config: &item,
			}
		}
	}
	return
}

type GlobalConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Config
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Config = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateConfigByName(ctx, obj.Config)
	if err != nil {
		return err
	}
	obj.Config = result.Config
	return nil
}

func (obj *GlobalConfig) GetParent(ctx context.Context) (result *GlobalRoot, err error) {
	hashedName := helper.GetHashedName("roots.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["roots.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetRootByName(ctx, hashedName)
}

// GetResourceGroups returns child of given type
func (obj *GlobalConfig) GetResourceGroups(ctx context.Context) (
	result *GlobalResourceGroup, err error) {
	if obj.Spec.ResourceGroupsGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Config", "ResourceGroups")
	}
	return obj.client.Global().GetResourceGroupByName(ctx, obj.Spec.ResourceGroupsGvk.Name)
}

// AddResourceGroups calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalConfig) AddResourceGroups(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ResourceGroup) (result *GlobalResourceGroup, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateResourceGroupByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteResourceGroups calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalConfig) DeleteResourceGroups(ctx context.Context) (err error) {
	if obj.Spec.ResourceGroupsGvk != nil {
		err = obj.client.
			Global().DeleteResourceGroupByName(ctx, obj.Spec.ResourceGroupsGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetGlobalNamespace returns child of given type
func (obj *GlobalConfig) GetGlobalNamespace(ctx context.Context) (
	result *GlobalGlobalNamespace, err error) {
	if obj.Spec.GlobalNamespaceGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Config", "GlobalNamespace")
	}
	return obj.client.Global().GetGlobalNamespaceByName(ctx, obj.Spec.GlobalNamespaceGvk.Name)
}

// AddGlobalNamespace calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalConfig) AddGlobalNamespace(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GlobalNamespace) (result *GlobalGlobalNamespace, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGlobalNamespaceByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteGlobalNamespace calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalConfig) DeleteGlobalNamespace(ctx context.Context) (err error) {
	if obj.Spec.GlobalNamespaceGvk != nil {
		err = obj.client.
			Global().DeleteGlobalNamespaceByName(ctx, obj.Spec.GlobalNamespaceGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetPolicy returns child of given type
func (obj *GlobalConfig) GetPolicy(ctx context.Context) (
	result *GlobalAccessControlPolicy, err error) {
	if obj.Spec.PolicyGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Config", "Policy")
	}
	return obj.client.Global().GetAccessControlPolicyByName(ctx, obj.Spec.PolicyGvk.Name)
}

// AddPolicy calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalConfig) AddPolicy(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AccessControlPolicy) (result *GlobalAccessControlPolicy, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateAccessControlPolicyByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeletePolicy calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalConfig) DeletePolicy(ctx context.Context) (err error) {
	if obj.Spec.PolicyGvk != nil {
		err = obj.client.
			Global().DeleteAccessControlPolicyByName(ctx, obj.Spec.PolicyGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetTemplates returns child of given type
func (obj *GlobalConfig) GetTemplates(ctx context.Context) (
	result *GlobalTemplate, err error) {
	if obj.Spec.TemplatesGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Config", "Templates")
	}
	return obj.client.Global().GetTemplateByName(ctx, obj.Spec.TemplatesGvk.Name)
}

// AddTemplates calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalConfig) AddTemplates(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Template) (result *GlobalTemplate, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateTemplateByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteTemplates calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalConfig) DeleteTemplates(ctx context.Context) (err error) {
	if obj.Spec.TemplatesGvk != nil {
		err = obj.client.
			Global().DeleteTemplateByName(ctx, obj.Spec.TemplatesGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetProgressiveUpgrade returns child of given type
func (obj *GlobalConfig) GetProgressiveUpgrade(ctx context.Context) (
	result *GlobalProgressiveUpgrade, err error) {
	if obj.Spec.ProgressiveUpgradeGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Config", "ProgressiveUpgrade")
	}
	return obj.client.Global().GetProgressiveUpgradeByName(ctx, obj.Spec.ProgressiveUpgradeGvk.Name)
}

// AddProgressiveUpgrade calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalConfig) AddProgressiveUpgrade(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgrade) (result *GlobalProgressiveUpgrade, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateProgressiveUpgradeByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteProgressiveUpgrade calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalConfig) DeleteProgressiveUpgrade(ctx context.Context) (err error) {
	if obj.Spec.ProgressiveUpgradeGvk != nil {
		err = obj.client.
			Global().DeleteProgressiveUpgradeByName(ctx, obj.Spec.ProgressiveUpgradeGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetExternalPlugins returns child of given type
func (obj *GlobalConfig) GetExternalPlugins(ctx context.Context) (
	result *GlobalExternalPluginConfigFolder, err error) {
	if obj.Spec.ExternalPluginsGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Config", "ExternalPlugins")
	}
	return obj.client.Global().GetExternalPluginConfigFolderByName(ctx, obj.Spec.ExternalPluginsGvk.Name)
}

// AddExternalPlugins calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalConfig) AddExternalPlugins(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalPluginConfigFolder) (result *GlobalExternalPluginConfigFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateExternalPluginConfigFolderByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteExternalPlugins calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalConfig) DeleteExternalPlugins(ctx context.Context) (err error) {
	if obj.Spec.ExternalPluginsGvk != nil {
		err = obj.client.
			Global().DeleteExternalPluginConfigFolderByName(ctx, obj.Spec.ExternalPluginsGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetAllCertificates returns all children of given type
func (obj *GlobalConfig) GetAllCertificates(ctx context.Context) (
	result []*GlobalCertificateConfigN, err error) {
	result = make([]*GlobalCertificateConfigN, 0, len(obj.Spec.CertificatesGvk))
	for _, v := range obj.Spec.CertificatesGvk {
		l, err := obj.client.Global().GetCertificateConfigNByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetCertificates returns child which has given displayName
func (obj *GlobalConfig) GetCertificates(ctx context.Context,
	displayName string) (result *GlobalCertificateConfigN, err error) {
	l, ok := obj.Spec.CertificatesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Config", "Certificates", displayName)
	}
	result, err = obj.client.Global().GetCertificateConfigNByName(ctx, l.Name)
	return
}

// AddCertificates calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalConfig) AddCertificates(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.CertificateConfigN) (result *GlobalCertificateConfigN, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateCertificateConfigNByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteCertificates calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalConfig) DeleteCertificates(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.CertificatesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Config", "Certificates", displayName)
	}
	err = obj.client.Global().DeleteCertificateConfigNByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetAllExternalAccounts returns all children of given type
func (obj *GlobalConfig) GetAllExternalAccounts(ctx context.Context) (
	result []*GlobalExternalAccountConfigN, err error) {
	result = make([]*GlobalExternalAccountConfigN, 0, len(obj.Spec.ExternalAccountsGvk))
	for _, v := range obj.Spec.ExternalAccountsGvk {
		l, err := obj.client.Global().GetExternalAccountConfigNByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetExternalAccounts returns child which has given displayName
func (obj *GlobalConfig) GetExternalAccounts(ctx context.Context,
	displayName string) (result *GlobalExternalAccountConfigN, err error) {
	l, ok := obj.Spec.ExternalAccountsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Config", "ExternalAccounts", displayName)
	}
	result, err = obj.client.Global().GetExternalAccountConfigNByName(ctx, l.Name)
	return
}

// AddExternalAccounts calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalConfig) AddExternalAccounts(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalAccountConfigN) (result *GlobalExternalAccountConfigN, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateExternalAccountConfigNByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteExternalAccounts calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalConfig) DeleteExternalAccounts(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ExternalAccountsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Config", "ExternalAccounts", displayName)
	}
	err = obj.client.Global().DeleteExternalAccountConfigNByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetExternalAuditStorage returns child of given type
func (obj *GlobalConfig) GetExternalAuditStorage(ctx context.Context) (
	result *GlobalExternalAuditStorage, err error) {
	if obj.Spec.ExternalAuditStorageGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Config", "ExternalAuditStorage")
	}
	return obj.client.Global().GetExternalAuditStorageByName(ctx, obj.Spec.ExternalAuditStorageGvk.Name)
}

// AddExternalAuditStorage calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalConfig) AddExternalAuditStorage(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalAuditStorage) (result *GlobalExternalAuditStorage, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateExternalAuditStorageByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteExternalAuditStorage calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalConfig) DeleteExternalAuditStorage(ctx context.Context) (err error) {
	if obj.Spec.ExternalAuditStorageGvk != nil {
		err = obj.client.
			Global().DeleteExternalAuditStorageByName(ctx, obj.Spec.ExternalAuditStorageGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetAllExternalDNS returns all children of given type
func (obj *GlobalConfig) GetAllExternalDNS(ctx context.Context) (
	result []*GlobalExternalDNSConfigN, err error) {
	result = make([]*GlobalExternalDNSConfigN, 0, len(obj.Spec.ExternalDNSGvk))
	for _, v := range obj.Spec.ExternalDNSGvk {
		l, err := obj.client.Global().GetExternalDNSConfigNByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetExternalDNS returns child which has given displayName
func (obj *GlobalConfig) GetExternalDNS(ctx context.Context,
	displayName string) (result *GlobalExternalDNSConfigN, err error) {
	l, ok := obj.Spec.ExternalDNSGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Config", "ExternalDNS", displayName)
	}
	result, err = obj.client.Global().GetExternalDNSConfigNByName(ctx, l.Name)
	return
}

// AddExternalDNS calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalConfig) AddExternalDNS(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSConfigN) (result *GlobalExternalDNSConfigN, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateExternalDNSConfigNByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteExternalDNS calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalConfig) DeleteExternalDNS(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ExternalDNSGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Config", "ExternalDNS", displayName)
	}
	err = obj.client.Global().DeleteExternalDNSConfigNByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetAllExternalLB returns all children of given type
func (obj *GlobalConfig) GetAllExternalLB(ctx context.Context) (
	result []*GlobalExternalLBConfigN, err error) {
	result = make([]*GlobalExternalLBConfigN, 0, len(obj.Spec.ExternalLBGvk))
	for _, v := range obj.Spec.ExternalLBGvk {
		l, err := obj.client.Global().GetExternalLBConfigNByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetExternalLB returns child which has given displayName
func (obj *GlobalConfig) GetExternalLB(ctx context.Context,
	displayName string) (result *GlobalExternalLBConfigN, err error) {
	l, ok := obj.Spec.ExternalLBGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Config", "ExternalLB", displayName)
	}
	result, err = obj.client.Global().GetExternalLBConfigNByName(ctx, l.Name)
	return
}

// AddExternalLB calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalConfig) AddExternalLB(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalLBConfigN) (result *GlobalExternalLBConfigN, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateExternalLBConfigNByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteExternalLB calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalConfig) DeleteExternalLB(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ExternalLBGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Config", "ExternalLB", displayName)
	}
	err = obj.client.Global().DeleteExternalLBConfigNByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetAutoscalerFolder returns child of given type
func (obj *GlobalConfig) GetAutoscalerFolder(ctx context.Context) (
	result *GlobalAutoscalerFolder, err error) {
	if obj.Spec.AutoscalerFolderGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Config", "AutoscalerFolder")
	}
	return obj.client.Global().GetAutoscalerFolderByName(ctx, obj.Spec.AutoscalerFolderGvk.Name)
}

// AddAutoscalerFolder calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalConfig) AddAutoscalerFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AutoscalerFolder) (result *GlobalAutoscalerFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateAutoscalerFolderByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteAutoscalerFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalConfig) DeleteAutoscalerFolder(ctx context.Context) (err error) {
	if obj.Spec.AutoscalerFolderGvk != nil {
		err = obj.client.
			Global().DeleteAutoscalerFolderByName(ctx, obj.Spec.AutoscalerFolderGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetClusters returns child of given type
func (obj *GlobalConfig) GetClusters(ctx context.Context) (
	result *GlobalClusterConfigFolder, err error) {
	if obj.Spec.ClustersGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Config", "Clusters")
	}
	return obj.client.Global().GetClusterConfigFolderByName(ctx, obj.Spec.ClustersGvk.Name)
}

// AddClusters calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalConfig) AddClusters(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ClusterConfigFolder) (result *GlobalClusterConfigFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateClusterConfigFolderByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteClusters calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalConfig) DeleteClusters(ctx context.Context) (err error) {
	if obj.Spec.ClustersGvk != nil {
		err = obj.client.
			Global().DeleteClusterConfigFolderByName(ctx, obj.Spec.ClustersGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetServiceLevelObjective returns child of given type
func (obj *GlobalConfig) GetServiceLevelObjective(ctx context.Context) (
	result *GlobalServiceLevelObjectiveFolder, err error) {
	if obj.Spec.ServiceLevelObjectiveGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Config", "ServiceLevelObjective")
	}
	return obj.client.Global().GetServiceLevelObjectiveFolderByName(ctx, obj.Spec.ServiceLevelObjectiveGvk.Name)
}

// AddServiceLevelObjective calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalConfig) AddServiceLevelObjective(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceLevelObjectiveFolder) (result *GlobalServiceLevelObjectiveFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceLevelObjectiveFolderByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteServiceLevelObjective calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalConfig) DeleteServiceLevelObjective(ctx context.Context) (err error) {
	if obj.Spec.ServiceLevelObjectiveGvk != nil {
		err = obj.client.
			Global().DeleteServiceLevelObjectiveFolderByName(ctx, obj.Spec.ServiceLevelObjectiveGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetAllFeatureFlags returns all children of given type
func (obj *GlobalConfig) GetAllFeatureFlags(ctx context.Context) (
	result []*GlobalFeatureFlag, err error) {
	result = make([]*GlobalFeatureFlag, 0, len(obj.Spec.FeatureFlagsGvk))
	for _, v := range obj.Spec.FeatureFlagsGvk {
		l, err := obj.client.Global().GetFeatureFlagByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetFeatureFlags returns child which has given displayName
func (obj *GlobalConfig) GetFeatureFlags(ctx context.Context,
	displayName string) (result *GlobalFeatureFlag, err error) {
	l, ok := obj.Spec.FeatureFlagsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Config", "FeatureFlags", displayName)
	}
	result, err = obj.client.Global().GetFeatureFlagByName(ctx, l.Name)
	return
}

// AddFeatureFlags calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalConfig) AddFeatureFlags(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.FeatureFlag) (result *GlobalFeatureFlag, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateFeatureFlagByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteFeatureFlags calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalConfig) DeleteFeatureFlags(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.FeatureFlagsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Config", "FeatureFlags", displayName)
	}
	err = obj.client.Global().DeleteFeatureFlagByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetAllProjects returns all children of given type
func (obj *GlobalConfig) GetAllProjects(ctx context.Context) (
	result []*GlobalProject, err error) {
	result = make([]*GlobalProject, 0, len(obj.Spec.ProjectsGvk))
	for _, v := range obj.Spec.ProjectsGvk {
		l, err := obj.client.Global().GetProjectByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetProjects returns child which has given displayName
func (obj *GlobalConfig) GetProjects(ctx context.Context,
	displayName string) (result *GlobalProject, err error) {
	l, ok := obj.Spec.ProjectsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Config", "Projects", displayName)
	}
	result, err = obj.client.Global().GetProjectByName(ctx, l.Name)
	return
}

// AddProjects calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalConfig) AddProjects(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Project) (result *GlobalProject, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateProjectByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteProjects calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalConfig) DeleteProjects(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ProjectsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Config", "Projects", displayName)
	}
	err = obj.client.Global().DeleteProjectByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetAllServiceDirectory returns all children of given type
func (obj *GlobalConfig) GetAllServiceDirectory(ctx context.Context) (
	result []*GlobalServiceDirectoryN, err error) {
	result = make([]*GlobalServiceDirectoryN, 0, len(obj.Spec.ServiceDirectoryGvk))
	for _, v := range obj.Spec.ServiceDirectoryGvk {
		l, err := obj.client.Global().GetServiceDirectoryNByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceDirectory returns child which has given displayName
func (obj *GlobalConfig) GetServiceDirectory(ctx context.Context,
	displayName string) (result *GlobalServiceDirectoryN, err error) {
	l, ok := obj.Spec.ServiceDirectoryGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Config", "ServiceDirectory", displayName)
	}
	result, err = obj.client.Global().GetServiceDirectoryNByName(ctx, l.Name)
	return
}

// AddServiceDirectory calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalConfig) AddServiceDirectory(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryN) (result *GlobalServiceDirectoryN, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceDirectoryNByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteServiceDirectory calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalConfig) DeleteServiceDirectory(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ServiceDirectoryGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Config", "ServiceDirectory", displayName)
	}
	err = obj.client.Global().DeleteServiceDirectoryNByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

type configGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *configGlobalTsmV1Chainer) Subscribe() {
	key := "configs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *configGlobalTsmV1Chainer) Unsubscribe() {
	key := "configs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *configGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "configs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *configGlobalTsmV1Chainer) ResourceGroups(name string) *resourcegroupGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["resourcegroups.global.tsm.tanzu.vmware.com"] = name
	return &resourcegroupGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetResourceGroups calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configGlobalTsmV1Chainer) GetResourceGroups(ctx context.Context, displayName string) (result *GlobalResourceGroup, err error) {
	hashedName := helper.GetHashedName("resourcegroups.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetResourceGroupByName(ctx, hashedName)
}

// AddResourceGroups calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configGlobalTsmV1Chainer) AddResourceGroups(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ResourceGroup) (result *GlobalResourceGroup, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("resourcegroups.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateResourceGroupByName(ctx, objToCreate)
}

// DeleteResourceGroups calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configGlobalTsmV1Chainer) DeleteResourceGroups(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("resourcegroups.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteResourceGroupByName(ctx, hashedName)
}

func (c *configGlobalTsmV1Chainer) GlobalNamespace(name string) *globalnamespaceGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["globalnamespaces.global.tsm.tanzu.vmware.com"] = name
	return &globalnamespaceGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGlobalNamespace calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configGlobalTsmV1Chainer) GetGlobalNamespace(ctx context.Context, displayName string) (result *GlobalGlobalNamespace, err error) {
	hashedName := helper.GetHashedName("globalnamespaces.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGlobalNamespaceByName(ctx, hashedName)
}

// AddGlobalNamespace calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configGlobalTsmV1Chainer) AddGlobalNamespace(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GlobalNamespace) (result *GlobalGlobalNamespace, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("globalnamespaces.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGlobalNamespaceByName(ctx, objToCreate)
}

// DeleteGlobalNamespace calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configGlobalTsmV1Chainer) DeleteGlobalNamespace(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("globalnamespaces.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGlobalNamespaceByName(ctx, hashedName)
}

func (c *configGlobalTsmV1Chainer) Policy(name string) *accesscontrolpolicyGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["accesscontrolpolicies.global.tsm.tanzu.vmware.com"] = name
	return &accesscontrolpolicyGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetPolicy calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configGlobalTsmV1Chainer) GetPolicy(ctx context.Context, displayName string) (result *GlobalAccessControlPolicy, err error) {
	hashedName := helper.GetHashedName("accesscontrolpolicies.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetAccessControlPolicyByName(ctx, hashedName)
}

// AddPolicy calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configGlobalTsmV1Chainer) AddPolicy(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AccessControlPolicy) (result *GlobalAccessControlPolicy, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("accesscontrolpolicies.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateAccessControlPolicyByName(ctx, objToCreate)
}

// DeletePolicy calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configGlobalTsmV1Chainer) DeletePolicy(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("accesscontrolpolicies.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteAccessControlPolicyByName(ctx, hashedName)
}

func (c *configGlobalTsmV1Chainer) Templates(name string) *templateGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["templates.global.tsm.tanzu.vmware.com"] = name
	return &templateGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetTemplates calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configGlobalTsmV1Chainer) GetTemplates(ctx context.Context, displayName string) (result *GlobalTemplate, err error) {
	hashedName := helper.GetHashedName("templates.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetTemplateByName(ctx, hashedName)
}

// AddTemplates calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configGlobalTsmV1Chainer) AddTemplates(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Template) (result *GlobalTemplate, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("templates.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateTemplateByName(ctx, objToCreate)
}

// DeleteTemplates calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configGlobalTsmV1Chainer) DeleteTemplates(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("templates.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteTemplateByName(ctx, hashedName)
}

func (c *configGlobalTsmV1Chainer) ProgressiveUpgrade(name string) *progressiveupgradeGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["progressiveupgrades.global.tsm.tanzu.vmware.com"] = name
	return &progressiveupgradeGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetProgressiveUpgrade calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configGlobalTsmV1Chainer) GetProgressiveUpgrade(ctx context.Context, displayName string) (result *GlobalProgressiveUpgrade, err error) {
	hashedName := helper.GetHashedName("progressiveupgrades.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetProgressiveUpgradeByName(ctx, hashedName)
}

// AddProgressiveUpgrade calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configGlobalTsmV1Chainer) AddProgressiveUpgrade(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgrade) (result *GlobalProgressiveUpgrade, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("progressiveupgrades.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateProgressiveUpgradeByName(ctx, objToCreate)
}

// DeleteProgressiveUpgrade calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configGlobalTsmV1Chainer) DeleteProgressiveUpgrade(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("progressiveupgrades.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteProgressiveUpgradeByName(ctx, hashedName)
}

func (c *configGlobalTsmV1Chainer) ExternalPlugins(name string) *externalpluginconfigfolderGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["externalpluginconfigfolders.global.tsm.tanzu.vmware.com"] = name
	return &externalpluginconfigfolderGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetExternalPlugins calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configGlobalTsmV1Chainer) GetExternalPlugins(ctx context.Context, displayName string) (result *GlobalExternalPluginConfigFolder, err error) {
	hashedName := helper.GetHashedName("externalpluginconfigfolders.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetExternalPluginConfigFolderByName(ctx, hashedName)
}

// AddExternalPlugins calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configGlobalTsmV1Chainer) AddExternalPlugins(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalPluginConfigFolder) (result *GlobalExternalPluginConfigFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("externalpluginconfigfolders.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateExternalPluginConfigFolderByName(ctx, objToCreate)
}

// DeleteExternalPlugins calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configGlobalTsmV1Chainer) DeleteExternalPlugins(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("externalpluginconfigfolders.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteExternalPluginConfigFolderByName(ctx, hashedName)
}

func (c *configGlobalTsmV1Chainer) Certificates(name string) *certificateconfignGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["certificateconfigns.global.tsm.tanzu.vmware.com"] = name
	return &certificateconfignGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetCertificates calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configGlobalTsmV1Chainer) GetCertificates(ctx context.Context, displayName string) (result *GlobalCertificateConfigN, err error) {
	hashedName := helper.GetHashedName("certificateconfigns.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetCertificateConfigNByName(ctx, hashedName)
}

// AddCertificates calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configGlobalTsmV1Chainer) AddCertificates(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.CertificateConfigN) (result *GlobalCertificateConfigN, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("certificateconfigns.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateCertificateConfigNByName(ctx, objToCreate)
}

// DeleteCertificates calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configGlobalTsmV1Chainer) DeleteCertificates(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("certificateconfigns.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteCertificateConfigNByName(ctx, hashedName)
}

func (c *configGlobalTsmV1Chainer) ExternalAccounts(name string) *externalaccountconfignGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["externalaccountconfigns.global.tsm.tanzu.vmware.com"] = name
	return &externalaccountconfignGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetExternalAccounts calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configGlobalTsmV1Chainer) GetExternalAccounts(ctx context.Context, displayName string) (result *GlobalExternalAccountConfigN, err error) {
	hashedName := helper.GetHashedName("externalaccountconfigns.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetExternalAccountConfigNByName(ctx, hashedName)
}

// AddExternalAccounts calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configGlobalTsmV1Chainer) AddExternalAccounts(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalAccountConfigN) (result *GlobalExternalAccountConfigN, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("externalaccountconfigns.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateExternalAccountConfigNByName(ctx, objToCreate)
}

// DeleteExternalAccounts calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configGlobalTsmV1Chainer) DeleteExternalAccounts(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("externalaccountconfigns.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteExternalAccountConfigNByName(ctx, hashedName)
}

func (c *configGlobalTsmV1Chainer) ExternalAuditStorage(name string) *externalauditstorageGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["externalauditstorages.global.tsm.tanzu.vmware.com"] = name
	return &externalauditstorageGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetExternalAuditStorage calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configGlobalTsmV1Chainer) GetExternalAuditStorage(ctx context.Context, displayName string) (result *GlobalExternalAuditStorage, err error) {
	hashedName := helper.GetHashedName("externalauditstorages.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetExternalAuditStorageByName(ctx, hashedName)
}

// AddExternalAuditStorage calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configGlobalTsmV1Chainer) AddExternalAuditStorage(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalAuditStorage) (result *GlobalExternalAuditStorage, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("externalauditstorages.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateExternalAuditStorageByName(ctx, objToCreate)
}

// DeleteExternalAuditStorage calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configGlobalTsmV1Chainer) DeleteExternalAuditStorage(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("externalauditstorages.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteExternalAuditStorageByName(ctx, hashedName)
}

func (c *configGlobalTsmV1Chainer) ExternalDNS(name string) *externaldnsconfignGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["externaldnsconfigns.global.tsm.tanzu.vmware.com"] = name
	return &externaldnsconfignGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetExternalDNS calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configGlobalTsmV1Chainer) GetExternalDNS(ctx context.Context, displayName string) (result *GlobalExternalDNSConfigN, err error) {
	hashedName := helper.GetHashedName("externaldnsconfigns.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetExternalDNSConfigNByName(ctx, hashedName)
}

// AddExternalDNS calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configGlobalTsmV1Chainer) AddExternalDNS(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSConfigN) (result *GlobalExternalDNSConfigN, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("externaldnsconfigns.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateExternalDNSConfigNByName(ctx, objToCreate)
}

// DeleteExternalDNS calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configGlobalTsmV1Chainer) DeleteExternalDNS(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("externaldnsconfigns.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteExternalDNSConfigNByName(ctx, hashedName)
}

func (c *configGlobalTsmV1Chainer) ExternalLB(name string) *externallbconfignGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["externallbconfigns.global.tsm.tanzu.vmware.com"] = name
	return &externallbconfignGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetExternalLB calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configGlobalTsmV1Chainer) GetExternalLB(ctx context.Context, displayName string) (result *GlobalExternalLBConfigN, err error) {
	hashedName := helper.GetHashedName("externallbconfigns.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetExternalLBConfigNByName(ctx, hashedName)
}

// AddExternalLB calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configGlobalTsmV1Chainer) AddExternalLB(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalLBConfigN) (result *GlobalExternalLBConfigN, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("externallbconfigns.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateExternalLBConfigNByName(ctx, objToCreate)
}

// DeleteExternalLB calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configGlobalTsmV1Chainer) DeleteExternalLB(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("externallbconfigns.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteExternalLBConfigNByName(ctx, hashedName)
}

func (c *configGlobalTsmV1Chainer) AutoscalerFolder(name string) *autoscalerfolderGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["autoscalerfolders.global.tsm.tanzu.vmware.com"] = name
	return &autoscalerfolderGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetAutoscalerFolder calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configGlobalTsmV1Chainer) GetAutoscalerFolder(ctx context.Context, displayName string) (result *GlobalAutoscalerFolder, err error) {
	hashedName := helper.GetHashedName("autoscalerfolders.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetAutoscalerFolderByName(ctx, hashedName)
}

// AddAutoscalerFolder calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configGlobalTsmV1Chainer) AddAutoscalerFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AutoscalerFolder) (result *GlobalAutoscalerFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("autoscalerfolders.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateAutoscalerFolderByName(ctx, objToCreate)
}

// DeleteAutoscalerFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configGlobalTsmV1Chainer) DeleteAutoscalerFolder(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("autoscalerfolders.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteAutoscalerFolderByName(ctx, hashedName)
}

func (c *configGlobalTsmV1Chainer) Clusters(name string) *clusterconfigfolderGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["clusterconfigfolders.global.tsm.tanzu.vmware.com"] = name
	return &clusterconfigfolderGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetClusters calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configGlobalTsmV1Chainer) GetClusters(ctx context.Context, displayName string) (result *GlobalClusterConfigFolder, err error) {
	hashedName := helper.GetHashedName("clusterconfigfolders.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetClusterConfigFolderByName(ctx, hashedName)
}

// AddClusters calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configGlobalTsmV1Chainer) AddClusters(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ClusterConfigFolder) (result *GlobalClusterConfigFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("clusterconfigfolders.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateClusterConfigFolderByName(ctx, objToCreate)
}

// DeleteClusters calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configGlobalTsmV1Chainer) DeleteClusters(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("clusterconfigfolders.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteClusterConfigFolderByName(ctx, hashedName)
}

func (c *configGlobalTsmV1Chainer) ServiceLevelObjective(name string) *servicelevelobjectivefolderGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["servicelevelobjectivefolders.global.tsm.tanzu.vmware.com"] = name
	return &servicelevelobjectivefolderGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetServiceLevelObjective calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configGlobalTsmV1Chainer) GetServiceLevelObjective(ctx context.Context, displayName string) (result *GlobalServiceLevelObjectiveFolder, err error) {
	hashedName := helper.GetHashedName("servicelevelobjectivefolders.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceLevelObjectiveFolderByName(ctx, hashedName)
}

// AddServiceLevelObjective calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configGlobalTsmV1Chainer) AddServiceLevelObjective(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceLevelObjectiveFolder) (result *GlobalServiceLevelObjectiveFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("servicelevelobjectivefolders.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceLevelObjectiveFolderByName(ctx, objToCreate)
}

// DeleteServiceLevelObjective calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configGlobalTsmV1Chainer) DeleteServiceLevelObjective(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("servicelevelobjectivefolders.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceLevelObjectiveFolderByName(ctx, hashedName)
}

func (c *configGlobalTsmV1Chainer) FeatureFlags(name string) *featureflagGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["featureflags.global.tsm.tanzu.vmware.com"] = name
	return &featureflagGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetFeatureFlags calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configGlobalTsmV1Chainer) GetFeatureFlags(ctx context.Context, displayName string) (result *GlobalFeatureFlag, err error) {
	hashedName := helper.GetHashedName("featureflags.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetFeatureFlagByName(ctx, hashedName)
}

// AddFeatureFlags calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configGlobalTsmV1Chainer) AddFeatureFlags(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.FeatureFlag) (result *GlobalFeatureFlag, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("featureflags.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateFeatureFlagByName(ctx, objToCreate)
}

// DeleteFeatureFlags calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configGlobalTsmV1Chainer) DeleteFeatureFlags(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("featureflags.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteFeatureFlagByName(ctx, hashedName)
}

func (c *configGlobalTsmV1Chainer) Projects(name string) *projectGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["projects.global.tsm.tanzu.vmware.com"] = name
	return &projectGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetProjects calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configGlobalTsmV1Chainer) GetProjects(ctx context.Context, displayName string) (result *GlobalProject, err error) {
	hashedName := helper.GetHashedName("projects.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetProjectByName(ctx, hashedName)
}

// AddProjects calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configGlobalTsmV1Chainer) AddProjects(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Project) (result *GlobalProject, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("projects.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateProjectByName(ctx, objToCreate)
}

// DeleteProjects calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configGlobalTsmV1Chainer) DeleteProjects(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("projects.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteProjectByName(ctx, hashedName)
}

func (c *configGlobalTsmV1Chainer) ServiceDirectory(name string) *servicedirectorynGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["servicedirectoryns.global.tsm.tanzu.vmware.com"] = name
	return &servicedirectorynGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetServiceDirectory calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configGlobalTsmV1Chainer) GetServiceDirectory(ctx context.Context, displayName string) (result *GlobalServiceDirectoryN, err error) {
	hashedName := helper.GetHashedName("servicedirectoryns.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceDirectoryNByName(ctx, hashedName)
}

// AddServiceDirectory calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configGlobalTsmV1Chainer) AddServiceDirectory(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryN) (result *GlobalServiceDirectoryN, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("servicedirectoryns.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceDirectoryNByName(ctx, objToCreate)
}

// DeleteServiceDirectory calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configGlobalTsmV1Chainer) DeleteServiceDirectory(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("servicedirectoryns.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceDirectoryNByName(ctx, hashedName)
}

// GetConnectionStatusByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetConnectionStatusByName(ctx context.Context, hashedName string) (*GlobalConnectionStatus, error) {
	key := "connectionstatuses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ConnectionStatus)
		return &GlobalConnectionStatus{
			client:           group.client,
			ConnectionStatus: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ConnectionStatuses().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalConnectionStatus{
			client:           group.client,
			ConnectionStatus: result,
		}, nil
	}
}

// DeleteConnectionStatusByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteConnectionStatusByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ConnectionStatuses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ConnectionStatuses().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/connectionStatusGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["clusters.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusters.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Clusters().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateConnectionStatusByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateConnectionStatusByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ConnectionStatus) (*GlobalConnectionStatus, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ConnectionStatuses().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["clusters.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusters.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/connectionStatusGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "ConnectionStatus",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Clusters().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalConnectionStatus{
		client:           group.client,
		ConnectionStatus: result,
	}, nil
}

// UpdateConnectionStatusByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateConnectionStatusByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ConnectionStatus) (*GlobalConnectionStatus, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ConnectionStatuses().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueConnected :=
		objToUpdate.Spec.Connected
	patchOpConnected := PatchOp{
		Op:    "replace",
		Path:  "/spec/connected",
		Value: patchValueConnected,
	}
	patch = append(patch, patchOpConnected)

	patchValueMessage :=
		objToUpdate.Spec.Message
	patchOpMessage := PatchOp{
		Op:    "replace",
		Path:  "/spec/message",
		Value: patchValueMessage,
	}
	patch = append(patch, patchOpMessage)

	patchValueCode :=
		objToUpdate.Spec.Code
	patchOpCode := PatchOp{
		Op:    "replace",
		Path:  "/spec/code",
		Value: patchValueCode,
	}
	patch = append(patch, patchOpCode)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ConnectionStatuses().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalConnectionStatus{
		client:           group.client,
		ConnectionStatus: result,
	}, nil
}

// ListConnectionStatuses returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListConnectionStatuses(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalConnectionStatus, err error) {
	key := "connectionstatuses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalConnectionStatus, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ConnectionStatus)
			result[k] = &GlobalConnectionStatus{
				client:           group.client,
				ConnectionStatus: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ConnectionStatuses().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalConnectionStatus, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalConnectionStatus{
				client:           group.client,
				ConnectionStatus: &item,
			}
		}
	}
	return
}

type GlobalConnectionStatus struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ConnectionStatus
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalConnectionStatus) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteConnectionStatusByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ConnectionStatus = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalConnectionStatus) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateConnectionStatusByName(ctx, obj.ConnectionStatus)
	if err != nil {
		return err
	}
	obj.ConnectionStatus = result.ConnectionStatus
	return nil
}

func (obj *GlobalConnectionStatus) GetParent(ctx context.Context) (result *GlobalCluster, err error) {
	hashedName := helper.GetHashedName("clusters.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["clusters.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetClusterByName(ctx, hashedName)
}

type connectionstatusGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *connectionstatusGlobalTsmV1Chainer) Subscribe() {
	key := "connectionstatuses.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewConnectionStatusInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *connectionstatusGlobalTsmV1Chainer) Unsubscribe() {
	key := "connectionstatuses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *connectionstatusGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "connectionstatuses.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetDataFolderDomainClusterByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetDataFolderDomainClusterByName(ctx context.Context, hashedName string) (*GlobalDataFolderDomainCluster, error) {
	key := "datafolderdomainclusters.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.DataFolderDomainCluster)
		return &GlobalDataFolderDomainCluster{
			client:                  group.client,
			DataFolderDomainCluster: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			DataFolderDomainClusters().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalDataFolderDomainCluster{
			client:                  group.client,
			DataFolderDomainCluster: result,
		}, nil
	}
}

// DeleteDataFolderDomainClusterByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteDataFolderDomainClusterByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomainClusters().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomainClusters().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/clusterGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["datafolderdomains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("datafolderdomains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateDataFolderDomainClusterByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateDataFolderDomainClusterByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DataFolderDomainCluster) (*GlobalDataFolderDomainCluster, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomainClusters().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["datafolderdomains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("datafolderdomains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/clusterGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "DataFolderDomainCluster",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalDataFolderDomainCluster{
		client:                  group.client,
		DataFolderDomainCluster: result,
	}, nil
}

// UpdateDataFolderDomainClusterByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateDataFolderDomainClusterByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.DataFolderDomainCluster) (*GlobalDataFolderDomainCluster, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			DataFolderDomainClusters().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomainClusters().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalDataFolderDomainCluster{
		client:                  group.client,
		DataFolderDomainCluster: result,
	}, nil
}

// ListDataFolderDomainClusters returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListDataFolderDomainClusters(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalDataFolderDomainCluster, err error) {
	key := "datafolderdomainclusters.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalDataFolderDomainCluster, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.DataFolderDomainCluster)
			result[k] = &GlobalDataFolderDomainCluster{
				client:                  group.client,
				DataFolderDomainCluster: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			DataFolderDomainClusters().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalDataFolderDomainCluster, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalDataFolderDomainCluster{
				client:                  group.client,
				DataFolderDomainCluster: &item,
			}
		}
	}
	return
}

type GlobalDataFolderDomainCluster struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.DataFolderDomainCluster
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalDataFolderDomainCluster) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteDataFolderDomainClusterByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.DataFolderDomainCluster = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalDataFolderDomainCluster) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateDataFolderDomainClusterByName(ctx, obj.DataFolderDomainCluster)
	if err != nil {
		return err
	}
	obj.DataFolderDomainCluster = result.DataFolderDomainCluster
	return nil
}

func (obj *GlobalDataFolderDomainCluster) GetParent(ctx context.Context) (result *GlobalDataFolderDomain, err error) {
	hashedName := helper.GetHashedName("datafolderdomains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["datafolderdomains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDataFolderDomainByName(ctx, hashedName)
}

type datafolderdomainclusterGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *datafolderdomainclusterGlobalTsmV1Chainer) Subscribe() {
	key := "datafolderdomainclusters.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDataFolderDomainClusterInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *datafolderdomainclusterGlobalTsmV1Chainer) Unsubscribe() {
	key := "datafolderdomainclusters.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *datafolderdomainclusterGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "datafolderdomainclusters.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetDataFolderDomainServiceVersionByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetDataFolderDomainServiceVersionByName(ctx context.Context, hashedName string) (*GlobalDataFolderDomainServiceVersion, error) {
	key := "datafolderdomainserviceversions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.DataFolderDomainServiceVersion)
		return &GlobalDataFolderDomainServiceVersion{
			client:                         group.client,
			DataFolderDomainServiceVersion: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			DataFolderDomainServiceVersions().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalDataFolderDomainServiceVersion{
			client:                         group.client,
			DataFolderDomainServiceVersion: result,
		}, nil
	}
}

// DeleteDataFolderDomainServiceVersionByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteDataFolderDomainServiceVersionByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomainServiceVersions().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomainServiceVersions().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/versionsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["datafolderdomainservices.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("datafolderdomainservices.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomainServices().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateDataFolderDomainServiceVersionByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateDataFolderDomainServiceVersionByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DataFolderDomainServiceVersion) (*GlobalDataFolderDomainServiceVersion, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomainServiceVersions().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["datafolderdomainservices.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("datafolderdomainservices.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"versionsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"DataFolderDomainServiceVersion\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomainServices().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalDataFolderDomainServiceVersion{
		client:                         group.client,
		DataFolderDomainServiceVersion: result,
	}, nil
}

// UpdateDataFolderDomainServiceVersionByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateDataFolderDomainServiceVersionByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.DataFolderDomainServiceVersion) (*GlobalDataFolderDomainServiceVersion, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			DataFolderDomainServiceVersions().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomainServiceVersions().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalDataFolderDomainServiceVersion{
		client:                         group.client,
		DataFolderDomainServiceVersion: result,
	}, nil
}

// ListDataFolderDomainServiceVersions returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListDataFolderDomainServiceVersions(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalDataFolderDomainServiceVersion, err error) {
	key := "datafolderdomainserviceversions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalDataFolderDomainServiceVersion, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.DataFolderDomainServiceVersion)
			result[k] = &GlobalDataFolderDomainServiceVersion{
				client:                         group.client,
				DataFolderDomainServiceVersion: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			DataFolderDomainServiceVersions().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalDataFolderDomainServiceVersion, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalDataFolderDomainServiceVersion{
				client:                         group.client,
				DataFolderDomainServiceVersion: &item,
			}
		}
	}
	return
}

type GlobalDataFolderDomainServiceVersion struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.DataFolderDomainServiceVersion
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalDataFolderDomainServiceVersion) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteDataFolderDomainServiceVersionByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.DataFolderDomainServiceVersion = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalDataFolderDomainServiceVersion) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateDataFolderDomainServiceVersionByName(ctx, obj.DataFolderDomainServiceVersion)
	if err != nil {
		return err
	}
	obj.DataFolderDomainServiceVersion = result.DataFolderDomainServiceVersion
	return nil
}

func (obj *GlobalDataFolderDomainServiceVersion) GetParent(ctx context.Context) (result *GlobalDataFolderDomainService, err error) {
	hashedName := helper.GetHashedName("datafolderdomainservices.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["datafolderdomainservices.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDataFolderDomainServiceByName(ctx, hashedName)
}

type datafolderdomainserviceversionGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *datafolderdomainserviceversionGlobalTsmV1Chainer) Subscribe() {
	key := "datafolderdomainserviceversions.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDataFolderDomainServiceVersionInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *datafolderdomainserviceversionGlobalTsmV1Chainer) Unsubscribe() {
	key := "datafolderdomainserviceversions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *datafolderdomainserviceversionGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "datafolderdomainserviceversions.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetDataFolderDomainServiceByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetDataFolderDomainServiceByName(ctx context.Context, hashedName string) (*GlobalDataFolderDomainService, error) {
	key := "datafolderdomainservices.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.DataFolderDomainService)
		return &GlobalDataFolderDomainService{
			client:                  group.client,
			DataFolderDomainService: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			DataFolderDomainServices().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalDataFolderDomainService{
			client:                  group.client,
			DataFolderDomainService: result,
		}, nil
	}
}

// DeleteDataFolderDomainServiceByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteDataFolderDomainServiceByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomainServices().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.VersionsGvk {
		err := group.client.
			Global().DeleteDataFolderDomainServiceVersionByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomainServices().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["datafolderdomains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("datafolderdomains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateDataFolderDomainServiceByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateDataFolderDomainServiceByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DataFolderDomainService) (*GlobalDataFolderDomainService, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.VersionsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomainServices().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["datafolderdomains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("datafolderdomains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"serviceGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"DataFolderDomainService\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalDataFolderDomainService{
		client:                  group.client,
		DataFolderDomainService: result,
	}, nil
}

// UpdateDataFolderDomainServiceByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateDataFolderDomainServiceByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.DataFolderDomainService) (*GlobalDataFolderDomainService, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			DataFolderDomainServices().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomainServices().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalDataFolderDomainService{
		client:                  group.client,
		DataFolderDomainService: result,
	}, nil
}

// ListDataFolderDomainServices returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListDataFolderDomainServices(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalDataFolderDomainService, err error) {
	key := "datafolderdomainservices.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalDataFolderDomainService, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.DataFolderDomainService)
			result[k] = &GlobalDataFolderDomainService{
				client:                  group.client,
				DataFolderDomainService: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			DataFolderDomainServices().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalDataFolderDomainService, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalDataFolderDomainService{
				client:                  group.client,
				DataFolderDomainService: &item,
			}
		}
	}
	return
}

type GlobalDataFolderDomainService struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.DataFolderDomainService
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalDataFolderDomainService) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteDataFolderDomainServiceByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.DataFolderDomainService = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalDataFolderDomainService) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateDataFolderDomainServiceByName(ctx, obj.DataFolderDomainService)
	if err != nil {
		return err
	}
	obj.DataFolderDomainService = result.DataFolderDomainService
	return nil
}

func (obj *GlobalDataFolderDomainService) GetParent(ctx context.Context) (result *GlobalDataFolderDomain, err error) {
	hashedName := helper.GetHashedName("datafolderdomains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["datafolderdomains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDataFolderDomainByName(ctx, hashedName)
}

// GetAllVersions returns all children of given type
func (obj *GlobalDataFolderDomainService) GetAllVersions(ctx context.Context) (
	result []*GlobalDataFolderDomainServiceVersion, err error) {
	result = make([]*GlobalDataFolderDomainServiceVersion, 0, len(obj.Spec.VersionsGvk))
	for _, v := range obj.Spec.VersionsGvk {
		l, err := obj.client.Global().GetDataFolderDomainServiceVersionByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetVersions returns child which has given displayName
func (obj *GlobalDataFolderDomainService) GetVersions(ctx context.Context,
	displayName string) (result *GlobalDataFolderDomainServiceVersion, err error) {
	l, ok := obj.Spec.VersionsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DataFolderDomainService", "Versions", displayName)
	}
	result, err = obj.client.Global().GetDataFolderDomainServiceVersionByName(ctx, l.Name)
	return
}

// AddVersions calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDataFolderDomainService) AddVersions(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DataFolderDomainServiceVersion) (result *GlobalDataFolderDomainServiceVersion, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["datafolderdomainservices.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["datafolderdomainservices.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateDataFolderDomainServiceVersionByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDataFolderDomainServiceByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DataFolderDomainService = updatedObj.DataFolderDomainService
	}
	return
}

// DeleteVersions calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDataFolderDomainService) DeleteVersions(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.VersionsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DataFolderDomainService", "Versions", displayName)
	}
	err = obj.client.Global().DeleteDataFolderDomainServiceVersionByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDataFolderDomainServiceByName(ctx, obj.GetName())
	if err == nil {
		obj.DataFolderDomainService = updatedObj.DataFolderDomainService
	}
	return
}

type datafolderdomainserviceGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *datafolderdomainserviceGlobalTsmV1Chainer) Subscribe() {
	key := "datafolderdomainservices.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDataFolderDomainServiceInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *datafolderdomainserviceGlobalTsmV1Chainer) Unsubscribe() {
	key := "datafolderdomainservices.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *datafolderdomainserviceGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "datafolderdomainservices.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *datafolderdomainserviceGlobalTsmV1Chainer) Versions(name string) *datafolderdomainserviceversionGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["datafolderdomainserviceversions.global.tsm.tanzu.vmware.com"] = name
	return &datafolderdomainserviceversionGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetVersions calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *datafolderdomainserviceGlobalTsmV1Chainer) GetVersions(ctx context.Context, displayName string) (result *GlobalDataFolderDomainServiceVersion, err error) {
	hashedName := helper.GetHashedName("datafolderdomainserviceversions.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetDataFolderDomainServiceVersionByName(ctx, hashedName)
}

// AddVersions calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *datafolderdomainserviceGlobalTsmV1Chainer) AddVersions(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DataFolderDomainServiceVersion) (result *GlobalDataFolderDomainServiceVersion, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("datafolderdomainserviceversions.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateDataFolderDomainServiceVersionByName(ctx, objToCreate)
}

// DeleteVersions calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *datafolderdomainserviceGlobalTsmV1Chainer) DeleteVersions(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("datafolderdomainserviceversions.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteDataFolderDomainServiceVersionByName(ctx, hashedName)
}

// GetDataFolderDomainByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetDataFolderDomainByName(ctx context.Context, hashedName string) (*GlobalDataFolderDomain, error) {
	key := "datafolderdomains.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.DataFolderDomain)
		return &GlobalDataFolderDomain{
			client:           group.client,
			DataFolderDomain: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			DataFolderDomains().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalDataFolderDomain{
			client:           group.client,
			DataFolderDomain: result,
		}, nil
	}
}

// DeleteDataFolderDomainByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteDataFolderDomainByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomains().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.ClusterGvk != nil {
		err := group.client.
			Global().
			DeleteDataFolderDomainClusterByName(ctx, result.Spec.ClusterGvk.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ServiceGvk {
		err := group.client.
			Global().DeleteDataFolderDomainServiceByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.DatabaseGvk != nil {
		err := group.client.
			Global().
			DeleteDatabaseByName(ctx, result.Spec.DatabaseGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomains().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/domainGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["datafolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("datafolders.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DataFolders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateDataFolderDomainByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateDataFolderDomainByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DataFolderDomain) (*GlobalDataFolderDomain, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ClusterGvk = nil
	objToCreate.Spec.ServiceGvk = nil
	objToCreate.Spec.DatabaseGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomains().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["datafolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("datafolders.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/domainGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "DataFolderDomain",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DataFolders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalDataFolderDomain{
		client:           group.client,
		DataFolderDomain: result,
	}, nil
}

// UpdateDataFolderDomainByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateDataFolderDomainByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.DataFolderDomain) (*GlobalDataFolderDomain, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			DataFolderDomains().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomains().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalDataFolderDomain{
		client:           group.client,
		DataFolderDomain: result,
	}, nil
}

// ListDataFolderDomains returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListDataFolderDomains(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalDataFolderDomain, err error) {
	key := "datafolderdomains.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalDataFolderDomain, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.DataFolderDomain)
			result[k] = &GlobalDataFolderDomain{
				client:           group.client,
				DataFolderDomain: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			DataFolderDomains().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalDataFolderDomain, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalDataFolderDomain{
				client:           group.client,
				DataFolderDomain: &item,
			}
		}
	}
	return
}

type GlobalDataFolderDomain struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.DataFolderDomain
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalDataFolderDomain) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteDataFolderDomainByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.DataFolderDomain = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalDataFolderDomain) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateDataFolderDomainByName(ctx, obj.DataFolderDomain)
	if err != nil {
		return err
	}
	obj.DataFolderDomain = result.DataFolderDomain
	return nil
}

func (obj *GlobalDataFolderDomain) GetParent(ctx context.Context) (result *GlobalDataFolder, err error) {
	hashedName := helper.GetHashedName("datafolders.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["datafolders.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDataFolderByName(ctx, hashedName)
}

// GetCluster returns child of given type
func (obj *GlobalDataFolderDomain) GetCluster(ctx context.Context) (
	result *GlobalDataFolderDomainCluster, err error) {
	if obj.Spec.ClusterGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DataFolderDomain", "Cluster")
	}
	return obj.client.Global().GetDataFolderDomainClusterByName(ctx, obj.Spec.ClusterGvk.Name)
}

// AddCluster calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDataFolderDomain) AddCluster(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DataFolderDomainCluster) (result *GlobalDataFolderDomainCluster, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["datafolderdomains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["datafolderdomains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateDataFolderDomainClusterByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDataFolderDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DataFolderDomain = updatedObj.DataFolderDomain
	}
	return
}

// DeleteCluster calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDataFolderDomain) DeleteCluster(ctx context.Context) (err error) {
	if obj.Spec.ClusterGvk != nil {
		err = obj.client.
			Global().DeleteDataFolderDomainClusterByName(ctx, obj.Spec.ClusterGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetDataFolderDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.DataFolderDomain = updatedObj.DataFolderDomain
	}
	return
}

// GetAllService returns all children of given type
func (obj *GlobalDataFolderDomain) GetAllService(ctx context.Context) (
	result []*GlobalDataFolderDomainService, err error) {
	result = make([]*GlobalDataFolderDomainService, 0, len(obj.Spec.ServiceGvk))
	for _, v := range obj.Spec.ServiceGvk {
		l, err := obj.client.Global().GetDataFolderDomainServiceByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetService returns child which has given displayName
func (obj *GlobalDataFolderDomain) GetService(ctx context.Context,
	displayName string) (result *GlobalDataFolderDomainService, err error) {
	l, ok := obj.Spec.ServiceGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DataFolderDomain", "Service", displayName)
	}
	result, err = obj.client.Global().GetDataFolderDomainServiceByName(ctx, l.Name)
	return
}

// AddService calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDataFolderDomain) AddService(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DataFolderDomainService) (result *GlobalDataFolderDomainService, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["datafolderdomains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["datafolderdomains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateDataFolderDomainServiceByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDataFolderDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DataFolderDomain = updatedObj.DataFolderDomain
	}
	return
}

// DeleteService calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDataFolderDomain) DeleteService(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ServiceGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DataFolderDomain", "Service", displayName)
	}
	err = obj.client.Global().DeleteDataFolderDomainServiceByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDataFolderDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.DataFolderDomain = updatedObj.DataFolderDomain
	}
	return
}

// GetDatabase returns child of given type
func (obj *GlobalDataFolderDomain) GetDatabase(ctx context.Context) (
	result *GlobalDatabase, err error) {
	if obj.Spec.DatabaseGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DataFolderDomain", "Database")
	}
	return obj.client.Global().GetDatabaseByName(ctx, obj.Spec.DatabaseGvk.Name)
}

// AddDatabase calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDataFolderDomain) AddDatabase(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Database) (result *GlobalDatabase, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["datafolderdomains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["datafolderdomains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateDatabaseByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDataFolderDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DataFolderDomain = updatedObj.DataFolderDomain
	}
	return
}

// DeleteDatabase calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDataFolderDomain) DeleteDatabase(ctx context.Context) (err error) {
	if obj.Spec.DatabaseGvk != nil {
		err = obj.client.
			Global().DeleteDatabaseByName(ctx, obj.Spec.DatabaseGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetDataFolderDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.DataFolderDomain = updatedObj.DataFolderDomain
	}
	return
}

type datafolderdomainGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *datafolderdomainGlobalTsmV1Chainer) Subscribe() {
	key := "datafolderdomains.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDataFolderDomainInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *datafolderdomainGlobalTsmV1Chainer) Unsubscribe() {
	key := "datafolderdomains.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *datafolderdomainGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "datafolderdomains.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *datafolderdomainGlobalTsmV1Chainer) Cluster(name string) *datafolderdomainclusterGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["datafolderdomainclusters.global.tsm.tanzu.vmware.com"] = name
	return &datafolderdomainclusterGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetCluster calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *datafolderdomainGlobalTsmV1Chainer) GetCluster(ctx context.Context, displayName string) (result *GlobalDataFolderDomainCluster, err error) {
	hashedName := helper.GetHashedName("datafolderdomainclusters.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetDataFolderDomainClusterByName(ctx, hashedName)
}

// AddCluster calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *datafolderdomainGlobalTsmV1Chainer) AddCluster(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DataFolderDomainCluster) (result *GlobalDataFolderDomainCluster, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("datafolderdomainclusters.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateDataFolderDomainClusterByName(ctx, objToCreate)
}

// DeleteCluster calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *datafolderdomainGlobalTsmV1Chainer) DeleteCluster(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("datafolderdomainclusters.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteDataFolderDomainClusterByName(ctx, hashedName)
}

func (c *datafolderdomainGlobalTsmV1Chainer) Service(name string) *datafolderdomainserviceGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["datafolderdomainservices.global.tsm.tanzu.vmware.com"] = name
	return &datafolderdomainserviceGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetService calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *datafolderdomainGlobalTsmV1Chainer) GetService(ctx context.Context, displayName string) (result *GlobalDataFolderDomainService, err error) {
	hashedName := helper.GetHashedName("datafolderdomainservices.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetDataFolderDomainServiceByName(ctx, hashedName)
}

// AddService calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *datafolderdomainGlobalTsmV1Chainer) AddService(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DataFolderDomainService) (result *GlobalDataFolderDomainService, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("datafolderdomainservices.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateDataFolderDomainServiceByName(ctx, objToCreate)
}

// DeleteService calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *datafolderdomainGlobalTsmV1Chainer) DeleteService(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("datafolderdomainservices.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteDataFolderDomainServiceByName(ctx, hashedName)
}

func (c *datafolderdomainGlobalTsmV1Chainer) Database() *databaseGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["databases.global.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &databaseGlobalTsmV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetDatabase calculates hashed name of the object based on it's parents and returns the object
func (c *datafolderdomainGlobalTsmV1Chainer) GetDatabase(ctx context.Context) (result *GlobalDatabase, err error) {
	hashedName := helper.GetHashedName("databases.global.tsm.tanzu.vmware.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Global().GetDatabaseByName(ctx, hashedName)
}

// AddDatabase calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *datafolderdomainGlobalTsmV1Chainer) AddDatabase(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Database) (result *GlobalDatabase, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("databases.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateDatabaseByName(ctx, objToCreate)
}

// DeleteDatabase calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *datafolderdomainGlobalTsmV1Chainer) DeleteDatabase(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("databases.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteDatabaseByName(ctx, hashedName)
}

// GetDataFolderByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetDataFolderByName(ctx context.Context, hashedName string) (*GlobalDataFolder, error) {
	key := "datafolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.DataFolder)
		return &GlobalDataFolder{
			client:     group.client,
			DataFolder: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			DataFolders().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalDataFolder{
			client:     group.client,
			DataFolder: result,
		}, nil
	}
}

// DeleteDataFolderByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteDataFolderByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DataFolders().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.DomainGvk != nil {
		err := group.client.
			Global().
			DeleteDataFolderDomainByName(ctx, result.Spec.DomainGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		DataFolders().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/dataFolderGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["runtimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateDataFolderByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateDataFolderByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DataFolder) (*GlobalDataFolder, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.DomainGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DataFolders().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["runtimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/dataFolderGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "DataFolder",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalDataFolder{
		client:     group.client,
		DataFolder: result,
	}, nil
}

// UpdateDataFolderByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateDataFolderByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.DataFolder) (*GlobalDataFolder, error) {
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			DataFolders().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		DataFolders().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalDataFolder{
		client:     group.client,
		DataFolder: result,
	}, nil
}

// ListDataFolders returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListDataFolders(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalDataFolder, err error) {
	key := "datafolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalDataFolder, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.DataFolder)
			result[k] = &GlobalDataFolder{
				client:     group.client,
				DataFolder: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			DataFolders().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalDataFolder, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalDataFolder{
				client:     group.client,
				DataFolder: &item,
			}
		}
	}
	return
}

type GlobalDataFolder struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.DataFolder
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalDataFolder) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteDataFolderByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.DataFolder = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalDataFolder) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateDataFolderByName(ctx, obj.DataFolder)
	if err != nil {
		return err
	}
	obj.DataFolder = result.DataFolder
	return nil
}

func (obj *GlobalDataFolder) GetParent(ctx context.Context) (result *GlobalRuntime, err error) {
	hashedName := helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["runtimes.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetRuntimeByName(ctx, hashedName)
}

// GetDomain returns child of given type
func (obj *GlobalDataFolder) GetDomain(ctx context.Context) (
	result *GlobalDataFolderDomain, err error) {
	if obj.Spec.DomainGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DataFolder", "Domain")
	}
	return obj.client.Global().GetDataFolderDomainByName(ctx, obj.Spec.DomainGvk.Name)
}

// AddDomain calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDataFolder) AddDomain(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DataFolderDomain) (result *GlobalDataFolderDomain, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["datafolders.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["datafolders.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateDataFolderDomainByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDataFolderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DataFolder = updatedObj.DataFolder
	}
	return
}

// DeleteDomain calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDataFolder) DeleteDomain(ctx context.Context) (err error) {
	if obj.Spec.DomainGvk != nil {
		err = obj.client.
			Global().DeleteDataFolderDomainByName(ctx, obj.Spec.DomainGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetDataFolderByName(ctx, obj.GetName())
	if err == nil {
		obj.DataFolder = updatedObj.DataFolder
	}
	return
}

type datafolderGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *datafolderGlobalTsmV1Chainer) Subscribe() {
	key := "datafolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDataFolderInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *datafolderGlobalTsmV1Chainer) Unsubscribe() {
	key := "datafolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *datafolderGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "datafolders.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *datafolderGlobalTsmV1Chainer) Domain(name string) *datafolderdomainGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["datafolderdomains.global.tsm.tanzu.vmware.com"] = name
	return &datafolderdomainGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetDomain calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *datafolderGlobalTsmV1Chainer) GetDomain(ctx context.Context, displayName string) (result *GlobalDataFolderDomain, err error) {
	hashedName := helper.GetHashedName("datafolderdomains.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetDataFolderDomainByName(ctx, hashedName)
}

// AddDomain calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *datafolderGlobalTsmV1Chainer) AddDomain(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DataFolderDomain) (result *GlobalDataFolderDomain, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("datafolderdomains.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateDataFolderDomainByName(ctx, objToCreate)
}

// DeleteDomain calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *datafolderGlobalTsmV1Chainer) DeleteDomain(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("datafolderdomains.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteDataFolderDomainByName(ctx, hashedName)
}

// GetDataGroupByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetDataGroupByName(ctx context.Context, hashedName string) (*GlobalDataGroup, error) {
	key := "datagroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.DataGroup)
		return &GlobalDataGroup{
			client:    group.client,
			DataGroup: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			DataGroups().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalDataGroup{
			client:    group.client,
			DataGroup: result,
		}, nil
	}
}

// DeleteDataGroupByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteDataGroupByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DataGroups().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		DataGroups().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/dataGroupsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["resourcegroups.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("resourcegroups.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ResourceGroups().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateDataGroupByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateDataGroupByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DataGroup) (*GlobalDataGroup, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DataGroups().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["resourcegroups.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("resourcegroups.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"dataGroupsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"DataGroup\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ResourceGroups().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalDataGroup{
		client:    group.client,
		DataGroup: result,
	}, nil
}

// UpdateDataGroupByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateDataGroupByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.DataGroup) (*GlobalDataGroup, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			DataGroups().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDisplayName :=
		objToUpdate.Spec.DisplayName
	patchOpDisplayName := PatchOp{
		Op:    "replace",
		Path:  "/spec/displayName",
		Value: patchValueDisplayName,
	}
	patch = append(patch, patchOpDisplayName)

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueScope :=
		objToUpdate.Spec.Scope
	patchOpScope := PatchOp{
		Op:    "replace",
		Path:  "/spec/scope",
		Value: patchValueScope,
	}
	patch = append(patch, patchOpScope)

	patchValueColor :=
		objToUpdate.Spec.Color
	patchOpColor := PatchOp{
		Op:    "replace",
		Path:  "/spec/color",
		Value: patchValueColor,
	}
	patch = append(patch, patchOpColor)

	patchValueRules :=
		objToUpdate.Spec.Rules
	patchOpRules := PatchOp{
		Op:    "replace",
		Path:  "/spec/rules",
		Value: patchValueRules,
	}
	patch = append(patch, patchOpRules)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		DataGroups().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalDataGroup{
		client:    group.client,
		DataGroup: result,
	}, nil
}

// ListDataGroups returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListDataGroups(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalDataGroup, err error) {
	key := "datagroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalDataGroup, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.DataGroup)
			result[k] = &GlobalDataGroup{
				client:    group.client,
				DataGroup: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			DataGroups().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalDataGroup, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalDataGroup{
				client:    group.client,
				DataGroup: &item,
			}
		}
	}
	return
}

type GlobalDataGroup struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.DataGroup
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalDataGroup) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteDataGroupByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.DataGroup = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalDataGroup) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateDataGroupByName(ctx, obj.DataGroup)
	if err != nil {
		return err
	}
	obj.DataGroup = result.DataGroup
	return nil
}

func (obj *GlobalDataGroup) GetParent(ctx context.Context) (result *GlobalResourceGroup, err error) {
	hashedName := helper.GetHashedName("resourcegroups.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["resourcegroups.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetResourceGroupByName(ctx, hashedName)
}

type datagroupGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *datagroupGlobalTsmV1Chainer) Subscribe() {
	key := "datagroups.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDataGroupInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *datagroupGlobalTsmV1Chainer) Unsubscribe() {
	key := "datagroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *datagroupGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "datagroups.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetDataTemplateByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetDataTemplateByName(ctx context.Context, hashedName string) (*GlobalDataTemplate, error) {
	key := "datatemplates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.DataTemplate)
		return &GlobalDataTemplate{
			client:       group.client,
			DataTemplate: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			DataTemplates().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalDataTemplate{
			client:       group.client,
			DataTemplate: result,
		}, nil
	}
}

// DeleteDataTemplateByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteDataTemplateByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DataTemplates().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		DataTemplates().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/dataTemplatesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["templategroups.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("templategroups.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		TemplateGroups().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateDataTemplateByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateDataTemplateByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DataTemplate) (*GlobalDataTemplate, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DataTemplates().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["templategroups.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("templategroups.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"dataTemplatesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"DataTemplate\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		TemplateGroups().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalDataTemplate{
		client:       group.client,
		DataTemplate: result,
	}, nil
}

// UpdateDataTemplateByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateDataTemplateByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.DataTemplate) (*GlobalDataTemplate, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			DataTemplates().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		DataTemplates().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalDataTemplate{
		client:       group.client,
		DataTemplate: result,
	}, nil
}

// ListDataTemplates returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListDataTemplates(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalDataTemplate, err error) {
	key := "datatemplates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalDataTemplate, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.DataTemplate)
			result[k] = &GlobalDataTemplate{
				client:       group.client,
				DataTemplate: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			DataTemplates().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalDataTemplate, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalDataTemplate{
				client:       group.client,
				DataTemplate: &item,
			}
		}
	}
	return
}

type GlobalDataTemplate struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.DataTemplate
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalDataTemplate) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteDataTemplateByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.DataTemplate = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalDataTemplate) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateDataTemplateByName(ctx, obj.DataTemplate)
	if err != nil {
		return err
	}
	obj.DataTemplate = result.DataTemplate
	return nil
}

func (obj *GlobalDataTemplate) GetParent(ctx context.Context) (result *GlobalTemplateGroup, err error) {
	hashedName := helper.GetHashedName("templategroups.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["templategroups.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetTemplateGroupByName(ctx, hashedName)
}

type datatemplateGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *datatemplateGlobalTsmV1Chainer) Subscribe() {
	key := "datatemplates.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDataTemplateInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *datatemplateGlobalTsmV1Chainer) Unsubscribe() {
	key := "datatemplates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *datatemplateGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "datatemplates.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetDatabaseByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetDatabaseByName(ctx context.Context, hashedName string) (*GlobalDatabase, error) {
	key := "databases.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Database)
		return &GlobalDatabase{
			client:   group.client,
			Database: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Databases().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalDatabase{
			client:   group.client,
			Database: result,
		}, nil
	}
}

// DeleteDatabaseByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteDatabaseByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Databases().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.TablesGvk {
		err := group.client.
			Global().DeleteTableByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.DirectoriesGvk {
		err := group.client.
			Global().DeleteDirectoryByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.BucketsGvk {
		err := group.client.
			Global().DeleteBucketByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Databases().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/databaseGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["datafolderdomains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("datafolderdomains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateDatabaseByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateDatabaseByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Database) (*GlobalDatabase, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.TablesGvk = nil
	objToCreate.Spec.DirectoriesGvk = nil
	objToCreate.Spec.BucketsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Databases().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["datafolderdomains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("datafolderdomains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/databaseGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "Database",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DataFolderDomains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalDatabase{
		client:   group.client,
		Database: result,
	}, nil
}

// UpdateDatabaseByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateDatabaseByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Database) (*GlobalDatabase, error) {
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Databases().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Databases().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalDatabase{
		client:   group.client,
		Database: result,
	}, nil
}

// ListDatabases returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListDatabases(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalDatabase, err error) {
	key := "databases.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalDatabase, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Database)
			result[k] = &GlobalDatabase{
				client:   group.client,
				Database: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Databases().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalDatabase, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalDatabase{
				client:   group.client,
				Database: &item,
			}
		}
	}
	return
}

type GlobalDatabase struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Database
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalDatabase) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteDatabaseByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Database = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalDatabase) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateDatabaseByName(ctx, obj.Database)
	if err != nil {
		return err
	}
	obj.Database = result.Database
	return nil
}

func (obj *GlobalDatabase) GetParent(ctx context.Context) (result *GlobalDataFolderDomain, err error) {
	hashedName := helper.GetHashedName("datafolderdomains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["datafolderdomains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDataFolderDomainByName(ctx, hashedName)
}

// GetAllTables returns all children of given type
func (obj *GlobalDatabase) GetAllTables(ctx context.Context) (
	result []*GlobalTable, err error) {
	result = make([]*GlobalTable, 0, len(obj.Spec.TablesGvk))
	for _, v := range obj.Spec.TablesGvk {
		l, err := obj.client.Global().GetTableByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetTables returns child which has given displayName
func (obj *GlobalDatabase) GetTables(ctx context.Context,
	displayName string) (result *GlobalTable, err error) {
	l, ok := obj.Spec.TablesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Database", "Tables", displayName)
	}
	result, err = obj.client.Global().GetTableByName(ctx, l.Name)
	return
}

// AddTables calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDatabase) AddTables(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Table) (result *GlobalTable, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["databases.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["databases.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateTableByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDatabaseByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Database = updatedObj.Database
	}
	return
}

// DeleteTables calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDatabase) DeleteTables(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.TablesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Database", "Tables", displayName)
	}
	err = obj.client.Global().DeleteTableByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDatabaseByName(ctx, obj.GetName())
	if err == nil {
		obj.Database = updatedObj.Database
	}
	return
}

// GetAllDirectories returns all children of given type
func (obj *GlobalDatabase) GetAllDirectories(ctx context.Context) (
	result []*GlobalDirectory, err error) {
	result = make([]*GlobalDirectory, 0, len(obj.Spec.DirectoriesGvk))
	for _, v := range obj.Spec.DirectoriesGvk {
		l, err := obj.client.Global().GetDirectoryByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetDirectories returns child which has given displayName
func (obj *GlobalDatabase) GetDirectories(ctx context.Context,
	displayName string) (result *GlobalDirectory, err error) {
	l, ok := obj.Spec.DirectoriesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Database", "Directories", displayName)
	}
	result, err = obj.client.Global().GetDirectoryByName(ctx, l.Name)
	return
}

// AddDirectories calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDatabase) AddDirectories(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Directory) (result *GlobalDirectory, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["databases.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["databases.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateDirectoryByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDatabaseByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Database = updatedObj.Database
	}
	return
}

// DeleteDirectories calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDatabase) DeleteDirectories(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.DirectoriesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Database", "Directories", displayName)
	}
	err = obj.client.Global().DeleteDirectoryByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDatabaseByName(ctx, obj.GetName())
	if err == nil {
		obj.Database = updatedObj.Database
	}
	return
}

// GetAllBuckets returns all children of given type
func (obj *GlobalDatabase) GetAllBuckets(ctx context.Context) (
	result []*GlobalBucket, err error) {
	result = make([]*GlobalBucket, 0, len(obj.Spec.BucketsGvk))
	for _, v := range obj.Spec.BucketsGvk {
		l, err := obj.client.Global().GetBucketByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetBuckets returns child which has given displayName
func (obj *GlobalDatabase) GetBuckets(ctx context.Context,
	displayName string) (result *GlobalBucket, err error) {
	l, ok := obj.Spec.BucketsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Database", "Buckets", displayName)
	}
	result, err = obj.client.Global().GetBucketByName(ctx, l.Name)
	return
}

// AddBuckets calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDatabase) AddBuckets(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Bucket) (result *GlobalBucket, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["databases.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["databases.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateBucketByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDatabaseByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Database = updatedObj.Database
	}
	return
}

// DeleteBuckets calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDatabase) DeleteBuckets(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.BucketsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Database", "Buckets", displayName)
	}
	err = obj.client.Global().DeleteBucketByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDatabaseByName(ctx, obj.GetName())
	if err == nil {
		obj.Database = updatedObj.Database
	}
	return
}

type databaseGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *databaseGlobalTsmV1Chainer) Subscribe() {
	key := "databases.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDatabaseInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *databaseGlobalTsmV1Chainer) Unsubscribe() {
	key := "databases.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *databaseGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "databases.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *databaseGlobalTsmV1Chainer) Tables(name string) *tableGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["tables.global.tsm.tanzu.vmware.com"] = name
	return &tableGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetTables calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *databaseGlobalTsmV1Chainer) GetTables(ctx context.Context, displayName string) (result *GlobalTable, err error) {
	hashedName := helper.GetHashedName("tables.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetTableByName(ctx, hashedName)
}

// AddTables calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *databaseGlobalTsmV1Chainer) AddTables(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Table) (result *GlobalTable, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("tables.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateTableByName(ctx, objToCreate)
}

// DeleteTables calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *databaseGlobalTsmV1Chainer) DeleteTables(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("tables.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteTableByName(ctx, hashedName)
}

func (c *databaseGlobalTsmV1Chainer) Directories(name string) *directoryGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["directories.global.tsm.tanzu.vmware.com"] = name
	return &directoryGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetDirectories calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *databaseGlobalTsmV1Chainer) GetDirectories(ctx context.Context, displayName string) (result *GlobalDirectory, err error) {
	hashedName := helper.GetHashedName("directories.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetDirectoryByName(ctx, hashedName)
}

// AddDirectories calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *databaseGlobalTsmV1Chainer) AddDirectories(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Directory) (result *GlobalDirectory, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("directories.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateDirectoryByName(ctx, objToCreate)
}

// DeleteDirectories calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *databaseGlobalTsmV1Chainer) DeleteDirectories(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("directories.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteDirectoryByName(ctx, hashedName)
}

func (c *databaseGlobalTsmV1Chainer) Buckets(name string) *bucketGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["buckets.global.tsm.tanzu.vmware.com"] = name
	return &bucketGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetBuckets calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *databaseGlobalTsmV1Chainer) GetBuckets(ctx context.Context, displayName string) (result *GlobalBucket, err error) {
	hashedName := helper.GetHashedName("buckets.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetBucketByName(ctx, hashedName)
}

// AddBuckets calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *databaseGlobalTsmV1Chainer) AddBuckets(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Bucket) (result *GlobalBucket, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("buckets.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateBucketByName(ctx, objToCreate)
}

// DeleteBuckets calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *databaseGlobalTsmV1Chainer) DeleteBuckets(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("buckets.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteBucketByName(ctx, hashedName)
}

// GetDCRegionByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetDCRegionByName(ctx context.Context, hashedName string) (*GlobalDCRegion, error) {
	key := "dcregions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.DCRegion)
		return &GlobalDCRegion{
			client:   group.client,
			DCRegion: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			DCRegions().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalDCRegion{
			client:   group.client,
			DCRegion: result,
		}, nil
	}
}

// DeleteDCRegionByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteDCRegionByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DCRegions().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.ZonesGvk {
		err := group.client.
			Global().DeleteDCZoneByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		DCRegions().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/regionsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["inventories.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("inventories.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Inventories().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateDCRegionByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateDCRegionByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DCRegion) (*GlobalDCRegion, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ZonesGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DCRegions().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["inventories.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("inventories.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"regionsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"DCRegion\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Inventories().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalDCRegion{
		client:   group.client,
		DCRegion: result,
	}, nil
}

// UpdateDCRegionByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateDCRegionByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.DCRegion) (*GlobalDCRegion, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			DCRegions().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		DCRegions().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalDCRegion{
		client:   group.client,
		DCRegion: result,
	}, nil
}

// ListDCRegions returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListDCRegions(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalDCRegion, err error) {
	key := "dcregions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalDCRegion, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.DCRegion)
			result[k] = &GlobalDCRegion{
				client:   group.client,
				DCRegion: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			DCRegions().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalDCRegion, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalDCRegion{
				client:   group.client,
				DCRegion: &item,
			}
		}
	}
	return
}

type GlobalDCRegion struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.DCRegion
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalDCRegion) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteDCRegionByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.DCRegion = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalDCRegion) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateDCRegionByName(ctx, obj.DCRegion)
	if err != nil {
		return err
	}
	obj.DCRegion = result.DCRegion
	return nil
}

func (obj *GlobalDCRegion) GetParent(ctx context.Context) (result *GlobalInventory, err error) {
	hashedName := helper.GetHashedName("inventories.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["inventories.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetInventoryByName(ctx, hashedName)
}

// GetAllZones returns all children of given type
func (obj *GlobalDCRegion) GetAllZones(ctx context.Context) (
	result []*GlobalDCZone, err error) {
	result = make([]*GlobalDCZone, 0, len(obj.Spec.ZonesGvk))
	for _, v := range obj.Spec.ZonesGvk {
		l, err := obj.client.Global().GetDCZoneByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetZones returns child which has given displayName
func (obj *GlobalDCRegion) GetZones(ctx context.Context,
	displayName string) (result *GlobalDCZone, err error) {
	l, ok := obj.Spec.ZonesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DCRegion", "Zones", displayName)
	}
	result, err = obj.client.Global().GetDCZoneByName(ctx, l.Name)
	return
}

// AddZones calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDCRegion) AddZones(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DCZone) (result *GlobalDCZone, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["dcregions.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["dcregions.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateDCZoneByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDCRegionByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DCRegion = updatedObj.DCRegion
	}
	return
}

// DeleteZones calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDCRegion) DeleteZones(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ZonesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DCRegion", "Zones", displayName)
	}
	err = obj.client.Global().DeleteDCZoneByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDCRegionByName(ctx, obj.GetName())
	if err == nil {
		obj.DCRegion = updatedObj.DCRegion
	}
	return
}

type dcregionGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *dcregionGlobalTsmV1Chainer) Subscribe() {
	key := "dcregions.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDCRegionInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *dcregionGlobalTsmV1Chainer) Unsubscribe() {
	key := "dcregions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *dcregionGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "dcregions.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *dcregionGlobalTsmV1Chainer) Zones(name string) *dczoneGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["dczones.global.tsm.tanzu.vmware.com"] = name
	return &dczoneGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetZones calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *dcregionGlobalTsmV1Chainer) GetZones(ctx context.Context, displayName string) (result *GlobalDCZone, err error) {
	hashedName := helper.GetHashedName("dczones.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetDCZoneByName(ctx, hashedName)
}

// AddZones calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *dcregionGlobalTsmV1Chainer) AddZones(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DCZone) (result *GlobalDCZone, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("dczones.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateDCZoneByName(ctx, objToCreate)
}

// DeleteZones calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *dcregionGlobalTsmV1Chainer) DeleteZones(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("dczones.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteDCZoneByName(ctx, hashedName)
}

// GetDCZoneByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetDCZoneByName(ctx context.Context, hashedName string) (*GlobalDCZone, error) {
	key := "dczones.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.DCZone)
		return &GlobalDCZone{
			client: group.client,
			DCZone: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			DCZones().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalDCZone{
			client: group.client,
			DCZone: result,
		}, nil
	}
}

// DeleteDCZoneByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteDCZoneByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DCZones().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		DCZones().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/zonesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["dcregions.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("dcregions.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DCRegions().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateDCZoneByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateDCZoneByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DCZone) (*GlobalDCZone, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ClustersGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DCZones().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["dcregions.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("dcregions.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"zonesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"DCZone\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DCRegions().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalDCZone{
		client: group.client,
		DCZone: result,
	}, nil
}

// UpdateDCZoneByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateDCZoneByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.DCZone) (*GlobalDCZone, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			DCZones().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		DCZones().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalDCZone{
		client: group.client,
		DCZone: result,
	}, nil
}

// ListDCZones returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListDCZones(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalDCZone, err error) {
	key := "dczones.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalDCZone, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.DCZone)
			result[k] = &GlobalDCZone{
				client: group.client,
				DCZone: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			DCZones().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalDCZone, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalDCZone{
				client: group.client,
				DCZone: &item,
			}
		}
	}
	return
}

type GlobalDCZone struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.DCZone
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalDCZone) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteDCZoneByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.DCZone = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalDCZone) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateDCZoneByName(ctx, obj.DCZone)
	if err != nil {
		return err
	}
	obj.DCZone = result.DCZone
	return nil
}

func (obj *GlobalDCZone) GetParent(ctx context.Context) (result *GlobalDCRegion, err error) {
	hashedName := helper.GetHashedName("dcregions.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["dcregions.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDCRegionByName(ctx, hashedName)
}

// GetAllClusters returns all links of given type
func (obj *GlobalDCZone) GetAllClusters(ctx context.Context) (
	result []*GlobalCluster, err error) {
	result = make([]*GlobalCluster, 0, len(obj.Spec.ClustersGvk))
	for _, v := range obj.Spec.ClustersGvk {
		l, err := obj.client.Global().GetClusterByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetClusters returns link which has given displayName
func (obj *GlobalDCZone) GetClusters(ctx context.Context,
	displayName string) (result *GlobalCluster, err error) {
	l, ok := obj.Spec.ClustersGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.DCZone", "Clusters", displayName)
	}
	result, err = obj.client.Global().GetClusterByName(ctx, l.Name)
	return
}

// LinkClusters links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalDCZone) LinkClusters(ctx context.Context,
	linkToAdd *GlobalCluster) error {

	payload := "{\"spec\": {\"clustersGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"Cluster\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().DCZones().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.DCZone = result
	return nil
}

// UnlinkClusters unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalDCZone) UnlinkClusters(ctx context.Context,
	linkToRemove *GlobalCluster) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/clustersGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().DCZones().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.DCZone = result
	return nil

}

type dczoneGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *dczoneGlobalTsmV1Chainer) Subscribe() {
	key := "dczones.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDCZoneInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *dczoneGlobalTsmV1Chainer) Unsubscribe() {
	key := "dczones.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *dczoneGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "dczones.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetDestinationRuleByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetDestinationRuleByName(ctx context.Context, hashedName string) (*GlobalDestinationRule, error) {
	key := "destinationrules.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.DestinationRule)
		return &GlobalDestinationRule{
			client:          group.client,
			DestinationRule: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			DestinationRules().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalDestinationRule{
			client:          group.client,
			DestinationRule: result,
		}, nil
	}
}

// DeleteDestinationRuleByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteDestinationRuleByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DestinationRules().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		DestinationRules().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/destinationRulesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateDestinationRuleByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateDestinationRuleByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DestinationRule) (*GlobalDestinationRule, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ServiceGvk = nil
	objToCreate.Spec.ServiceDeploymentsGvk = nil
	objToCreate.Spec.ServiceReplicaSetsGvk = nil
	objToCreate.Spec.ServiceStatefulSetsGvk = nil
	objToCreate.Spec.ServiceDaemonSetsGvk = nil
	objToCreate.Spec.ServiceJobsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DestinationRules().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"destinationRulesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"DestinationRule\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalDestinationRule{
		client:          group.client,
		DestinationRule: result,
	}, nil
}

// UpdateDestinationRuleByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateDestinationRuleByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.DestinationRule) (*GlobalDestinationRule, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			DestinationRules().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueAnnotations :=
		objToUpdate.Spec.Annotations
	patchOpAnnotations := PatchOp{
		Op:    "replace",
		Path:  "/spec/annotations",
		Value: patchValueAnnotations,
	}
	patch = append(patch, patchOpAnnotations)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueCreationTimestamp :=
		objToUpdate.Spec.CreationTimestamp
	patchOpCreationTimestamp := PatchOp{
		Op:    "replace",
		Path:  "/spec/creationTimestamp",
		Value: patchValueCreationTimestamp,
	}
	patch = append(patch, patchOpCreationTimestamp)

	patchValueApiLink :=
		objToUpdate.Spec.ApiLink
	patchOpApiLink := PatchOp{
		Op:    "replace",
		Path:  "/spec/apiLink",
		Value: patchValueApiLink,
	}
	patch = append(patch, patchOpApiLink)

	patchValueUid :=
		objToUpdate.Spec.Uid
	patchOpUid := PatchOp{
		Op:    "replace",
		Path:  "/spec/uid",
		Value: patchValueUid,
	}
	patch = append(patch, patchOpUid)

	patchValueHost :=
		objToUpdate.Spec.Host
	patchOpHost := PatchOp{
		Op:    "replace",
		Path:  "/spec/host",
		Value: patchValueHost,
	}
	patch = append(patch, patchOpHost)

	patchValueTrafficPolicy :=
		objToUpdate.Spec.TrafficPolicy
	patchOpTrafficPolicy := PatchOp{
		Op:    "replace",
		Path:  "/spec/trafficPolicy",
		Value: patchValueTrafficPolicy,
	}
	patch = append(patch, patchOpTrafficPolicy)

	patchValueSubsets :=
		objToUpdate.Spec.Subsets
	patchOpSubsets := PatchOp{
		Op:    "replace",
		Path:  "/spec/subsets",
		Value: patchValueSubsets,
	}
	patch = append(patch, patchOpSubsets)

	if objToUpdate.Spec.ExportTo != nil {
		patchValueExportTo :=
			objToUpdate.Spec.ExportTo
		patchOpExportTo := PatchOp{
			Op:    "replace",
			Path:  "/spec/exportTo",
			Value: patchValueExportTo,
		}
		patch = append(patch, patchOpExportTo)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		DestinationRules().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalDestinationRule{
		client:          group.client,
		DestinationRule: result,
	}, nil
}

// ListDestinationRules returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListDestinationRules(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalDestinationRule, err error) {
	key := "destinationrules.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalDestinationRule, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.DestinationRule)
			result[k] = &GlobalDestinationRule{
				client:          group.client,
				DestinationRule: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			DestinationRules().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalDestinationRule, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalDestinationRule{
				client:          group.client,
				DestinationRule: &item,
			}
		}
	}
	return
}

type GlobalDestinationRule struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.DestinationRule
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalDestinationRule) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteDestinationRuleByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.DestinationRule = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalDestinationRule) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateDestinationRuleByName(ctx, obj.DestinationRule)
	if err != nil {
		return err
	}
	obj.DestinationRule = result.DestinationRule
	return nil
}

func (obj *GlobalDestinationRule) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

// GetService returns link of given type
func (obj *GlobalDestinationRule) GetService(ctx context.Context) (
	result *GlobalService, err error) {
	if obj.Spec.ServiceGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.DestinationRule", "Service")
	}
	return obj.client.Global().GetServiceByName(ctx, obj.Spec.ServiceGvk.Name)
}

// LinkService links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalDestinationRule) LinkService(ctx context.Context,
	linkToAdd *GlobalService) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/serviceGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "Service",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().DestinationRules().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.DestinationRule = result
	return nil
}

// UnlinkService unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalDestinationRule) UnlinkService(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().DestinationRules().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.DestinationRule = result
	return nil

}

// GetAllServiceDeployments returns all links of given type
func (obj *GlobalDestinationRule) GetAllServiceDeployments(ctx context.Context) (
	result []*GlobalServiceDeployment, err error) {
	result = make([]*GlobalServiceDeployment, 0, len(obj.Spec.ServiceDeploymentsGvk))
	for _, v := range obj.Spec.ServiceDeploymentsGvk {
		l, err := obj.client.Global().GetServiceDeploymentByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceDeployments returns link which has given displayName
func (obj *GlobalDestinationRule) GetServiceDeployments(ctx context.Context,
	displayName string) (result *GlobalServiceDeployment, err error) {
	l, ok := obj.Spec.ServiceDeploymentsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.DestinationRule", "ServiceDeployments", displayName)
	}
	result, err = obj.client.Global().GetServiceDeploymentByName(ctx, l.Name)
	return
}

// LinkServiceDeployments links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalDestinationRule) LinkServiceDeployments(ctx context.Context,
	linkToAdd *GlobalServiceDeployment) error {

	payload := "{\"spec\": {\"serviceDeploymentsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceDeployment\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().DestinationRules().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.DestinationRule = result
	return nil
}

// UnlinkServiceDeployments unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalDestinationRule) UnlinkServiceDeployments(ctx context.Context,
	linkToRemove *GlobalServiceDeployment) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceDeploymentsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().DestinationRules().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.DestinationRule = result
	return nil

}

// GetAllServiceReplicaSets returns all links of given type
func (obj *GlobalDestinationRule) GetAllServiceReplicaSets(ctx context.Context) (
	result []*GlobalServiceReplicaSet, err error) {
	result = make([]*GlobalServiceReplicaSet, 0, len(obj.Spec.ServiceReplicaSetsGvk))
	for _, v := range obj.Spec.ServiceReplicaSetsGvk {
		l, err := obj.client.Global().GetServiceReplicaSetByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceReplicaSets returns link which has given displayName
func (obj *GlobalDestinationRule) GetServiceReplicaSets(ctx context.Context,
	displayName string) (result *GlobalServiceReplicaSet, err error) {
	l, ok := obj.Spec.ServiceReplicaSetsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.DestinationRule", "ServiceReplicaSets", displayName)
	}
	result, err = obj.client.Global().GetServiceReplicaSetByName(ctx, l.Name)
	return
}

// LinkServiceReplicaSets links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalDestinationRule) LinkServiceReplicaSets(ctx context.Context,
	linkToAdd *GlobalServiceReplicaSet) error {

	payload := "{\"spec\": {\"serviceReplicaSetsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceReplicaSet\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().DestinationRules().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.DestinationRule = result
	return nil
}

// UnlinkServiceReplicaSets unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalDestinationRule) UnlinkServiceReplicaSets(ctx context.Context,
	linkToRemove *GlobalServiceReplicaSet) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceReplicaSetsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().DestinationRules().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.DestinationRule = result
	return nil

}

// GetAllServiceStatefulSets returns all links of given type
func (obj *GlobalDestinationRule) GetAllServiceStatefulSets(ctx context.Context) (
	result []*GlobalServiceStatefulSet, err error) {
	result = make([]*GlobalServiceStatefulSet, 0, len(obj.Spec.ServiceStatefulSetsGvk))
	for _, v := range obj.Spec.ServiceStatefulSetsGvk {
		l, err := obj.client.Global().GetServiceStatefulSetByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceStatefulSets returns link which has given displayName
func (obj *GlobalDestinationRule) GetServiceStatefulSets(ctx context.Context,
	displayName string) (result *GlobalServiceStatefulSet, err error) {
	l, ok := obj.Spec.ServiceStatefulSetsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.DestinationRule", "ServiceStatefulSets", displayName)
	}
	result, err = obj.client.Global().GetServiceStatefulSetByName(ctx, l.Name)
	return
}

// LinkServiceStatefulSets links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalDestinationRule) LinkServiceStatefulSets(ctx context.Context,
	linkToAdd *GlobalServiceStatefulSet) error {

	payload := "{\"spec\": {\"serviceStatefulSetsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceStatefulSet\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().DestinationRules().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.DestinationRule = result
	return nil
}

// UnlinkServiceStatefulSets unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalDestinationRule) UnlinkServiceStatefulSets(ctx context.Context,
	linkToRemove *GlobalServiceStatefulSet) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceStatefulSetsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().DestinationRules().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.DestinationRule = result
	return nil

}

// GetAllServiceDaemonSets returns all links of given type
func (obj *GlobalDestinationRule) GetAllServiceDaemonSets(ctx context.Context) (
	result []*GlobalServiceDaemonSet, err error) {
	result = make([]*GlobalServiceDaemonSet, 0, len(obj.Spec.ServiceDaemonSetsGvk))
	for _, v := range obj.Spec.ServiceDaemonSetsGvk {
		l, err := obj.client.Global().GetServiceDaemonSetByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceDaemonSets returns link which has given displayName
func (obj *GlobalDestinationRule) GetServiceDaemonSets(ctx context.Context,
	displayName string) (result *GlobalServiceDaemonSet, err error) {
	l, ok := obj.Spec.ServiceDaemonSetsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.DestinationRule", "ServiceDaemonSets", displayName)
	}
	result, err = obj.client.Global().GetServiceDaemonSetByName(ctx, l.Name)
	return
}

// LinkServiceDaemonSets links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalDestinationRule) LinkServiceDaemonSets(ctx context.Context,
	linkToAdd *GlobalServiceDaemonSet) error {

	payload := "{\"spec\": {\"serviceDaemonSetsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceDaemonSet\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().DestinationRules().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.DestinationRule = result
	return nil
}

// UnlinkServiceDaemonSets unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalDestinationRule) UnlinkServiceDaemonSets(ctx context.Context,
	linkToRemove *GlobalServiceDaemonSet) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceDaemonSetsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().DestinationRules().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.DestinationRule = result
	return nil

}

// GetAllServiceJobs returns all links of given type
func (obj *GlobalDestinationRule) GetAllServiceJobs(ctx context.Context) (
	result []*GlobalServiceJob, err error) {
	result = make([]*GlobalServiceJob, 0, len(obj.Spec.ServiceJobsGvk))
	for _, v := range obj.Spec.ServiceJobsGvk {
		l, err := obj.client.Global().GetServiceJobByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceJobs returns link which has given displayName
func (obj *GlobalDestinationRule) GetServiceJobs(ctx context.Context,
	displayName string) (result *GlobalServiceJob, err error) {
	l, ok := obj.Spec.ServiceJobsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.DestinationRule", "ServiceJobs", displayName)
	}
	result, err = obj.client.Global().GetServiceJobByName(ctx, l.Name)
	return
}

// LinkServiceJobs links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalDestinationRule) LinkServiceJobs(ctx context.Context,
	linkToAdd *GlobalServiceJob) error {

	payload := "{\"spec\": {\"serviceJobsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceJob\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().DestinationRules().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.DestinationRule = result
	return nil
}

// UnlinkServiceJobs unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalDestinationRule) UnlinkServiceJobs(ctx context.Context,
	linkToRemove *GlobalServiceJob) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceJobsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().DestinationRules().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.DestinationRule = result
	return nil

}

type destinationruleGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *destinationruleGlobalTsmV1Chainer) Subscribe() {
	key := "destinationrules.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDestinationRuleInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *destinationruleGlobalTsmV1Chainer) Unsubscribe() {
	key := "destinationrules.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *destinationruleGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "destinationrules.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetDirectoryByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetDirectoryByName(ctx context.Context, hashedName string) (*GlobalDirectory, error) {
	key := "directories.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Directory)
		return &GlobalDirectory{
			client:    group.client,
			Directory: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Directories().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalDirectory{
			client:    group.client,
			Directory: result,
		}, nil
	}
}

// DeleteDirectoryByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteDirectoryByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Directories().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Directories().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/directoriesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["databases.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("databases.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Databases().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateDirectoryByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateDirectoryByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Directory) (*GlobalDirectory, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.TemplateGvk = nil
	objToCreate.Spec.InventoryGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Directories().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["databases.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("databases.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"directoriesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"Directory\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Databases().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalDirectory{
		client:    group.client,
		Directory: result,
	}, nil
}

// UpdateDirectoryByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateDirectoryByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Directory) (*GlobalDirectory, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Directories().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Directories().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalDirectory{
		client:    group.client,
		Directory: result,
	}, nil
}

// ListDirectories returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListDirectories(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalDirectory, err error) {
	key := "directories.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalDirectory, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Directory)
			result[k] = &GlobalDirectory{
				client:    group.client,
				Directory: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Directories().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalDirectory, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalDirectory{
				client:    group.client,
				Directory: &item,
			}
		}
	}
	return
}

type GlobalDirectory struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Directory
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalDirectory) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteDirectoryByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Directory = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalDirectory) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateDirectoryByName(ctx, obj.Directory)
	if err != nil {
		return err
	}
	obj.Directory = result.Directory
	return nil
}

func (obj *GlobalDirectory) GetParent(ctx context.Context) (result *GlobalDatabase, err error) {
	hashedName := helper.GetHashedName("databases.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["databases.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDatabaseByName(ctx, hashedName)
}

// GetTemplate returns link of given type
func (obj *GlobalDirectory) GetTemplate(ctx context.Context) (
	result *GlobalTemplate, err error) {
	if obj.Spec.TemplateGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.Directory", "Template")
	}
	return obj.client.Global().GetTemplateByName(ctx, obj.Spec.TemplateGvk.Name)
}

// LinkTemplate links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalDirectory) LinkTemplate(ctx context.Context,
	linkToAdd *GlobalTemplate) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/templateGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "Template",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Directories().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Directory = result
	return nil
}

// UnlinkTemplate unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalDirectory) UnlinkTemplate(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/templateGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Directories().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Directory = result
	return nil

}

// GetInventory returns link of given type
func (obj *GlobalDirectory) GetInventory(ctx context.Context) (
	result *GlobalInventory, err error) {
	if obj.Spec.InventoryGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.Directory", "Inventory")
	}
	return obj.client.Global().GetInventoryByName(ctx, obj.Spec.InventoryGvk.Name)
}

// LinkInventory links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalDirectory) LinkInventory(ctx context.Context,
	linkToAdd *GlobalInventory) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/inventoryGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "Inventory",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Directories().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Directory = result
	return nil
}

// UnlinkInventory unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalDirectory) UnlinkInventory(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/inventoryGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Directories().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Directory = result
	return nil

}

type directoryGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *directoryGlobalTsmV1Chainer) Subscribe() {
	key := "directories.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDirectoryInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *directoryGlobalTsmV1Chainer) Unsubscribe() {
	key := "directories.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *directoryGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "directories.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetDNSConfigFolderByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetDNSConfigFolderByName(ctx context.Context, hashedName string) (*GlobalDNSConfigFolder, error) {
	key := "dnsconfigfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.DNSConfigFolder)
		return &GlobalDNSConfigFolder{
			client:          group.client,
			DNSConfigFolder: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			DNSConfigFolders().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalDNSConfigFolder{
			client:          group.client,
			DNSConfigFolder: result,
		}, nil
	}
}

// DeleteDNSConfigFolderByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteDNSConfigFolderByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DNSConfigFolders().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.DnsConfigGvk {
		err := group.client.
			Global().DeleteDNSConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		DNSConfigFolders().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/dnsConfigFolderGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["clusterconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateDNSConfigFolderByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateDNSConfigFolderByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DNSConfigFolder) (*GlobalDNSConfigFolder, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.DnsConfigGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DNSConfigFolders().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["clusterconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/dnsConfigFolderGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "DNSConfigFolder",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalDNSConfigFolder{
		client:          group.client,
		DNSConfigFolder: result,
	}, nil
}

// UpdateDNSConfigFolderByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateDNSConfigFolderByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.DNSConfigFolder) (*GlobalDNSConfigFolder, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			DNSConfigFolders().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		DNSConfigFolders().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalDNSConfigFolder{
		client:          group.client,
		DNSConfigFolder: result,
	}, nil
}

// ListDNSConfigFolders returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListDNSConfigFolders(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalDNSConfigFolder, err error) {
	key := "dnsconfigfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalDNSConfigFolder, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.DNSConfigFolder)
			result[k] = &GlobalDNSConfigFolder{
				client:          group.client,
				DNSConfigFolder: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			DNSConfigFolders().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalDNSConfigFolder, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalDNSConfigFolder{
				client:          group.client,
				DNSConfigFolder: &item,
			}
		}
	}
	return
}

type GlobalDNSConfigFolder struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.DNSConfigFolder
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalDNSConfigFolder) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteDNSConfigFolderByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.DNSConfigFolder = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalDNSConfigFolder) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateDNSConfigFolderByName(ctx, obj.DNSConfigFolder)
	if err != nil {
		return err
	}
	obj.DNSConfigFolder = result.DNSConfigFolder
	return nil
}

func (obj *GlobalDNSConfigFolder) GetParent(ctx context.Context) (result *GlobalClusterConfig, err error) {
	hashedName := helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["clusterconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetClusterConfigByName(ctx, hashedName)
}

// GetAllDnsConfig returns all children of given type
func (obj *GlobalDNSConfigFolder) GetAllDnsConfig(ctx context.Context) (
	result []*GlobalDNSConfig, err error) {
	result = make([]*GlobalDNSConfig, 0, len(obj.Spec.DnsConfigGvk))
	for _, v := range obj.Spec.DnsConfigGvk {
		l, err := obj.client.Global().GetDNSConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetDnsConfig returns child which has given displayName
func (obj *GlobalDNSConfigFolder) GetDnsConfig(ctx context.Context,
	displayName string) (result *GlobalDNSConfig, err error) {
	l, ok := obj.Spec.DnsConfigGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DNSConfigFolder", "DnsConfig", displayName)
	}
	result, err = obj.client.Global().GetDNSConfigByName(ctx, l.Name)
	return
}

// AddDnsConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDNSConfigFolder) AddDnsConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DNSConfig) (result *GlobalDNSConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["dnsconfigfolders.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["dnsconfigfolders.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateDNSConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDNSConfigFolderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DNSConfigFolder = updatedObj.DNSConfigFolder
	}
	return
}

// DeleteDnsConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDNSConfigFolder) DeleteDnsConfig(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.DnsConfigGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DNSConfigFolder", "DnsConfig", displayName)
	}
	err = obj.client.Global().DeleteDNSConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDNSConfigFolderByName(ctx, obj.GetName())
	if err == nil {
		obj.DNSConfigFolder = updatedObj.DNSConfigFolder
	}
	return
}

type dnsconfigfolderGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *dnsconfigfolderGlobalTsmV1Chainer) Subscribe() {
	key := "dnsconfigfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDNSConfigFolderInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *dnsconfigfolderGlobalTsmV1Chainer) Unsubscribe() {
	key := "dnsconfigfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *dnsconfigfolderGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "dnsconfigfolders.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *dnsconfigfolderGlobalTsmV1Chainer) DnsConfig(name string) *dnsconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["dnsconfigs.global.tsm.tanzu.vmware.com"] = name
	return &dnsconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetDnsConfig calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *dnsconfigfolderGlobalTsmV1Chainer) GetDnsConfig(ctx context.Context, displayName string) (result *GlobalDNSConfig, err error) {
	hashedName := helper.GetHashedName("dnsconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetDNSConfigByName(ctx, hashedName)
}

// AddDnsConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *dnsconfigfolderGlobalTsmV1Chainer) AddDnsConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DNSConfig) (result *GlobalDNSConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("dnsconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateDNSConfigByName(ctx, objToCreate)
}

// DeleteDnsConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *dnsconfigfolderGlobalTsmV1Chainer) DeleteDnsConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("dnsconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteDNSConfigByName(ctx, hashedName)
}

// GetDNSConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetDNSConfigByName(ctx context.Context, hashedName string) (*GlobalDNSConfig, error) {
	key := "dnsconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.DNSConfig)
		return &GlobalDNSConfig{
			client:    group.client,
			DNSConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			DNSConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalDNSConfig{
			client:    group.client,
			DNSConfig: result,
		}, nil
	}
}

// DeleteDNSConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteDNSConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DNSConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		DNSConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/dnsConfigGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["dnsconfigfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("dnsconfigfolders.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DNSConfigFolders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateDNSConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateDNSConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DNSConfig) (*GlobalDNSConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DNSConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["dnsconfigfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("dnsconfigfolders.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"dnsConfigGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"DNSConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DNSConfigFolders().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalDNSConfig{
		client:    group.client,
		DNSConfig: result,
	}, nil
}

// UpdateDNSConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateDNSConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.DNSConfig) (*GlobalDNSConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			DNSConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueOwnedBy :=
		objToUpdate.Spec.OwnedBy
	patchOpOwnedBy := PatchOp{
		Op:    "replace",
		Path:  "/spec/ownedBy",
		Value: patchValueOwnedBy,
	}
	patch = append(patch, patchOpOwnedBy)

	patchValueDnsSuffix :=
		objToUpdate.Spec.DnsSuffix
	patchOpDnsSuffix := PatchOp{
		Op:    "replace",
		Path:  "/spec/dnsSuffix",
		Value: patchValueDnsSuffix,
	}
	patch = append(patch, patchOpDnsSuffix)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		DNSConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalDNSConfig{
		client:    group.client,
		DNSConfig: result,
	}, nil
}

// ListDNSConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListDNSConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalDNSConfig, err error) {
	key := "dnsconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalDNSConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.DNSConfig)
			result[k] = &GlobalDNSConfig{
				client:    group.client,
				DNSConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			DNSConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalDNSConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalDNSConfig{
				client:    group.client,
				DNSConfig: &item,
			}
		}
	}
	return
}

type GlobalDNSConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.DNSConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalDNSConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteDNSConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.DNSConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalDNSConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateDNSConfigByName(ctx, obj.DNSConfig)
	if err != nil {
		return err
	}
	obj.DNSConfig = result.DNSConfig
	return nil
}

func (obj *GlobalDNSConfig) GetParent(ctx context.Context) (result *GlobalDNSConfigFolder, err error) {
	hashedName := helper.GetHashedName("dnsconfigfolders.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["dnsconfigfolders.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDNSConfigFolderByName(ctx, hashedName)
}

type dnsconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *dnsconfigGlobalTsmV1Chainer) Subscribe() {
	key := "dnsconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDNSConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *dnsconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "dnsconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *dnsconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "dnsconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetDNSProbeConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetDNSProbeConfigByName(ctx context.Context, hashedName string) (*GlobalDNSProbeConfig, error) {
	key := "dnsprobeconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.DNSProbeConfig)
		return &GlobalDNSProbeConfig{
			client:         group.client,
			DNSProbeConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			DNSProbeConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalDNSProbeConfig{
			client:         group.client,
			DNSProbeConfig: result,
		}, nil
	}
}

// DeleteDNSProbeConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteDNSProbeConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DNSProbeConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		DNSProbeConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/dnsProbeConfigsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["dnsprobesconfigfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("dnsprobesconfigfolders.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DNSProbesConfigFolders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateDNSProbeConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateDNSProbeConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DNSProbeConfig) (*GlobalDNSProbeConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DNSProbeConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["dnsprobesconfigfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("dnsprobesconfigfolders.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"dnsProbeConfigsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"DNSProbeConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DNSProbesConfigFolders().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalDNSProbeConfig{
		client:         group.client,
		DNSProbeConfig: result,
	}, nil
}

// UpdateDNSProbeConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateDNSProbeConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.DNSProbeConfig) (*GlobalDNSProbeConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			DNSProbeConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDomain :=
		objToUpdate.Spec.Domain
	patchOpDomain := PatchOp{
		Op:    "replace",
		Path:  "/spec/domain",
		Value: patchValueDomain,
	}
	patch = append(patch, patchOpDomain)

	patchValueCreateTimestamp :=
		objToUpdate.Spec.CreateTimestamp
	patchOpCreateTimestamp := PatchOp{
		Op:    "replace",
		Path:  "/spec/createTimestamp",
		Value: patchValueCreateTimestamp,
	}
	patch = append(patch, patchOpCreateTimestamp)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		DNSProbeConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalDNSProbeConfig{
		client:         group.client,
		DNSProbeConfig: result,
	}, nil
}

// ListDNSProbeConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListDNSProbeConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalDNSProbeConfig, err error) {
	key := "dnsprobeconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalDNSProbeConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.DNSProbeConfig)
			result[k] = &GlobalDNSProbeConfig{
				client:         group.client,
				DNSProbeConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			DNSProbeConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalDNSProbeConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalDNSProbeConfig{
				client:         group.client,
				DNSProbeConfig: &item,
			}
		}
	}
	return
}

type GlobalDNSProbeConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.DNSProbeConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalDNSProbeConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteDNSProbeConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.DNSProbeConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalDNSProbeConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateDNSProbeConfigByName(ctx, obj.DNSProbeConfig)
	if err != nil {
		return err
	}
	obj.DNSProbeConfig = result.DNSProbeConfig
	return nil
}

func (obj *GlobalDNSProbeConfig) GetParent(ctx context.Context) (result *GlobalDNSProbesConfigFolder, err error) {
	hashedName := helper.GetHashedName("dnsprobesconfigfolders.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["dnsprobesconfigfolders.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDNSProbesConfigFolderByName(ctx, hashedName)
}

type dnsprobeconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *dnsprobeconfigGlobalTsmV1Chainer) Subscribe() {
	key := "dnsprobeconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDNSProbeConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *dnsprobeconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "dnsprobeconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *dnsprobeconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "dnsprobeconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetDNSProbeStatusByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetDNSProbeStatusByName(ctx context.Context, hashedName string) (*GlobalDNSProbeStatus, error) {
	key := "dnsprobestatuses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.DNSProbeStatus)
		return &GlobalDNSProbeStatus{
			client:         group.client,
			DNSProbeStatus: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			DNSProbeStatuses().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalDNSProbeStatus{
			client:         group.client,
			DNSProbeStatus: result,
		}, nil
	}
}

// DeleteDNSProbeStatusByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteDNSProbeStatusByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DNSProbeStatuses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		DNSProbeStatuses().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/dnsProbeStatusGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["clusters.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusters.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Clusters().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateDNSProbeStatusByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateDNSProbeStatusByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DNSProbeStatus) (*GlobalDNSProbeStatus, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DNSProbeStatuses().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["clusters.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusters.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"dnsProbeStatusGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"DNSProbeStatus\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Clusters().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalDNSProbeStatus{
		client:         group.client,
		DNSProbeStatus: result,
	}, nil
}

// UpdateDNSProbeStatusByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateDNSProbeStatusByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.DNSProbeStatus) (*GlobalDNSProbeStatus, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			DNSProbeStatuses().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueDomain :=
		objToUpdate.Spec.Domain
	patchOpDomain := PatchOp{
		Op:    "replace",
		Path:  "/spec/domain",
		Value: patchValueDomain,
	}
	patch = append(patch, patchOpDomain)

	patchValueSuccess :=
		objToUpdate.Spec.Success
	patchOpSuccess := PatchOp{
		Op:    "replace",
		Path:  "/spec/success",
		Value: patchValueSuccess,
	}
	patch = append(patch, patchOpSuccess)

	patchValueUpdateTimestamp :=
		objToUpdate.Spec.UpdateTimestamp
	patchOpUpdateTimestamp := PatchOp{
		Op:    "replace",
		Path:  "/spec/updateTimestamp",
		Value: patchValueUpdateTimestamp,
	}
	patch = append(patch, patchOpUpdateTimestamp)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		DNSProbeStatuses().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalDNSProbeStatus{
		client:         group.client,
		DNSProbeStatus: result,
	}, nil
}

// ListDNSProbeStatuses returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListDNSProbeStatuses(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalDNSProbeStatus, err error) {
	key := "dnsprobestatuses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalDNSProbeStatus, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.DNSProbeStatus)
			result[k] = &GlobalDNSProbeStatus{
				client:         group.client,
				DNSProbeStatus: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			DNSProbeStatuses().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalDNSProbeStatus, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalDNSProbeStatus{
				client:         group.client,
				DNSProbeStatus: &item,
			}
		}
	}
	return
}

type GlobalDNSProbeStatus struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.DNSProbeStatus
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalDNSProbeStatus) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteDNSProbeStatusByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.DNSProbeStatus = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalDNSProbeStatus) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateDNSProbeStatusByName(ctx, obj.DNSProbeStatus)
	if err != nil {
		return err
	}
	obj.DNSProbeStatus = result.DNSProbeStatus
	return nil
}

func (obj *GlobalDNSProbeStatus) GetParent(ctx context.Context) (result *GlobalCluster, err error) {
	hashedName := helper.GetHashedName("clusters.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["clusters.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetClusterByName(ctx, hashedName)
}

type dnsprobestatusGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *dnsprobestatusGlobalTsmV1Chainer) Subscribe() {
	key := "dnsprobestatuses.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDNSProbeStatusInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *dnsprobestatusGlobalTsmV1Chainer) Unsubscribe() {
	key := "dnsprobestatuses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *dnsprobestatusGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "dnsprobestatuses.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetDNSProbesConfigFolderByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetDNSProbesConfigFolderByName(ctx context.Context, hashedName string) (*GlobalDNSProbesConfigFolder, error) {
	key := "dnsprobesconfigfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.DNSProbesConfigFolder)
		return &GlobalDNSProbesConfigFolder{
			client:                group.client,
			DNSProbesConfigFolder: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			DNSProbesConfigFolders().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalDNSProbesConfigFolder{
			client:                group.client,
			DNSProbesConfigFolder: result,
		}, nil
	}
}

// DeleteDNSProbesConfigFolderByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteDNSProbesConfigFolderByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DNSProbesConfigFolders().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.DnsProbeConfigsGvk {
		err := group.client.
			Global().DeleteDNSProbeConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		DNSProbesConfigFolders().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/dnsProbesConfigFolderGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["clusterconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateDNSProbesConfigFolderByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateDNSProbesConfigFolderByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DNSProbesConfigFolder) (*GlobalDNSProbesConfigFolder, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.DnsProbeConfigsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DNSProbesConfigFolders().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["clusterconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/dnsProbesConfigFolderGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "DNSProbesConfigFolder",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalDNSProbesConfigFolder{
		client:                group.client,
		DNSProbesConfigFolder: result,
	}, nil
}

// UpdateDNSProbesConfigFolderByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateDNSProbesConfigFolderByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.DNSProbesConfigFolder) (*GlobalDNSProbesConfigFolder, error) {
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			DNSProbesConfigFolders().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		DNSProbesConfigFolders().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalDNSProbesConfigFolder{
		client:                group.client,
		DNSProbesConfigFolder: result,
	}, nil
}

// ListDNSProbesConfigFolders returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListDNSProbesConfigFolders(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalDNSProbesConfigFolder, err error) {
	key := "dnsprobesconfigfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalDNSProbesConfigFolder, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.DNSProbesConfigFolder)
			result[k] = &GlobalDNSProbesConfigFolder{
				client:                group.client,
				DNSProbesConfigFolder: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			DNSProbesConfigFolders().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalDNSProbesConfigFolder, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalDNSProbesConfigFolder{
				client:                group.client,
				DNSProbesConfigFolder: &item,
			}
		}
	}
	return
}

type GlobalDNSProbesConfigFolder struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.DNSProbesConfigFolder
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalDNSProbesConfigFolder) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteDNSProbesConfigFolderByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.DNSProbesConfigFolder = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalDNSProbesConfigFolder) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateDNSProbesConfigFolderByName(ctx, obj.DNSProbesConfigFolder)
	if err != nil {
		return err
	}
	obj.DNSProbesConfigFolder = result.DNSProbesConfigFolder
	return nil
}

func (obj *GlobalDNSProbesConfigFolder) GetParent(ctx context.Context) (result *GlobalClusterConfig, err error) {
	hashedName := helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["clusterconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetClusterConfigByName(ctx, hashedName)
}

// GetAllDnsProbeConfigs returns all children of given type
func (obj *GlobalDNSProbesConfigFolder) GetAllDnsProbeConfigs(ctx context.Context) (
	result []*GlobalDNSProbeConfig, err error) {
	result = make([]*GlobalDNSProbeConfig, 0, len(obj.Spec.DnsProbeConfigsGvk))
	for _, v := range obj.Spec.DnsProbeConfigsGvk {
		l, err := obj.client.Global().GetDNSProbeConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetDnsProbeConfigs returns child which has given displayName
func (obj *GlobalDNSProbesConfigFolder) GetDnsProbeConfigs(ctx context.Context,
	displayName string) (result *GlobalDNSProbeConfig, err error) {
	l, ok := obj.Spec.DnsProbeConfigsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DNSProbesConfigFolder", "DnsProbeConfigs", displayName)
	}
	result, err = obj.client.Global().GetDNSProbeConfigByName(ctx, l.Name)
	return
}

// AddDnsProbeConfigs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDNSProbesConfigFolder) AddDnsProbeConfigs(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DNSProbeConfig) (result *GlobalDNSProbeConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["dnsprobesconfigfolders.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["dnsprobesconfigfolders.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateDNSProbeConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDNSProbesConfigFolderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DNSProbesConfigFolder = updatedObj.DNSProbesConfigFolder
	}
	return
}

// DeleteDnsProbeConfigs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDNSProbesConfigFolder) DeleteDnsProbeConfigs(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.DnsProbeConfigsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DNSProbesConfigFolder", "DnsProbeConfigs", displayName)
	}
	err = obj.client.Global().DeleteDNSProbeConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDNSProbesConfigFolderByName(ctx, obj.GetName())
	if err == nil {
		obj.DNSProbesConfigFolder = updatedObj.DNSProbesConfigFolder
	}
	return
}

type dnsprobesconfigfolderGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *dnsprobesconfigfolderGlobalTsmV1Chainer) Subscribe() {
	key := "dnsprobesconfigfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDNSProbesConfigFolderInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *dnsprobesconfigfolderGlobalTsmV1Chainer) Unsubscribe() {
	key := "dnsprobesconfigfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *dnsprobesconfigfolderGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "dnsprobesconfigfolders.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *dnsprobesconfigfolderGlobalTsmV1Chainer) DnsProbeConfigs(name string) *dnsprobeconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["dnsprobeconfigs.global.tsm.tanzu.vmware.com"] = name
	return &dnsprobeconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetDnsProbeConfigs calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *dnsprobesconfigfolderGlobalTsmV1Chainer) GetDnsProbeConfigs(ctx context.Context, displayName string) (result *GlobalDNSProbeConfig, err error) {
	hashedName := helper.GetHashedName("dnsprobeconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetDNSProbeConfigByName(ctx, hashedName)
}

// AddDnsProbeConfigs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *dnsprobesconfigfolderGlobalTsmV1Chainer) AddDnsProbeConfigs(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DNSProbeConfig) (result *GlobalDNSProbeConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("dnsprobeconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateDNSProbeConfigByName(ctx, objToCreate)
}

// DeleteDnsProbeConfigs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *dnsprobesconfigfolderGlobalTsmV1Chainer) DeleteDnsProbeConfigs(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("dnsprobeconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteDNSProbeConfigByName(ctx, hashedName)
}

// GetDomainConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetDomainConfigByName(ctx context.Context, hashedName string) (*GlobalDomainConfig, error) {
	key := "domainconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.DomainConfig)
		return &GlobalDomainConfig{
			client:       group.client,
			DomainConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			DomainConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalDomainConfig{
			client:       group.client,
			DomainConfig: result,
		}, nil
	}
}

// DeleteDomainConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteDomainConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.PolicyGvk {
		err := group.client.
			Global().DeletePolicyConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.LabelConfigGvk != nil {
		err := group.client.
			Global().
			DeleteLabelConfigByName(ctx, result.Spec.LabelConfigGvk.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.NetworkAttachmentDefinitionGvk {
		err := group.client.
			Global().DeleteNetworkAttachmentDefinitionConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ServicesGvk {
		err := group.client.
			Global().DeleteServiceConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ServiceEntriesGvk {
		err := group.client.
			Global().DeleteServiceEntryConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.GatewayConfigGvk {
		err := group.client.
			Global().DeleteGatewayConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.AutoscalersGvk {
		err := group.client.
			Global().DeleteAutoscalerConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.HostConfigV2Gvk {
		err := group.client.
			Global().DeleteHostConfigV2ByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.InboundAuthenticationConfigGvk {
		err := group.client.
			Global().DeleteInboundAuthenticationConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.SlosGvk {
		err := group.client.
			Global().DeleteSloConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.SecretsGvk {
		err := group.client.
			Global().DeleteSecretRTConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ExternalServicesGvk {
		err := group.client.
			Global().DeleteExternalServicesRTByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ApiDiscoveryGvk {
		err := group.client.
			Global().DeleteApiDiscoveryRTByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.GeoDiscoveryGvk {
		err := group.client.
			Global().DeleteGeoDiscoveryRTByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.PiiDiscoveryGvk {
		err := group.client.
			Global().DeletePiiDiscoveryRTByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.AttackDiscoveryGvk {
		err := group.client.
			Global().DeleteAttackDiscoveryRTByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.UserDiscoveryGvk {
		err := group.client.
			Global().DeleteUserDiscoveryRTByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.PublicServiceGvk {
		err := group.client.
			Global().DeletePublicServiceRTByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.GnsAccessControlPolicyGvk {
		err := group.client.
			Global().DeleteGnsAccessControlPolicyRTByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.GnsSchemaViolationDiscoveryGvk {
		err := group.client.
			Global().DeleteSchemaViolationDiscoveryRTByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.GnsSegmentationPolicyGvk {
		err := group.client.
			Global().DeleteGnsSegmentationPolicyRTByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.CertificateAuthorityGvk {
		err := group.client.
			Global().DeleteCertificateAuthorityRTByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.GnsEndpointsConfigGvk {
		err := group.client.
			Global().DeleteGnsEndpointsConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/domainsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["clusterconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateDomainConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateDomainConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DomainConfig) (*GlobalDomainConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.PolicyGvk = nil
	objToCreate.Spec.LabelConfigGvk = nil
	objToCreate.Spec.NetworkAttachmentDefinitionGvk = nil
	objToCreate.Spec.ServicesGvk = nil
	objToCreate.Spec.ServiceEntriesGvk = nil
	objToCreate.Spec.GatewayConfigGvk = nil
	objToCreate.Spec.AutoscalersGvk = nil
	objToCreate.Spec.HostConfigV2Gvk = nil
	objToCreate.Spec.InboundAuthenticationConfigGvk = nil
	objToCreate.Spec.SlosGvk = nil
	objToCreate.Spec.SecretsGvk = nil
	objToCreate.Spec.ExternalServicesGvk = nil
	objToCreate.Spec.ApiDiscoveryGvk = nil
	objToCreate.Spec.GeoDiscoveryGvk = nil
	objToCreate.Spec.PiiDiscoveryGvk = nil
	objToCreate.Spec.AttackDiscoveryGvk = nil
	objToCreate.Spec.UserDiscoveryGvk = nil
	objToCreate.Spec.PublicServiceGvk = nil
	objToCreate.Spec.GnsAccessControlPolicyGvk = nil
	objToCreate.Spec.GnsSchemaViolationDiscoveryGvk = nil
	objToCreate.Spec.GnsSegmentationPolicyGvk = nil
	objToCreate.Spec.CertificateAuthorityGvk = nil
	objToCreate.Spec.GnsEndpointsConfigGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["clusterconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"domainsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"DomainConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalDomainConfig{
		client:       group.client,
		DomainConfig: result,
	}, nil
}

// UpdateDomainConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateDomainConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.DomainConfig) (*GlobalDomainConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			DomainConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueOwnedBy :=
		objToUpdate.Spec.OwnedBy
	patchOpOwnedBy := PatchOp{
		Op:    "replace",
		Path:  "/spec/ownedBy",
		Value: patchValueOwnedBy,
	}
	patch = append(patch, patchOpOwnedBy)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalDomainConfig{
		client:       group.client,
		DomainConfig: result,
	}, nil
}

// ListDomainConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListDomainConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalDomainConfig, err error) {
	key := "domainconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalDomainConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.DomainConfig)
			result[k] = &GlobalDomainConfig{
				client:       group.client,
				DomainConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			DomainConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalDomainConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalDomainConfig{
				client:       group.client,
				DomainConfig: &item,
			}
		}
	}
	return
}

type GlobalDomainConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.DomainConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalDomainConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteDomainConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.DomainConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalDomainConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateDomainConfigByName(ctx, obj.DomainConfig)
	if err != nil {
		return err
	}
	obj.DomainConfig = result.DomainConfig
	return nil
}

func (obj *GlobalDomainConfig) GetParent(ctx context.Context) (result *GlobalClusterConfig, err error) {
	hashedName := helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["clusterconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetClusterConfigByName(ctx, hashedName)
}

// GetAllPolicy returns all children of given type
func (obj *GlobalDomainConfig) GetAllPolicy(ctx context.Context) (
	result []*GlobalPolicyConfig, err error) {
	result = make([]*GlobalPolicyConfig, 0, len(obj.Spec.PolicyGvk))
	for _, v := range obj.Spec.PolicyGvk {
		l, err := obj.client.Global().GetPolicyConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetPolicy returns child which has given displayName
func (obj *GlobalDomainConfig) GetPolicy(ctx context.Context,
	displayName string) (result *GlobalPolicyConfig, err error) {
	l, ok := obj.Spec.PolicyGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "Policy", displayName)
	}
	result, err = obj.client.Global().GetPolicyConfigByName(ctx, l.Name)
	return
}

// AddPolicy calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddPolicy(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PolicyConfig) (result *GlobalPolicyConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreatePolicyConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeletePolicy calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeletePolicy(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.PolicyGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "Policy", displayName)
	}
	err = obj.client.Global().DeletePolicyConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// GetLabelConfig returns child of given type
func (obj *GlobalDomainConfig) GetLabelConfig(ctx context.Context) (
	result *GlobalLabelConfig, err error) {
	if obj.Spec.LabelConfigGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "LabelConfig")
	}
	return obj.client.Global().GetLabelConfigByName(ctx, obj.Spec.LabelConfigGvk.Name)
}

// AddLabelConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddLabelConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.LabelConfig) (result *GlobalLabelConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateLabelConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeleteLabelConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeleteLabelConfig(ctx context.Context) (err error) {
	if obj.Spec.LabelConfigGvk != nil {
		err = obj.client.
			Global().DeleteLabelConfigByName(ctx, obj.Spec.LabelConfigGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// GetAllNetworkAttachmentDefinition returns all children of given type
func (obj *GlobalDomainConfig) GetAllNetworkAttachmentDefinition(ctx context.Context) (
	result []*GlobalNetworkAttachmentDefinitionConfig, err error) {
	result = make([]*GlobalNetworkAttachmentDefinitionConfig, 0, len(obj.Spec.NetworkAttachmentDefinitionGvk))
	for _, v := range obj.Spec.NetworkAttachmentDefinitionGvk {
		l, err := obj.client.Global().GetNetworkAttachmentDefinitionConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetNetworkAttachmentDefinition returns child which has given displayName
func (obj *GlobalDomainConfig) GetNetworkAttachmentDefinition(ctx context.Context,
	displayName string) (result *GlobalNetworkAttachmentDefinitionConfig, err error) {
	l, ok := obj.Spec.NetworkAttachmentDefinitionGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "NetworkAttachmentDefinition", displayName)
	}
	result, err = obj.client.Global().GetNetworkAttachmentDefinitionConfigByName(ctx, l.Name)
	return
}

// AddNetworkAttachmentDefinition calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddNetworkAttachmentDefinition(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NetworkAttachmentDefinitionConfig) (result *GlobalNetworkAttachmentDefinitionConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateNetworkAttachmentDefinitionConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeleteNetworkAttachmentDefinition calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeleteNetworkAttachmentDefinition(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.NetworkAttachmentDefinitionGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "NetworkAttachmentDefinition", displayName)
	}
	err = obj.client.Global().DeleteNetworkAttachmentDefinitionConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// GetAllServices returns all children of given type
func (obj *GlobalDomainConfig) GetAllServices(ctx context.Context) (
	result []*GlobalServiceConfig, err error) {
	result = make([]*GlobalServiceConfig, 0, len(obj.Spec.ServicesGvk))
	for _, v := range obj.Spec.ServicesGvk {
		l, err := obj.client.Global().GetServiceConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServices returns child which has given displayName
func (obj *GlobalDomainConfig) GetServices(ctx context.Context,
	displayName string) (result *GlobalServiceConfig, err error) {
	l, ok := obj.Spec.ServicesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "Services", displayName)
	}
	result, err = obj.client.Global().GetServiceConfigByName(ctx, l.Name)
	return
}

// AddServices calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddServices(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceConfig) (result *GlobalServiceConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeleteServices calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeleteServices(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ServicesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "Services", displayName)
	}
	err = obj.client.Global().DeleteServiceConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// GetAllServiceEntries returns all children of given type
func (obj *GlobalDomainConfig) GetAllServiceEntries(ctx context.Context) (
	result []*GlobalServiceEntryConfig, err error) {
	result = make([]*GlobalServiceEntryConfig, 0, len(obj.Spec.ServiceEntriesGvk))
	for _, v := range obj.Spec.ServiceEntriesGvk {
		l, err := obj.client.Global().GetServiceEntryConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceEntries returns child which has given displayName
func (obj *GlobalDomainConfig) GetServiceEntries(ctx context.Context,
	displayName string) (result *GlobalServiceEntryConfig, err error) {
	l, ok := obj.Spec.ServiceEntriesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "ServiceEntries", displayName)
	}
	result, err = obj.client.Global().GetServiceEntryConfigByName(ctx, l.Name)
	return
}

// AddServiceEntries calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddServiceEntries(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceEntryConfig) (result *GlobalServiceEntryConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceEntryConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeleteServiceEntries calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeleteServiceEntries(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ServiceEntriesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "ServiceEntries", displayName)
	}
	err = obj.client.Global().DeleteServiceEntryConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// GetAllGatewayConfig returns all children of given type
func (obj *GlobalDomainConfig) GetAllGatewayConfig(ctx context.Context) (
	result []*GlobalGatewayConfig, err error) {
	result = make([]*GlobalGatewayConfig, 0, len(obj.Spec.GatewayConfigGvk))
	for _, v := range obj.Spec.GatewayConfigGvk {
		l, err := obj.client.Global().GetGatewayConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGatewayConfig returns child which has given displayName
func (obj *GlobalDomainConfig) GetGatewayConfig(ctx context.Context,
	displayName string) (result *GlobalGatewayConfig, err error) {
	l, ok := obj.Spec.GatewayConfigGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "GatewayConfig", displayName)
	}
	result, err = obj.client.Global().GetGatewayConfigByName(ctx, l.Name)
	return
}

// AddGatewayConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddGatewayConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GatewayConfig) (result *GlobalGatewayConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGatewayConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeleteGatewayConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeleteGatewayConfig(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.GatewayConfigGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "GatewayConfig", displayName)
	}
	err = obj.client.Global().DeleteGatewayConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// GetAllAutoscalers returns all children of given type
func (obj *GlobalDomainConfig) GetAllAutoscalers(ctx context.Context) (
	result []*GlobalAutoscalerConfig, err error) {
	result = make([]*GlobalAutoscalerConfig, 0, len(obj.Spec.AutoscalersGvk))
	for _, v := range obj.Spec.AutoscalersGvk {
		l, err := obj.client.Global().GetAutoscalerConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetAutoscalers returns child which has given displayName
func (obj *GlobalDomainConfig) GetAutoscalers(ctx context.Context,
	displayName string) (result *GlobalAutoscalerConfig, err error) {
	l, ok := obj.Spec.AutoscalersGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "Autoscalers", displayName)
	}
	result, err = obj.client.Global().GetAutoscalerConfigByName(ctx, l.Name)
	return
}

// AddAutoscalers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddAutoscalers(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AutoscalerConfig) (result *GlobalAutoscalerConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateAutoscalerConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeleteAutoscalers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeleteAutoscalers(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.AutoscalersGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "Autoscalers", displayName)
	}
	err = obj.client.Global().DeleteAutoscalerConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// GetAllHostConfigV2 returns all children of given type
func (obj *GlobalDomainConfig) GetAllHostConfigV2(ctx context.Context) (
	result []*GlobalHostConfigV2, err error) {
	result = make([]*GlobalHostConfigV2, 0, len(obj.Spec.HostConfigV2Gvk))
	for _, v := range obj.Spec.HostConfigV2Gvk {
		l, err := obj.client.Global().GetHostConfigV2ByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetHostConfigV2 returns child which has given displayName
func (obj *GlobalDomainConfig) GetHostConfigV2(ctx context.Context,
	displayName string) (result *GlobalHostConfigV2, err error) {
	l, ok := obj.Spec.HostConfigV2Gvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "HostConfigV2", displayName)
	}
	result, err = obj.client.Global().GetHostConfigV2ByName(ctx, l.Name)
	return
}

// AddHostConfigV2 calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddHostConfigV2(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.HostConfigV2) (result *GlobalHostConfigV2, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateHostConfigV2ByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeleteHostConfigV2 calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeleteHostConfigV2(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.HostConfigV2Gvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "HostConfigV2", displayName)
	}
	err = obj.client.Global().DeleteHostConfigV2ByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// GetAllInboundAuthenticationConfig returns all children of given type
func (obj *GlobalDomainConfig) GetAllInboundAuthenticationConfig(ctx context.Context) (
	result []*GlobalInboundAuthenticationConfig, err error) {
	result = make([]*GlobalInboundAuthenticationConfig, 0, len(obj.Spec.InboundAuthenticationConfigGvk))
	for _, v := range obj.Spec.InboundAuthenticationConfigGvk {
		l, err := obj.client.Global().GetInboundAuthenticationConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetInboundAuthenticationConfig returns child which has given displayName
func (obj *GlobalDomainConfig) GetInboundAuthenticationConfig(ctx context.Context,
	displayName string) (result *GlobalInboundAuthenticationConfig, err error) {
	l, ok := obj.Spec.InboundAuthenticationConfigGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "InboundAuthenticationConfig", displayName)
	}
	result, err = obj.client.Global().GetInboundAuthenticationConfigByName(ctx, l.Name)
	return
}

// AddInboundAuthenticationConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddInboundAuthenticationConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.InboundAuthenticationConfig) (result *GlobalInboundAuthenticationConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateInboundAuthenticationConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeleteInboundAuthenticationConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeleteInboundAuthenticationConfig(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.InboundAuthenticationConfigGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "InboundAuthenticationConfig", displayName)
	}
	err = obj.client.Global().DeleteInboundAuthenticationConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// GetAllSlos returns all children of given type
func (obj *GlobalDomainConfig) GetAllSlos(ctx context.Context) (
	result []*GlobalSloConfig, err error) {
	result = make([]*GlobalSloConfig, 0, len(obj.Spec.SlosGvk))
	for _, v := range obj.Spec.SlosGvk {
		l, err := obj.client.Global().GetSloConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetSlos returns child which has given displayName
func (obj *GlobalDomainConfig) GetSlos(ctx context.Context,
	displayName string) (result *GlobalSloConfig, err error) {
	l, ok := obj.Spec.SlosGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "Slos", displayName)
	}
	result, err = obj.client.Global().GetSloConfigByName(ctx, l.Name)
	return
}

// AddSlos calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddSlos(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SloConfig) (result *GlobalSloConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateSloConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeleteSlos calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeleteSlos(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.SlosGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "Slos", displayName)
	}
	err = obj.client.Global().DeleteSloConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// GetAllSecrets returns all children of given type
func (obj *GlobalDomainConfig) GetAllSecrets(ctx context.Context) (
	result []*GlobalSecretRTConfig, err error) {
	result = make([]*GlobalSecretRTConfig, 0, len(obj.Spec.SecretsGvk))
	for _, v := range obj.Spec.SecretsGvk {
		l, err := obj.client.Global().GetSecretRTConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetSecrets returns child which has given displayName
func (obj *GlobalDomainConfig) GetSecrets(ctx context.Context,
	displayName string) (result *GlobalSecretRTConfig, err error) {
	l, ok := obj.Spec.SecretsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "Secrets", displayName)
	}
	result, err = obj.client.Global().GetSecretRTConfigByName(ctx, l.Name)
	return
}

// AddSecrets calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddSecrets(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SecretRTConfig) (result *GlobalSecretRTConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateSecretRTConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeleteSecrets calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeleteSecrets(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.SecretsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "Secrets", displayName)
	}
	err = obj.client.Global().DeleteSecretRTConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// GetAllExternalServices returns all children of given type
func (obj *GlobalDomainConfig) GetAllExternalServices(ctx context.Context) (
	result []*GlobalExternalServicesRT, err error) {
	result = make([]*GlobalExternalServicesRT, 0, len(obj.Spec.ExternalServicesGvk))
	for _, v := range obj.Spec.ExternalServicesGvk {
		l, err := obj.client.Global().GetExternalServicesRTByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetExternalServices returns child which has given displayName
func (obj *GlobalDomainConfig) GetExternalServices(ctx context.Context,
	displayName string) (result *GlobalExternalServicesRT, err error) {
	l, ok := obj.Spec.ExternalServicesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "ExternalServices", displayName)
	}
	result, err = obj.client.Global().GetExternalServicesRTByName(ctx, l.Name)
	return
}

// AddExternalServices calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddExternalServices(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalServicesRT) (result *GlobalExternalServicesRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateExternalServicesRTByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeleteExternalServices calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeleteExternalServices(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ExternalServicesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "ExternalServices", displayName)
	}
	err = obj.client.Global().DeleteExternalServicesRTByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// GetAllApiDiscovery returns all children of given type
func (obj *GlobalDomainConfig) GetAllApiDiscovery(ctx context.Context) (
	result []*GlobalApiDiscoveryRT, err error) {
	result = make([]*GlobalApiDiscoveryRT, 0, len(obj.Spec.ApiDiscoveryGvk))
	for _, v := range obj.Spec.ApiDiscoveryGvk {
		l, err := obj.client.Global().GetApiDiscoveryRTByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetApiDiscovery returns child which has given displayName
func (obj *GlobalDomainConfig) GetApiDiscovery(ctx context.Context,
	displayName string) (result *GlobalApiDiscoveryRT, err error) {
	l, ok := obj.Spec.ApiDiscoveryGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "ApiDiscovery", displayName)
	}
	result, err = obj.client.Global().GetApiDiscoveryRTByName(ctx, l.Name)
	return
}

// AddApiDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddApiDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ApiDiscoveryRT) (result *GlobalApiDiscoveryRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateApiDiscoveryRTByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeleteApiDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeleteApiDiscovery(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ApiDiscoveryGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "ApiDiscovery", displayName)
	}
	err = obj.client.Global().DeleteApiDiscoveryRTByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// GetAllGeoDiscovery returns all children of given type
func (obj *GlobalDomainConfig) GetAllGeoDiscovery(ctx context.Context) (
	result []*GlobalGeoDiscoveryRT, err error) {
	result = make([]*GlobalGeoDiscoveryRT, 0, len(obj.Spec.GeoDiscoveryGvk))
	for _, v := range obj.Spec.GeoDiscoveryGvk {
		l, err := obj.client.Global().GetGeoDiscoveryRTByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGeoDiscovery returns child which has given displayName
func (obj *GlobalDomainConfig) GetGeoDiscovery(ctx context.Context,
	displayName string) (result *GlobalGeoDiscoveryRT, err error) {
	l, ok := obj.Spec.GeoDiscoveryGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "GeoDiscovery", displayName)
	}
	result, err = obj.client.Global().GetGeoDiscoveryRTByName(ctx, l.Name)
	return
}

// AddGeoDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddGeoDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GeoDiscoveryRT) (result *GlobalGeoDiscoveryRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGeoDiscoveryRTByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeleteGeoDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeleteGeoDiscovery(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.GeoDiscoveryGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "GeoDiscovery", displayName)
	}
	err = obj.client.Global().DeleteGeoDiscoveryRTByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// GetAllPiiDiscovery returns all children of given type
func (obj *GlobalDomainConfig) GetAllPiiDiscovery(ctx context.Context) (
	result []*GlobalPiiDiscoveryRT, err error) {
	result = make([]*GlobalPiiDiscoveryRT, 0, len(obj.Spec.PiiDiscoveryGvk))
	for _, v := range obj.Spec.PiiDiscoveryGvk {
		l, err := obj.client.Global().GetPiiDiscoveryRTByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetPiiDiscovery returns child which has given displayName
func (obj *GlobalDomainConfig) GetPiiDiscovery(ctx context.Context,
	displayName string) (result *GlobalPiiDiscoveryRT, err error) {
	l, ok := obj.Spec.PiiDiscoveryGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "PiiDiscovery", displayName)
	}
	result, err = obj.client.Global().GetPiiDiscoveryRTByName(ctx, l.Name)
	return
}

// AddPiiDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddPiiDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PiiDiscoveryRT) (result *GlobalPiiDiscoveryRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreatePiiDiscoveryRTByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeletePiiDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeletePiiDiscovery(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.PiiDiscoveryGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "PiiDiscovery", displayName)
	}
	err = obj.client.Global().DeletePiiDiscoveryRTByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// GetAllAttackDiscovery returns all children of given type
func (obj *GlobalDomainConfig) GetAllAttackDiscovery(ctx context.Context) (
	result []*GlobalAttackDiscoveryRT, err error) {
	result = make([]*GlobalAttackDiscoveryRT, 0, len(obj.Spec.AttackDiscoveryGvk))
	for _, v := range obj.Spec.AttackDiscoveryGvk {
		l, err := obj.client.Global().GetAttackDiscoveryRTByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetAttackDiscovery returns child which has given displayName
func (obj *GlobalDomainConfig) GetAttackDiscovery(ctx context.Context,
	displayName string) (result *GlobalAttackDiscoveryRT, err error) {
	l, ok := obj.Spec.AttackDiscoveryGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "AttackDiscovery", displayName)
	}
	result, err = obj.client.Global().GetAttackDiscoveryRTByName(ctx, l.Name)
	return
}

// AddAttackDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddAttackDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AttackDiscoveryRT) (result *GlobalAttackDiscoveryRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateAttackDiscoveryRTByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeleteAttackDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeleteAttackDiscovery(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.AttackDiscoveryGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "AttackDiscovery", displayName)
	}
	err = obj.client.Global().DeleteAttackDiscoveryRTByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// GetAllUserDiscovery returns all children of given type
func (obj *GlobalDomainConfig) GetAllUserDiscovery(ctx context.Context) (
	result []*GlobalUserDiscoveryRT, err error) {
	result = make([]*GlobalUserDiscoveryRT, 0, len(obj.Spec.UserDiscoveryGvk))
	for _, v := range obj.Spec.UserDiscoveryGvk {
		l, err := obj.client.Global().GetUserDiscoveryRTByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetUserDiscovery returns child which has given displayName
func (obj *GlobalDomainConfig) GetUserDiscovery(ctx context.Context,
	displayName string) (result *GlobalUserDiscoveryRT, err error) {
	l, ok := obj.Spec.UserDiscoveryGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "UserDiscovery", displayName)
	}
	result, err = obj.client.Global().GetUserDiscoveryRTByName(ctx, l.Name)
	return
}

// AddUserDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddUserDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.UserDiscoveryRT) (result *GlobalUserDiscoveryRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateUserDiscoveryRTByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeleteUserDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeleteUserDiscovery(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.UserDiscoveryGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "UserDiscovery", displayName)
	}
	err = obj.client.Global().DeleteUserDiscoveryRTByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// GetAllPublicService returns all children of given type
func (obj *GlobalDomainConfig) GetAllPublicService(ctx context.Context) (
	result []*GlobalPublicServiceRT, err error) {
	result = make([]*GlobalPublicServiceRT, 0, len(obj.Spec.PublicServiceGvk))
	for _, v := range obj.Spec.PublicServiceGvk {
		l, err := obj.client.Global().GetPublicServiceRTByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetPublicService returns child which has given displayName
func (obj *GlobalDomainConfig) GetPublicService(ctx context.Context,
	displayName string) (result *GlobalPublicServiceRT, err error) {
	l, ok := obj.Spec.PublicServiceGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "PublicService", displayName)
	}
	result, err = obj.client.Global().GetPublicServiceRTByName(ctx, l.Name)
	return
}

// AddPublicService calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddPublicService(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PublicServiceRT) (result *GlobalPublicServiceRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreatePublicServiceRTByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeletePublicService calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeletePublicService(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.PublicServiceGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "PublicService", displayName)
	}
	err = obj.client.Global().DeletePublicServiceRTByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// GetAllGnsAccessControlPolicy returns all children of given type
func (obj *GlobalDomainConfig) GetAllGnsAccessControlPolicy(ctx context.Context) (
	result []*GlobalGnsAccessControlPolicyRT, err error) {
	result = make([]*GlobalGnsAccessControlPolicyRT, 0, len(obj.Spec.GnsAccessControlPolicyGvk))
	for _, v := range obj.Spec.GnsAccessControlPolicyGvk {
		l, err := obj.client.Global().GetGnsAccessControlPolicyRTByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGnsAccessControlPolicy returns child which has given displayName
func (obj *GlobalDomainConfig) GetGnsAccessControlPolicy(ctx context.Context,
	displayName string) (result *GlobalGnsAccessControlPolicyRT, err error) {
	l, ok := obj.Spec.GnsAccessControlPolicyGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "GnsAccessControlPolicy", displayName)
	}
	result, err = obj.client.Global().GetGnsAccessControlPolicyRTByName(ctx, l.Name)
	return
}

// AddGnsAccessControlPolicy calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddGnsAccessControlPolicy(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsAccessControlPolicyRT) (result *GlobalGnsAccessControlPolicyRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGnsAccessControlPolicyRTByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeleteGnsAccessControlPolicy calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeleteGnsAccessControlPolicy(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.GnsAccessControlPolicyGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "GnsAccessControlPolicy", displayName)
	}
	err = obj.client.Global().DeleteGnsAccessControlPolicyRTByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// GetAllGnsSchemaViolationDiscovery returns all children of given type
func (obj *GlobalDomainConfig) GetAllGnsSchemaViolationDiscovery(ctx context.Context) (
	result []*GlobalSchemaViolationDiscoveryRT, err error) {
	result = make([]*GlobalSchemaViolationDiscoveryRT, 0, len(obj.Spec.GnsSchemaViolationDiscoveryGvk))
	for _, v := range obj.Spec.GnsSchemaViolationDiscoveryGvk {
		l, err := obj.client.Global().GetSchemaViolationDiscoveryRTByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGnsSchemaViolationDiscovery returns child which has given displayName
func (obj *GlobalDomainConfig) GetGnsSchemaViolationDiscovery(ctx context.Context,
	displayName string) (result *GlobalSchemaViolationDiscoveryRT, err error) {
	l, ok := obj.Spec.GnsSchemaViolationDiscoveryGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "GnsSchemaViolationDiscovery", displayName)
	}
	result, err = obj.client.Global().GetSchemaViolationDiscoveryRTByName(ctx, l.Name)
	return
}

// AddGnsSchemaViolationDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddGnsSchemaViolationDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SchemaViolationDiscoveryRT) (result *GlobalSchemaViolationDiscoveryRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateSchemaViolationDiscoveryRTByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeleteGnsSchemaViolationDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeleteGnsSchemaViolationDiscovery(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.GnsSchemaViolationDiscoveryGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "GnsSchemaViolationDiscovery", displayName)
	}
	err = obj.client.Global().DeleteSchemaViolationDiscoveryRTByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// GetAllGnsSegmentationPolicy returns all children of given type
func (obj *GlobalDomainConfig) GetAllGnsSegmentationPolicy(ctx context.Context) (
	result []*GlobalGnsSegmentationPolicyRT, err error) {
	result = make([]*GlobalGnsSegmentationPolicyRT, 0, len(obj.Spec.GnsSegmentationPolicyGvk))
	for _, v := range obj.Spec.GnsSegmentationPolicyGvk {
		l, err := obj.client.Global().GetGnsSegmentationPolicyRTByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGnsSegmentationPolicy returns child which has given displayName
func (obj *GlobalDomainConfig) GetGnsSegmentationPolicy(ctx context.Context,
	displayName string) (result *GlobalGnsSegmentationPolicyRT, err error) {
	l, ok := obj.Spec.GnsSegmentationPolicyGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "GnsSegmentationPolicy", displayName)
	}
	result, err = obj.client.Global().GetGnsSegmentationPolicyRTByName(ctx, l.Name)
	return
}

// AddGnsSegmentationPolicy calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddGnsSegmentationPolicy(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsSegmentationPolicyRT) (result *GlobalGnsSegmentationPolicyRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGnsSegmentationPolicyRTByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeleteGnsSegmentationPolicy calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeleteGnsSegmentationPolicy(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.GnsSegmentationPolicyGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "GnsSegmentationPolicy", displayName)
	}
	err = obj.client.Global().DeleteGnsSegmentationPolicyRTByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// GetAllCertificateAuthority returns all children of given type
func (obj *GlobalDomainConfig) GetAllCertificateAuthority(ctx context.Context) (
	result []*GlobalCertificateAuthorityRT, err error) {
	result = make([]*GlobalCertificateAuthorityRT, 0, len(obj.Spec.CertificateAuthorityGvk))
	for _, v := range obj.Spec.CertificateAuthorityGvk {
		l, err := obj.client.Global().GetCertificateAuthorityRTByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetCertificateAuthority returns child which has given displayName
func (obj *GlobalDomainConfig) GetCertificateAuthority(ctx context.Context,
	displayName string) (result *GlobalCertificateAuthorityRT, err error) {
	l, ok := obj.Spec.CertificateAuthorityGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "CertificateAuthority", displayName)
	}
	result, err = obj.client.Global().GetCertificateAuthorityRTByName(ctx, l.Name)
	return
}

// AddCertificateAuthority calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddCertificateAuthority(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.CertificateAuthorityRT) (result *GlobalCertificateAuthorityRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateCertificateAuthorityRTByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeleteCertificateAuthority calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeleteCertificateAuthority(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.CertificateAuthorityGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "CertificateAuthority", displayName)
	}
	err = obj.client.Global().DeleteCertificateAuthorityRTByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// GetAllGnsEndpointsConfig returns all children of given type
func (obj *GlobalDomainConfig) GetAllGnsEndpointsConfig(ctx context.Context) (
	result []*GlobalGnsEndpointsConfig, err error) {
	result = make([]*GlobalGnsEndpointsConfig, 0, len(obj.Spec.GnsEndpointsConfigGvk))
	for _, v := range obj.Spec.GnsEndpointsConfigGvk {
		l, err := obj.client.Global().GetGnsEndpointsConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGnsEndpointsConfig returns child which has given displayName
func (obj *GlobalDomainConfig) GetGnsEndpointsConfig(ctx context.Context,
	displayName string) (result *GlobalGnsEndpointsConfig, err error) {
	l, ok := obj.Spec.GnsEndpointsConfigGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "GnsEndpointsConfig", displayName)
	}
	result, err = obj.client.Global().GetGnsEndpointsConfigByName(ctx, l.Name)
	return
}

// AddGnsEndpointsConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomainConfig) AddGnsEndpointsConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsEndpointsConfig) (result *GlobalGnsEndpointsConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domainconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domainconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGnsEndpointsConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

// DeleteGnsEndpointsConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomainConfig) DeleteGnsEndpointsConfig(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.GnsEndpointsConfigGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.DomainConfig", "GnsEndpointsConfig", displayName)
	}
	err = obj.client.Global().DeleteGnsEndpointsConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.DomainConfig = updatedObj.DomainConfig
	}
	return
}

type domainconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *domainconfigGlobalTsmV1Chainer) Subscribe() {
	key := "domainconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDomainConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *domainconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "domainconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *domainconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "domainconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *domainconfigGlobalTsmV1Chainer) Policy(name string) *policyconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["policyconfigs.global.tsm.tanzu.vmware.com"] = name
	return &policyconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetPolicy calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetPolicy(ctx context.Context, displayName string) (result *GlobalPolicyConfig, err error) {
	hashedName := helper.GetHashedName("policyconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetPolicyConfigByName(ctx, hashedName)
}

// AddPolicy calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddPolicy(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PolicyConfig) (result *GlobalPolicyConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("policyconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreatePolicyConfigByName(ctx, objToCreate)
}

// DeletePolicy calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeletePolicy(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("policyconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeletePolicyConfigByName(ctx, hashedName)
}

func (c *domainconfigGlobalTsmV1Chainer) LabelConfig(name string) *labelconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["labelconfigs.global.tsm.tanzu.vmware.com"] = name
	return &labelconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetLabelConfig calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetLabelConfig(ctx context.Context, displayName string) (result *GlobalLabelConfig, err error) {
	hashedName := helper.GetHashedName("labelconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetLabelConfigByName(ctx, hashedName)
}

// AddLabelConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddLabelConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.LabelConfig) (result *GlobalLabelConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("labelconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateLabelConfigByName(ctx, objToCreate)
}

// DeleteLabelConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeleteLabelConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("labelconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteLabelConfigByName(ctx, hashedName)
}

func (c *domainconfigGlobalTsmV1Chainer) NetworkAttachmentDefinition(name string) *networkattachmentdefinitionconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["networkattachmentdefinitionconfigs.global.tsm.tanzu.vmware.com"] = name
	return &networkattachmentdefinitionconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetNetworkAttachmentDefinition calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetNetworkAttachmentDefinition(ctx context.Context, displayName string) (result *GlobalNetworkAttachmentDefinitionConfig, err error) {
	hashedName := helper.GetHashedName("networkattachmentdefinitionconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetNetworkAttachmentDefinitionConfigByName(ctx, hashedName)
}

// AddNetworkAttachmentDefinition calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddNetworkAttachmentDefinition(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NetworkAttachmentDefinitionConfig) (result *GlobalNetworkAttachmentDefinitionConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("networkattachmentdefinitionconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateNetworkAttachmentDefinitionConfigByName(ctx, objToCreate)
}

// DeleteNetworkAttachmentDefinition calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeleteNetworkAttachmentDefinition(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("networkattachmentdefinitionconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteNetworkAttachmentDefinitionConfigByName(ctx, hashedName)
}

func (c *domainconfigGlobalTsmV1Chainer) Services(name string) *serviceconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["serviceconfigs.global.tsm.tanzu.vmware.com"] = name
	return &serviceconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetServices calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetServices(ctx context.Context, displayName string) (result *GlobalServiceConfig, err error) {
	hashedName := helper.GetHashedName("serviceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceConfigByName(ctx, hashedName)
}

// AddServices calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddServices(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceConfig) (result *GlobalServiceConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("serviceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceConfigByName(ctx, objToCreate)
}

// DeleteServices calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeleteServices(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("serviceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceConfigByName(ctx, hashedName)
}

func (c *domainconfigGlobalTsmV1Chainer) ServiceEntries(name string) *serviceentryconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["serviceentryconfigs.global.tsm.tanzu.vmware.com"] = name
	return &serviceentryconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetServiceEntries calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetServiceEntries(ctx context.Context, displayName string) (result *GlobalServiceEntryConfig, err error) {
	hashedName := helper.GetHashedName("serviceentryconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceEntryConfigByName(ctx, hashedName)
}

// AddServiceEntries calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddServiceEntries(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceEntryConfig) (result *GlobalServiceEntryConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("serviceentryconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceEntryConfigByName(ctx, objToCreate)
}

// DeleteServiceEntries calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeleteServiceEntries(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("serviceentryconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceEntryConfigByName(ctx, hashedName)
}

func (c *domainconfigGlobalTsmV1Chainer) GatewayConfig(name string) *gatewayconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gatewayconfigs.global.tsm.tanzu.vmware.com"] = name
	return &gatewayconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGatewayConfig calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetGatewayConfig(ctx context.Context, displayName string) (result *GlobalGatewayConfig, err error) {
	hashedName := helper.GetHashedName("gatewayconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGatewayConfigByName(ctx, hashedName)
}

// AddGatewayConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddGatewayConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GatewayConfig) (result *GlobalGatewayConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gatewayconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGatewayConfigByName(ctx, objToCreate)
}

// DeleteGatewayConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeleteGatewayConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gatewayconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGatewayConfigByName(ctx, hashedName)
}

func (c *domainconfigGlobalTsmV1Chainer) Autoscalers(name string) *autoscalerconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["autoscalerconfigs.global.tsm.tanzu.vmware.com"] = name
	return &autoscalerconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetAutoscalers calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetAutoscalers(ctx context.Context, displayName string) (result *GlobalAutoscalerConfig, err error) {
	hashedName := helper.GetHashedName("autoscalerconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetAutoscalerConfigByName(ctx, hashedName)
}

// AddAutoscalers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddAutoscalers(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AutoscalerConfig) (result *GlobalAutoscalerConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("autoscalerconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateAutoscalerConfigByName(ctx, objToCreate)
}

// DeleteAutoscalers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeleteAutoscalers(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("autoscalerconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteAutoscalerConfigByName(ctx, hashedName)
}

func (c *domainconfigGlobalTsmV1Chainer) HostConfigV2(name string) *hostconfigv2GlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["hostconfigv2s.global.tsm.tanzu.vmware.com"] = name
	return &hostconfigv2GlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetHostConfigV2 calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetHostConfigV2(ctx context.Context, displayName string) (result *GlobalHostConfigV2, err error) {
	hashedName := helper.GetHashedName("hostconfigv2s.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetHostConfigV2ByName(ctx, hashedName)
}

// AddHostConfigV2 calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddHostConfigV2(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.HostConfigV2) (result *GlobalHostConfigV2, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("hostconfigv2s.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateHostConfigV2ByName(ctx, objToCreate)
}

// DeleteHostConfigV2 calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeleteHostConfigV2(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("hostconfigv2s.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteHostConfigV2ByName(ctx, hashedName)
}

func (c *domainconfigGlobalTsmV1Chainer) InboundAuthenticationConfig(name string) *inboundauthenticationconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["inboundauthenticationconfigs.global.tsm.tanzu.vmware.com"] = name
	return &inboundauthenticationconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetInboundAuthenticationConfig calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetInboundAuthenticationConfig(ctx context.Context, displayName string) (result *GlobalInboundAuthenticationConfig, err error) {
	hashedName := helper.GetHashedName("inboundauthenticationconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetInboundAuthenticationConfigByName(ctx, hashedName)
}

// AddInboundAuthenticationConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddInboundAuthenticationConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.InboundAuthenticationConfig) (result *GlobalInboundAuthenticationConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("inboundauthenticationconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateInboundAuthenticationConfigByName(ctx, objToCreate)
}

// DeleteInboundAuthenticationConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeleteInboundAuthenticationConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("inboundauthenticationconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteInboundAuthenticationConfigByName(ctx, hashedName)
}

func (c *domainconfigGlobalTsmV1Chainer) Slos(name string) *sloconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["sloconfigs.global.tsm.tanzu.vmware.com"] = name
	return &sloconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetSlos calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetSlos(ctx context.Context, displayName string) (result *GlobalSloConfig, err error) {
	hashedName := helper.GetHashedName("sloconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetSloConfigByName(ctx, hashedName)
}

// AddSlos calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddSlos(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SloConfig) (result *GlobalSloConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("sloconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateSloConfigByName(ctx, objToCreate)
}

// DeleteSlos calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeleteSlos(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("sloconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteSloConfigByName(ctx, hashedName)
}

func (c *domainconfigGlobalTsmV1Chainer) Secrets(name string) *secretrtconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["secretrtconfigs.global.tsm.tanzu.vmware.com"] = name
	return &secretrtconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetSecrets calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetSecrets(ctx context.Context, displayName string) (result *GlobalSecretRTConfig, err error) {
	hashedName := helper.GetHashedName("secretrtconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetSecretRTConfigByName(ctx, hashedName)
}

// AddSecrets calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddSecrets(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SecretRTConfig) (result *GlobalSecretRTConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("secretrtconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateSecretRTConfigByName(ctx, objToCreate)
}

// DeleteSecrets calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeleteSecrets(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("secretrtconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteSecretRTConfigByName(ctx, hashedName)
}

func (c *domainconfigGlobalTsmV1Chainer) ExternalServices(name string) *externalservicesrtGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["externalservicesrts.global.tsm.tanzu.vmware.com"] = name
	return &externalservicesrtGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetExternalServices calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetExternalServices(ctx context.Context, displayName string) (result *GlobalExternalServicesRT, err error) {
	hashedName := helper.GetHashedName("externalservicesrts.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetExternalServicesRTByName(ctx, hashedName)
}

// AddExternalServices calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddExternalServices(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalServicesRT) (result *GlobalExternalServicesRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("externalservicesrts.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateExternalServicesRTByName(ctx, objToCreate)
}

// DeleteExternalServices calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeleteExternalServices(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("externalservicesrts.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteExternalServicesRTByName(ctx, hashedName)
}

func (c *domainconfigGlobalTsmV1Chainer) ApiDiscovery(name string) *apidiscoveryrtGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["apidiscoveryrts.global.tsm.tanzu.vmware.com"] = name
	return &apidiscoveryrtGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetApiDiscovery calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetApiDiscovery(ctx context.Context, displayName string) (result *GlobalApiDiscoveryRT, err error) {
	hashedName := helper.GetHashedName("apidiscoveryrts.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetApiDiscoveryRTByName(ctx, hashedName)
}

// AddApiDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddApiDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ApiDiscoveryRT) (result *GlobalApiDiscoveryRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("apidiscoveryrts.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateApiDiscoveryRTByName(ctx, objToCreate)
}

// DeleteApiDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeleteApiDiscovery(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("apidiscoveryrts.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteApiDiscoveryRTByName(ctx, hashedName)
}

func (c *domainconfigGlobalTsmV1Chainer) GeoDiscovery(name string) *geodiscoveryrtGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["geodiscoveryrts.global.tsm.tanzu.vmware.com"] = name
	return &geodiscoveryrtGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGeoDiscovery calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetGeoDiscovery(ctx context.Context, displayName string) (result *GlobalGeoDiscoveryRT, err error) {
	hashedName := helper.GetHashedName("geodiscoveryrts.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGeoDiscoveryRTByName(ctx, hashedName)
}

// AddGeoDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddGeoDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GeoDiscoveryRT) (result *GlobalGeoDiscoveryRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("geodiscoveryrts.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGeoDiscoveryRTByName(ctx, objToCreate)
}

// DeleteGeoDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeleteGeoDiscovery(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("geodiscoveryrts.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGeoDiscoveryRTByName(ctx, hashedName)
}

func (c *domainconfigGlobalTsmV1Chainer) PiiDiscovery(name string) *piidiscoveryrtGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["piidiscoveryrts.global.tsm.tanzu.vmware.com"] = name
	return &piidiscoveryrtGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetPiiDiscovery calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetPiiDiscovery(ctx context.Context, displayName string) (result *GlobalPiiDiscoveryRT, err error) {
	hashedName := helper.GetHashedName("piidiscoveryrts.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetPiiDiscoveryRTByName(ctx, hashedName)
}

// AddPiiDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddPiiDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PiiDiscoveryRT) (result *GlobalPiiDiscoveryRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("piidiscoveryrts.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreatePiiDiscoveryRTByName(ctx, objToCreate)
}

// DeletePiiDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeletePiiDiscovery(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("piidiscoveryrts.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeletePiiDiscoveryRTByName(ctx, hashedName)
}

func (c *domainconfigGlobalTsmV1Chainer) AttackDiscovery(name string) *attackdiscoveryrtGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["attackdiscoveryrts.global.tsm.tanzu.vmware.com"] = name
	return &attackdiscoveryrtGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetAttackDiscovery calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetAttackDiscovery(ctx context.Context, displayName string) (result *GlobalAttackDiscoveryRT, err error) {
	hashedName := helper.GetHashedName("attackdiscoveryrts.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetAttackDiscoveryRTByName(ctx, hashedName)
}

// AddAttackDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddAttackDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AttackDiscoveryRT) (result *GlobalAttackDiscoveryRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("attackdiscoveryrts.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateAttackDiscoveryRTByName(ctx, objToCreate)
}

// DeleteAttackDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeleteAttackDiscovery(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("attackdiscoveryrts.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteAttackDiscoveryRTByName(ctx, hashedName)
}

func (c *domainconfigGlobalTsmV1Chainer) UserDiscovery(name string) *userdiscoveryrtGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["userdiscoveryrts.global.tsm.tanzu.vmware.com"] = name
	return &userdiscoveryrtGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetUserDiscovery calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetUserDiscovery(ctx context.Context, displayName string) (result *GlobalUserDiscoveryRT, err error) {
	hashedName := helper.GetHashedName("userdiscoveryrts.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetUserDiscoveryRTByName(ctx, hashedName)
}

// AddUserDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddUserDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.UserDiscoveryRT) (result *GlobalUserDiscoveryRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("userdiscoveryrts.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateUserDiscoveryRTByName(ctx, objToCreate)
}

// DeleteUserDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeleteUserDiscovery(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("userdiscoveryrts.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteUserDiscoveryRTByName(ctx, hashedName)
}

func (c *domainconfigGlobalTsmV1Chainer) PublicService(name string) *publicservicertGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["publicservicerts.global.tsm.tanzu.vmware.com"] = name
	return &publicservicertGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetPublicService calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetPublicService(ctx context.Context, displayName string) (result *GlobalPublicServiceRT, err error) {
	hashedName := helper.GetHashedName("publicservicerts.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetPublicServiceRTByName(ctx, hashedName)
}

// AddPublicService calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddPublicService(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PublicServiceRT) (result *GlobalPublicServiceRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("publicservicerts.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreatePublicServiceRTByName(ctx, objToCreate)
}

// DeletePublicService calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeletePublicService(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("publicservicerts.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeletePublicServiceRTByName(ctx, hashedName)
}

func (c *domainconfigGlobalTsmV1Chainer) GnsAccessControlPolicy(name string) *gnsaccesscontrolpolicyrtGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gnsaccesscontrolpolicyrts.global.tsm.tanzu.vmware.com"] = name
	return &gnsaccesscontrolpolicyrtGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGnsAccessControlPolicy calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetGnsAccessControlPolicy(ctx context.Context, displayName string) (result *GlobalGnsAccessControlPolicyRT, err error) {
	hashedName := helper.GetHashedName("gnsaccesscontrolpolicyrts.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGnsAccessControlPolicyRTByName(ctx, hashedName)
}

// AddGnsAccessControlPolicy calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddGnsAccessControlPolicy(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsAccessControlPolicyRT) (result *GlobalGnsAccessControlPolicyRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gnsaccesscontrolpolicyrts.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGnsAccessControlPolicyRTByName(ctx, objToCreate)
}

// DeleteGnsAccessControlPolicy calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeleteGnsAccessControlPolicy(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gnsaccesscontrolpolicyrts.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGnsAccessControlPolicyRTByName(ctx, hashedName)
}

func (c *domainconfigGlobalTsmV1Chainer) GnsSchemaViolationDiscovery(name string) *schemaviolationdiscoveryrtGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["schemaviolationdiscoveryrts.global.tsm.tanzu.vmware.com"] = name
	return &schemaviolationdiscoveryrtGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGnsSchemaViolationDiscovery calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetGnsSchemaViolationDiscovery(ctx context.Context, displayName string) (result *GlobalSchemaViolationDiscoveryRT, err error) {
	hashedName := helper.GetHashedName("schemaviolationdiscoveryrts.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetSchemaViolationDiscoveryRTByName(ctx, hashedName)
}

// AddGnsSchemaViolationDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddGnsSchemaViolationDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SchemaViolationDiscoveryRT) (result *GlobalSchemaViolationDiscoveryRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("schemaviolationdiscoveryrts.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateSchemaViolationDiscoveryRTByName(ctx, objToCreate)
}

// DeleteGnsSchemaViolationDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeleteGnsSchemaViolationDiscovery(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("schemaviolationdiscoveryrts.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteSchemaViolationDiscoveryRTByName(ctx, hashedName)
}

func (c *domainconfigGlobalTsmV1Chainer) GnsSegmentationPolicy(name string) *gnssegmentationpolicyrtGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gnssegmentationpolicyrts.global.tsm.tanzu.vmware.com"] = name
	return &gnssegmentationpolicyrtGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGnsSegmentationPolicy calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetGnsSegmentationPolicy(ctx context.Context, displayName string) (result *GlobalGnsSegmentationPolicyRT, err error) {
	hashedName := helper.GetHashedName("gnssegmentationpolicyrts.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGnsSegmentationPolicyRTByName(ctx, hashedName)
}

// AddGnsSegmentationPolicy calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddGnsSegmentationPolicy(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsSegmentationPolicyRT) (result *GlobalGnsSegmentationPolicyRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gnssegmentationpolicyrts.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGnsSegmentationPolicyRTByName(ctx, objToCreate)
}

// DeleteGnsSegmentationPolicy calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeleteGnsSegmentationPolicy(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gnssegmentationpolicyrts.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGnsSegmentationPolicyRTByName(ctx, hashedName)
}

func (c *domainconfigGlobalTsmV1Chainer) CertificateAuthority(name string) *certificateauthorityrtGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["certificateauthorityrts.global.tsm.tanzu.vmware.com"] = name
	return &certificateauthorityrtGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetCertificateAuthority calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetCertificateAuthority(ctx context.Context, displayName string) (result *GlobalCertificateAuthorityRT, err error) {
	hashedName := helper.GetHashedName("certificateauthorityrts.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetCertificateAuthorityRTByName(ctx, hashedName)
}

// AddCertificateAuthority calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddCertificateAuthority(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.CertificateAuthorityRT) (result *GlobalCertificateAuthorityRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("certificateauthorityrts.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateCertificateAuthorityRTByName(ctx, objToCreate)
}

// DeleteCertificateAuthority calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeleteCertificateAuthority(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("certificateauthorityrts.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteCertificateAuthorityRTByName(ctx, hashedName)
}

func (c *domainconfigGlobalTsmV1Chainer) GnsEndpointsConfig(name string) *gnsendpointsconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gnsendpointsconfigs.global.tsm.tanzu.vmware.com"] = name
	return &gnsendpointsconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGnsEndpointsConfig calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainconfigGlobalTsmV1Chainer) GetGnsEndpointsConfig(ctx context.Context, displayName string) (result *GlobalGnsEndpointsConfig, err error) {
	hashedName := helper.GetHashedName("gnsendpointsconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGnsEndpointsConfigByName(ctx, hashedName)
}

// AddGnsEndpointsConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainconfigGlobalTsmV1Chainer) AddGnsEndpointsConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsEndpointsConfig) (result *GlobalGnsEndpointsConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gnsendpointsconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGnsEndpointsConfigByName(ctx, objToCreate)
}

// DeleteGnsEndpointsConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainconfigGlobalTsmV1Chainer) DeleteGnsEndpointsConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gnsendpointsconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGnsEndpointsConfigByName(ctx, hashedName)
}

// GetDomainByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetDomainByName(ctx context.Context, hashedName string) (*GlobalDomain, error) {
	key := "domains.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Domain)
		return &GlobalDomain{
			client: group.client,
			Domain: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Domains().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalDomain{
			client: group.client,
			Domain: result,
		}, nil
	}
}

// DeleteDomainByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteDomainByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Domains().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.SecretHashesGvk {
		err := group.client.
			Global().DeleteSecretHashByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ServiceInstancesGvk {
		err := group.client.
			Global().DeleteServiceInstanceByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ServiceDeploymentsGvk {
		err := group.client.
			Global().DeleteServiceDeploymentByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ServiceStatefulSetsGvk {
		err := group.client.
			Global().DeleteServiceStatefulSetByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ServiceDaemonSetsGvk {
		err := group.client.
			Global().DeleteServiceDaemonSetByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ServiceReplicaSetsGvk {
		err := group.client.
			Global().DeleteServiceReplicaSetByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ServiceCronJobsGvk {
		err := group.client.
			Global().DeleteServiceCronJobByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ServiceJobsGvk {
		err := group.client.
			Global().DeleteServiceJobByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.VirtualServicesGvk {
		err := group.client.
			Global().DeleteVirtualServiceByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ServiceEntryGvk {
		err := group.client.
			Global().DeleteServiceEntryByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.WorkloadEntryGvk {
		err := group.client.
			Global().DeleteWorkloadEntryByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.DestinationRulesGvk {
		err := group.client.
			Global().DeleteDestinationRuleByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ServicesGvk {
		err := group.client.
			Global().DeleteServiceByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.EndpointsGvk {
		err := group.client.
			Global().DeleteEndpointsByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.GatewaysGvk {
		err := group.client.
			Global().DeleteGatewayByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.AuthenticationPoliciesGvk {
		err := group.client.
			Global().DeleteAuthenticationPolicyByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ConfigmapGvk {
		err := group.client.
			Global().DeleteConfigMapByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.EnvoyfilterGvk {
		err := group.client.
			Global().DeleteEnvoyFilterByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.AutoscalersGvk {
		err := group.client.
			Global().DeleteAutoscalerCRByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.PeerAuthenticationGvk {
		err := group.client.
			Global().DeletePeerAuthenticationByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.KnativeIngressesGvk {
		err := group.client.
			Global().DeleteKnativeIngressByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.NetworkAttachmentDefinitionGvk {
		err := group.client.
			Global().DeleteNetworkAttachmentDefinitionByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.IssuersGvk {
		err := group.client.
			Global().DeleteIssuerByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.CertificatesGvk {
		err := group.client.
			Global().DeleteCertificateByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.CertificateRequestsGvk {
		err := group.client.
			Global().DeleteCertificateRequestByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/domainsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["clusters.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusters.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Clusters().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateDomainByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateDomainByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Domain) (*GlobalDomain, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.SecretHashesGvk = nil
	objToCreate.Spec.ServiceInstancesGvk = nil
	objToCreate.Spec.ServiceDeploymentsGvk = nil
	objToCreate.Spec.ServiceStatefulSetsGvk = nil
	objToCreate.Spec.ServiceDaemonSetsGvk = nil
	objToCreate.Spec.ServiceReplicaSetsGvk = nil
	objToCreate.Spec.ServiceCronJobsGvk = nil
	objToCreate.Spec.ServiceJobsGvk = nil
	objToCreate.Spec.VirtualServicesGvk = nil
	objToCreate.Spec.ServiceEntryGvk = nil
	objToCreate.Spec.WorkloadEntryGvk = nil
	objToCreate.Spec.DestinationRulesGvk = nil
	objToCreate.Spec.ServicesGvk = nil
	objToCreate.Spec.EndpointsGvk = nil
	objToCreate.Spec.GatewaysGvk = nil
	objToCreate.Spec.AuthenticationPoliciesGvk = nil
	objToCreate.Spec.ConfigmapGvk = nil
	objToCreate.Spec.EnvoyfilterGvk = nil
	objToCreate.Spec.AutoscalersGvk = nil
	objToCreate.Spec.PeerAuthenticationGvk = nil
	objToCreate.Spec.KnativeIngressesGvk = nil
	objToCreate.Spec.NetworkAttachmentDefinitionGvk = nil
	objToCreate.Spec.IssuersGvk = nil
	objToCreate.Spec.CertificatesGvk = nil
	objToCreate.Spec.CertificateRequestsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Domains().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["clusters.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusters.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"domainsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"Domain\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Clusters().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalDomain{
		client: group.client,
		Domain: result,
	}, nil
}

// UpdateDomainByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateDomainByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Domain) (*GlobalDomain, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Domains().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueEnviornmentType :=
		objToUpdate.Spec.EnviornmentType
	patchOpEnviornmentType := PatchOp{
		Op:    "replace",
		Path:  "/spec/enviornmentType",
		Value: patchValueEnviornmentType,
	}
	patch = append(patch, patchOpEnviornmentType)

	patchValueApiLink :=
		objToUpdate.Spec.ApiLink
	patchOpApiLink := PatchOp{
		Op:    "replace",
		Path:  "/spec/apiLink",
		Value: patchValueApiLink,
	}
	patch = append(patch, patchOpApiLink)

	patchValueAnnotations :=
		objToUpdate.Spec.Annotations
	patchOpAnnotations := PatchOp{
		Op:    "replace",
		Path:  "/spec/annotations",
		Value: patchValueAnnotations,
	}
	patch = append(patch, patchOpAnnotations)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueMetadata :=
		objToUpdate.Spec.Metadata
	patchOpMetadata := PatchOp{
		Op:    "replace",
		Path:  "/spec/metadata",
		Value: patchValueMetadata,
	}
	patch = append(patch, patchOpMetadata)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalDomain{
		client: group.client,
		Domain: result,
	}, nil
}

// ListDomains returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListDomains(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalDomain, err error) {
	key := "domains.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalDomain, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Domain)
			result[k] = &GlobalDomain{
				client: group.client,
				Domain: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Domains().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalDomain, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalDomain{
				client: group.client,
				Domain: &item,
			}
		}
	}
	return
}

type GlobalDomain struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Domain
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalDomain) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteDomainByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Domain = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalDomain) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateDomainByName(ctx, obj.Domain)
	if err != nil {
		return err
	}
	obj.Domain = result.Domain
	return nil
}

func (obj *GlobalDomain) GetParent(ctx context.Context) (result *GlobalCluster, err error) {
	hashedName := helper.GetHashedName("clusters.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["clusters.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetClusterByName(ctx, hashedName)
}

// GetAllSecretHashes returns all children of given type
func (obj *GlobalDomain) GetAllSecretHashes(ctx context.Context) (
	result []*GlobalSecretHash, err error) {
	result = make([]*GlobalSecretHash, 0, len(obj.Spec.SecretHashesGvk))
	for _, v := range obj.Spec.SecretHashesGvk {
		l, err := obj.client.Global().GetSecretHashByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetSecretHashes returns child which has given displayName
func (obj *GlobalDomain) GetSecretHashes(ctx context.Context,
	displayName string) (result *GlobalSecretHash, err error) {
	l, ok := obj.Spec.SecretHashesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "SecretHashes", displayName)
	}
	result, err = obj.client.Global().GetSecretHashByName(ctx, l.Name)
	return
}

// AddSecretHashes calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddSecretHashes(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SecretHash) (result *GlobalSecretHash, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateSecretHashByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteSecretHashes calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteSecretHashes(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.SecretHashesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "SecretHashes", displayName)
	}
	err = obj.client.Global().DeleteSecretHashByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllServiceInstances returns all children of given type
func (obj *GlobalDomain) GetAllServiceInstances(ctx context.Context) (
	result []*GlobalServiceInstance, err error) {
	result = make([]*GlobalServiceInstance, 0, len(obj.Spec.ServiceInstancesGvk))
	for _, v := range obj.Spec.ServiceInstancesGvk {
		l, err := obj.client.Global().GetServiceInstanceByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceInstances returns child which has given displayName
func (obj *GlobalDomain) GetServiceInstances(ctx context.Context,
	displayName string) (result *GlobalServiceInstance, err error) {
	l, ok := obj.Spec.ServiceInstancesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "ServiceInstances", displayName)
	}
	result, err = obj.client.Global().GetServiceInstanceByName(ctx, l.Name)
	return
}

// AddServiceInstances calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddServiceInstances(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceInstance) (result *GlobalServiceInstance, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceInstanceByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteServiceInstances calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteServiceInstances(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ServiceInstancesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "ServiceInstances", displayName)
	}
	err = obj.client.Global().DeleteServiceInstanceByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllServiceDeployments returns all children of given type
func (obj *GlobalDomain) GetAllServiceDeployments(ctx context.Context) (
	result []*GlobalServiceDeployment, err error) {
	result = make([]*GlobalServiceDeployment, 0, len(obj.Spec.ServiceDeploymentsGvk))
	for _, v := range obj.Spec.ServiceDeploymentsGvk {
		l, err := obj.client.Global().GetServiceDeploymentByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceDeployments returns child which has given displayName
func (obj *GlobalDomain) GetServiceDeployments(ctx context.Context,
	displayName string) (result *GlobalServiceDeployment, err error) {
	l, ok := obj.Spec.ServiceDeploymentsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "ServiceDeployments", displayName)
	}
	result, err = obj.client.Global().GetServiceDeploymentByName(ctx, l.Name)
	return
}

// AddServiceDeployments calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddServiceDeployments(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDeployment) (result *GlobalServiceDeployment, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceDeploymentByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteServiceDeployments calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteServiceDeployments(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ServiceDeploymentsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "ServiceDeployments", displayName)
	}
	err = obj.client.Global().DeleteServiceDeploymentByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllServiceStatefulSets returns all children of given type
func (obj *GlobalDomain) GetAllServiceStatefulSets(ctx context.Context) (
	result []*GlobalServiceStatefulSet, err error) {
	result = make([]*GlobalServiceStatefulSet, 0, len(obj.Spec.ServiceStatefulSetsGvk))
	for _, v := range obj.Spec.ServiceStatefulSetsGvk {
		l, err := obj.client.Global().GetServiceStatefulSetByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceStatefulSets returns child which has given displayName
func (obj *GlobalDomain) GetServiceStatefulSets(ctx context.Context,
	displayName string) (result *GlobalServiceStatefulSet, err error) {
	l, ok := obj.Spec.ServiceStatefulSetsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "ServiceStatefulSets", displayName)
	}
	result, err = obj.client.Global().GetServiceStatefulSetByName(ctx, l.Name)
	return
}

// AddServiceStatefulSets calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddServiceStatefulSets(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceStatefulSet) (result *GlobalServiceStatefulSet, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceStatefulSetByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteServiceStatefulSets calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteServiceStatefulSets(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ServiceStatefulSetsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "ServiceStatefulSets", displayName)
	}
	err = obj.client.Global().DeleteServiceStatefulSetByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllServiceDaemonSets returns all children of given type
func (obj *GlobalDomain) GetAllServiceDaemonSets(ctx context.Context) (
	result []*GlobalServiceDaemonSet, err error) {
	result = make([]*GlobalServiceDaemonSet, 0, len(obj.Spec.ServiceDaemonSetsGvk))
	for _, v := range obj.Spec.ServiceDaemonSetsGvk {
		l, err := obj.client.Global().GetServiceDaemonSetByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceDaemonSets returns child which has given displayName
func (obj *GlobalDomain) GetServiceDaemonSets(ctx context.Context,
	displayName string) (result *GlobalServiceDaemonSet, err error) {
	l, ok := obj.Spec.ServiceDaemonSetsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "ServiceDaemonSets", displayName)
	}
	result, err = obj.client.Global().GetServiceDaemonSetByName(ctx, l.Name)
	return
}

// AddServiceDaemonSets calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddServiceDaemonSets(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDaemonSet) (result *GlobalServiceDaemonSet, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceDaemonSetByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteServiceDaemonSets calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteServiceDaemonSets(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ServiceDaemonSetsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "ServiceDaemonSets", displayName)
	}
	err = obj.client.Global().DeleteServiceDaemonSetByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllServiceReplicaSets returns all children of given type
func (obj *GlobalDomain) GetAllServiceReplicaSets(ctx context.Context) (
	result []*GlobalServiceReplicaSet, err error) {
	result = make([]*GlobalServiceReplicaSet, 0, len(obj.Spec.ServiceReplicaSetsGvk))
	for _, v := range obj.Spec.ServiceReplicaSetsGvk {
		l, err := obj.client.Global().GetServiceReplicaSetByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceReplicaSets returns child which has given displayName
func (obj *GlobalDomain) GetServiceReplicaSets(ctx context.Context,
	displayName string) (result *GlobalServiceReplicaSet, err error) {
	l, ok := obj.Spec.ServiceReplicaSetsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "ServiceReplicaSets", displayName)
	}
	result, err = obj.client.Global().GetServiceReplicaSetByName(ctx, l.Name)
	return
}

// AddServiceReplicaSets calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddServiceReplicaSets(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceReplicaSet) (result *GlobalServiceReplicaSet, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceReplicaSetByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteServiceReplicaSets calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteServiceReplicaSets(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ServiceReplicaSetsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "ServiceReplicaSets", displayName)
	}
	err = obj.client.Global().DeleteServiceReplicaSetByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllServiceCronJobs returns all children of given type
func (obj *GlobalDomain) GetAllServiceCronJobs(ctx context.Context) (
	result []*GlobalServiceCronJob, err error) {
	result = make([]*GlobalServiceCronJob, 0, len(obj.Spec.ServiceCronJobsGvk))
	for _, v := range obj.Spec.ServiceCronJobsGvk {
		l, err := obj.client.Global().GetServiceCronJobByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceCronJobs returns child which has given displayName
func (obj *GlobalDomain) GetServiceCronJobs(ctx context.Context,
	displayName string) (result *GlobalServiceCronJob, err error) {
	l, ok := obj.Spec.ServiceCronJobsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "ServiceCronJobs", displayName)
	}
	result, err = obj.client.Global().GetServiceCronJobByName(ctx, l.Name)
	return
}

// AddServiceCronJobs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddServiceCronJobs(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceCronJob) (result *GlobalServiceCronJob, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceCronJobByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteServiceCronJobs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteServiceCronJobs(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ServiceCronJobsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "ServiceCronJobs", displayName)
	}
	err = obj.client.Global().DeleteServiceCronJobByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllServiceJobs returns all children of given type
func (obj *GlobalDomain) GetAllServiceJobs(ctx context.Context) (
	result []*GlobalServiceJob, err error) {
	result = make([]*GlobalServiceJob, 0, len(obj.Spec.ServiceJobsGvk))
	for _, v := range obj.Spec.ServiceJobsGvk {
		l, err := obj.client.Global().GetServiceJobByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceJobs returns child which has given displayName
func (obj *GlobalDomain) GetServiceJobs(ctx context.Context,
	displayName string) (result *GlobalServiceJob, err error) {
	l, ok := obj.Spec.ServiceJobsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "ServiceJobs", displayName)
	}
	result, err = obj.client.Global().GetServiceJobByName(ctx, l.Name)
	return
}

// AddServiceJobs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddServiceJobs(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceJob) (result *GlobalServiceJob, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceJobByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteServiceJobs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteServiceJobs(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ServiceJobsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "ServiceJobs", displayName)
	}
	err = obj.client.Global().DeleteServiceJobByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllVirtualServices returns all children of given type
func (obj *GlobalDomain) GetAllVirtualServices(ctx context.Context) (
	result []*GlobalVirtualService, err error) {
	result = make([]*GlobalVirtualService, 0, len(obj.Spec.VirtualServicesGvk))
	for _, v := range obj.Spec.VirtualServicesGvk {
		l, err := obj.client.Global().GetVirtualServiceByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetVirtualServices returns child which has given displayName
func (obj *GlobalDomain) GetVirtualServices(ctx context.Context,
	displayName string) (result *GlobalVirtualService, err error) {
	l, ok := obj.Spec.VirtualServicesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "VirtualServices", displayName)
	}
	result, err = obj.client.Global().GetVirtualServiceByName(ctx, l.Name)
	return
}

// AddVirtualServices calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddVirtualServices(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.VirtualService) (result *GlobalVirtualService, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateVirtualServiceByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteVirtualServices calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteVirtualServices(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.VirtualServicesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "VirtualServices", displayName)
	}
	err = obj.client.Global().DeleteVirtualServiceByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllServiceEntry returns all children of given type
func (obj *GlobalDomain) GetAllServiceEntry(ctx context.Context) (
	result []*GlobalServiceEntry, err error) {
	result = make([]*GlobalServiceEntry, 0, len(obj.Spec.ServiceEntryGvk))
	for _, v := range obj.Spec.ServiceEntryGvk {
		l, err := obj.client.Global().GetServiceEntryByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceEntry returns child which has given displayName
func (obj *GlobalDomain) GetServiceEntry(ctx context.Context,
	displayName string) (result *GlobalServiceEntry, err error) {
	l, ok := obj.Spec.ServiceEntryGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "ServiceEntry", displayName)
	}
	result, err = obj.client.Global().GetServiceEntryByName(ctx, l.Name)
	return
}

// AddServiceEntry calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddServiceEntry(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceEntry) (result *GlobalServiceEntry, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceEntryByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteServiceEntry calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteServiceEntry(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ServiceEntryGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "ServiceEntry", displayName)
	}
	err = obj.client.Global().DeleteServiceEntryByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllWorkloadEntry returns all children of given type
func (obj *GlobalDomain) GetAllWorkloadEntry(ctx context.Context) (
	result []*GlobalWorkloadEntry, err error) {
	result = make([]*GlobalWorkloadEntry, 0, len(obj.Spec.WorkloadEntryGvk))
	for _, v := range obj.Spec.WorkloadEntryGvk {
		l, err := obj.client.Global().GetWorkloadEntryByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetWorkloadEntry returns child which has given displayName
func (obj *GlobalDomain) GetWorkloadEntry(ctx context.Context,
	displayName string) (result *GlobalWorkloadEntry, err error) {
	l, ok := obj.Spec.WorkloadEntryGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "WorkloadEntry", displayName)
	}
	result, err = obj.client.Global().GetWorkloadEntryByName(ctx, l.Name)
	return
}

// AddWorkloadEntry calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddWorkloadEntry(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.WorkloadEntry) (result *GlobalWorkloadEntry, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateWorkloadEntryByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteWorkloadEntry calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteWorkloadEntry(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.WorkloadEntryGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "WorkloadEntry", displayName)
	}
	err = obj.client.Global().DeleteWorkloadEntryByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllDestinationRules returns all children of given type
func (obj *GlobalDomain) GetAllDestinationRules(ctx context.Context) (
	result []*GlobalDestinationRule, err error) {
	result = make([]*GlobalDestinationRule, 0, len(obj.Spec.DestinationRulesGvk))
	for _, v := range obj.Spec.DestinationRulesGvk {
		l, err := obj.client.Global().GetDestinationRuleByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetDestinationRules returns child which has given displayName
func (obj *GlobalDomain) GetDestinationRules(ctx context.Context,
	displayName string) (result *GlobalDestinationRule, err error) {
	l, ok := obj.Spec.DestinationRulesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "DestinationRules", displayName)
	}
	result, err = obj.client.Global().GetDestinationRuleByName(ctx, l.Name)
	return
}

// AddDestinationRules calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddDestinationRules(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DestinationRule) (result *GlobalDestinationRule, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateDestinationRuleByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteDestinationRules calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteDestinationRules(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.DestinationRulesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "DestinationRules", displayName)
	}
	err = obj.client.Global().DeleteDestinationRuleByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllServices returns all children of given type
func (obj *GlobalDomain) GetAllServices(ctx context.Context) (
	result []*GlobalService, err error) {
	result = make([]*GlobalService, 0, len(obj.Spec.ServicesGvk))
	for _, v := range obj.Spec.ServicesGvk {
		l, err := obj.client.Global().GetServiceByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServices returns child which has given displayName
func (obj *GlobalDomain) GetServices(ctx context.Context,
	displayName string) (result *GlobalService, err error) {
	l, ok := obj.Spec.ServicesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "Services", displayName)
	}
	result, err = obj.client.Global().GetServiceByName(ctx, l.Name)
	return
}

// AddServices calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddServices(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Service) (result *GlobalService, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteServices calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteServices(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ServicesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "Services", displayName)
	}
	err = obj.client.Global().DeleteServiceByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllEndpoints returns all children of given type
func (obj *GlobalDomain) GetAllEndpoints(ctx context.Context) (
	result []*GlobalEndpoints, err error) {
	result = make([]*GlobalEndpoints, 0, len(obj.Spec.EndpointsGvk))
	for _, v := range obj.Spec.EndpointsGvk {
		l, err := obj.client.Global().GetEndpointsByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetEndpoints returns child which has given displayName
func (obj *GlobalDomain) GetEndpoints(ctx context.Context,
	displayName string) (result *GlobalEndpoints, err error) {
	l, ok := obj.Spec.EndpointsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "Endpoints", displayName)
	}
	result, err = obj.client.Global().GetEndpointsByName(ctx, l.Name)
	return
}

// AddEndpoints calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddEndpoints(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Endpoints) (result *GlobalEndpoints, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateEndpointsByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteEndpoints calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteEndpoints(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.EndpointsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "Endpoints", displayName)
	}
	err = obj.client.Global().DeleteEndpointsByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllGateways returns all children of given type
func (obj *GlobalDomain) GetAllGateways(ctx context.Context) (
	result []*GlobalGateway, err error) {
	result = make([]*GlobalGateway, 0, len(obj.Spec.GatewaysGvk))
	for _, v := range obj.Spec.GatewaysGvk {
		l, err := obj.client.Global().GetGatewayByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGateways returns child which has given displayName
func (obj *GlobalDomain) GetGateways(ctx context.Context,
	displayName string) (result *GlobalGateway, err error) {
	l, ok := obj.Spec.GatewaysGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "Gateways", displayName)
	}
	result, err = obj.client.Global().GetGatewayByName(ctx, l.Name)
	return
}

// AddGateways calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddGateways(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Gateway) (result *GlobalGateway, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGatewayByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteGateways calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteGateways(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.GatewaysGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "Gateways", displayName)
	}
	err = obj.client.Global().DeleteGatewayByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllAuthenticationPolicies returns all children of given type
func (obj *GlobalDomain) GetAllAuthenticationPolicies(ctx context.Context) (
	result []*GlobalAuthenticationPolicy, err error) {
	result = make([]*GlobalAuthenticationPolicy, 0, len(obj.Spec.AuthenticationPoliciesGvk))
	for _, v := range obj.Spec.AuthenticationPoliciesGvk {
		l, err := obj.client.Global().GetAuthenticationPolicyByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetAuthenticationPolicies returns child which has given displayName
func (obj *GlobalDomain) GetAuthenticationPolicies(ctx context.Context,
	displayName string) (result *GlobalAuthenticationPolicy, err error) {
	l, ok := obj.Spec.AuthenticationPoliciesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "AuthenticationPolicies", displayName)
	}
	result, err = obj.client.Global().GetAuthenticationPolicyByName(ctx, l.Name)
	return
}

// AddAuthenticationPolicies calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddAuthenticationPolicies(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AuthenticationPolicy) (result *GlobalAuthenticationPolicy, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateAuthenticationPolicyByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteAuthenticationPolicies calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteAuthenticationPolicies(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.AuthenticationPoliciesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "AuthenticationPolicies", displayName)
	}
	err = obj.client.Global().DeleteAuthenticationPolicyByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllConfigmap returns all children of given type
func (obj *GlobalDomain) GetAllConfigmap(ctx context.Context) (
	result []*GlobalConfigMap, err error) {
	result = make([]*GlobalConfigMap, 0, len(obj.Spec.ConfigmapGvk))
	for _, v := range obj.Spec.ConfigmapGvk {
		l, err := obj.client.Global().GetConfigMapByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetConfigmap returns child which has given displayName
func (obj *GlobalDomain) GetConfigmap(ctx context.Context,
	displayName string) (result *GlobalConfigMap, err error) {
	l, ok := obj.Spec.ConfigmapGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "Configmap", displayName)
	}
	result, err = obj.client.Global().GetConfigMapByName(ctx, l.Name)
	return
}

// AddConfigmap calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddConfigmap(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ConfigMap) (result *GlobalConfigMap, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateConfigMapByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteConfigmap calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteConfigmap(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ConfigmapGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "Configmap", displayName)
	}
	err = obj.client.Global().DeleteConfigMapByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllEnvoyfilter returns all children of given type
func (obj *GlobalDomain) GetAllEnvoyfilter(ctx context.Context) (
	result []*GlobalEnvoyFilter, err error) {
	result = make([]*GlobalEnvoyFilter, 0, len(obj.Spec.EnvoyfilterGvk))
	for _, v := range obj.Spec.EnvoyfilterGvk {
		l, err := obj.client.Global().GetEnvoyFilterByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetEnvoyfilter returns child which has given displayName
func (obj *GlobalDomain) GetEnvoyfilter(ctx context.Context,
	displayName string) (result *GlobalEnvoyFilter, err error) {
	l, ok := obj.Spec.EnvoyfilterGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "Envoyfilter", displayName)
	}
	result, err = obj.client.Global().GetEnvoyFilterByName(ctx, l.Name)
	return
}

// AddEnvoyfilter calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddEnvoyfilter(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.EnvoyFilter) (result *GlobalEnvoyFilter, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateEnvoyFilterByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteEnvoyfilter calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteEnvoyfilter(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.EnvoyfilterGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "Envoyfilter", displayName)
	}
	err = obj.client.Global().DeleteEnvoyFilterByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllAutoscalers returns all children of given type
func (obj *GlobalDomain) GetAllAutoscalers(ctx context.Context) (
	result []*GlobalAutoscalerCR, err error) {
	result = make([]*GlobalAutoscalerCR, 0, len(obj.Spec.AutoscalersGvk))
	for _, v := range obj.Spec.AutoscalersGvk {
		l, err := obj.client.Global().GetAutoscalerCRByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetAutoscalers returns child which has given displayName
func (obj *GlobalDomain) GetAutoscalers(ctx context.Context,
	displayName string) (result *GlobalAutoscalerCR, err error) {
	l, ok := obj.Spec.AutoscalersGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "Autoscalers", displayName)
	}
	result, err = obj.client.Global().GetAutoscalerCRByName(ctx, l.Name)
	return
}

// AddAutoscalers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddAutoscalers(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AutoscalerCR) (result *GlobalAutoscalerCR, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateAutoscalerCRByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteAutoscalers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteAutoscalers(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.AutoscalersGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "Autoscalers", displayName)
	}
	err = obj.client.Global().DeleteAutoscalerCRByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllPeerAuthentication returns all children of given type
func (obj *GlobalDomain) GetAllPeerAuthentication(ctx context.Context) (
	result []*GlobalPeerAuthentication, err error) {
	result = make([]*GlobalPeerAuthentication, 0, len(obj.Spec.PeerAuthenticationGvk))
	for _, v := range obj.Spec.PeerAuthenticationGvk {
		l, err := obj.client.Global().GetPeerAuthenticationByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetPeerAuthentication returns child which has given displayName
func (obj *GlobalDomain) GetPeerAuthentication(ctx context.Context,
	displayName string) (result *GlobalPeerAuthentication, err error) {
	l, ok := obj.Spec.PeerAuthenticationGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "PeerAuthentication", displayName)
	}
	result, err = obj.client.Global().GetPeerAuthenticationByName(ctx, l.Name)
	return
}

// AddPeerAuthentication calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddPeerAuthentication(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PeerAuthentication) (result *GlobalPeerAuthentication, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreatePeerAuthenticationByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeletePeerAuthentication calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeletePeerAuthentication(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.PeerAuthenticationGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "PeerAuthentication", displayName)
	}
	err = obj.client.Global().DeletePeerAuthenticationByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllKnativeIngresses returns all children of given type
func (obj *GlobalDomain) GetAllKnativeIngresses(ctx context.Context) (
	result []*GlobalKnativeIngress, err error) {
	result = make([]*GlobalKnativeIngress, 0, len(obj.Spec.KnativeIngressesGvk))
	for _, v := range obj.Spec.KnativeIngressesGvk {
		l, err := obj.client.Global().GetKnativeIngressByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetKnativeIngresses returns child which has given displayName
func (obj *GlobalDomain) GetKnativeIngresses(ctx context.Context,
	displayName string) (result *GlobalKnativeIngress, err error) {
	l, ok := obj.Spec.KnativeIngressesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "KnativeIngresses", displayName)
	}
	result, err = obj.client.Global().GetKnativeIngressByName(ctx, l.Name)
	return
}

// AddKnativeIngresses calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddKnativeIngresses(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.KnativeIngress) (result *GlobalKnativeIngress, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateKnativeIngressByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteKnativeIngresses calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteKnativeIngresses(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.KnativeIngressesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "KnativeIngresses", displayName)
	}
	err = obj.client.Global().DeleteKnativeIngressByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllNetworkAttachmentDefinition returns all children of given type
func (obj *GlobalDomain) GetAllNetworkAttachmentDefinition(ctx context.Context) (
	result []*GlobalNetworkAttachmentDefinition, err error) {
	result = make([]*GlobalNetworkAttachmentDefinition, 0, len(obj.Spec.NetworkAttachmentDefinitionGvk))
	for _, v := range obj.Spec.NetworkAttachmentDefinitionGvk {
		l, err := obj.client.Global().GetNetworkAttachmentDefinitionByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetNetworkAttachmentDefinition returns child which has given displayName
func (obj *GlobalDomain) GetNetworkAttachmentDefinition(ctx context.Context,
	displayName string) (result *GlobalNetworkAttachmentDefinition, err error) {
	l, ok := obj.Spec.NetworkAttachmentDefinitionGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "NetworkAttachmentDefinition", displayName)
	}
	result, err = obj.client.Global().GetNetworkAttachmentDefinitionByName(ctx, l.Name)
	return
}

// AddNetworkAttachmentDefinition calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddNetworkAttachmentDefinition(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NetworkAttachmentDefinition) (result *GlobalNetworkAttachmentDefinition, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateNetworkAttachmentDefinitionByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteNetworkAttachmentDefinition calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteNetworkAttachmentDefinition(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.NetworkAttachmentDefinitionGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "NetworkAttachmentDefinition", displayName)
	}
	err = obj.client.Global().DeleteNetworkAttachmentDefinitionByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllIssuers returns all children of given type
func (obj *GlobalDomain) GetAllIssuers(ctx context.Context) (
	result []*GlobalIssuer, err error) {
	result = make([]*GlobalIssuer, 0, len(obj.Spec.IssuersGvk))
	for _, v := range obj.Spec.IssuersGvk {
		l, err := obj.client.Global().GetIssuerByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetIssuers returns child which has given displayName
func (obj *GlobalDomain) GetIssuers(ctx context.Context,
	displayName string) (result *GlobalIssuer, err error) {
	l, ok := obj.Spec.IssuersGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "Issuers", displayName)
	}
	result, err = obj.client.Global().GetIssuerByName(ctx, l.Name)
	return
}

// AddIssuers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddIssuers(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Issuer) (result *GlobalIssuer, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateIssuerByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteIssuers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteIssuers(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.IssuersGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "Issuers", displayName)
	}
	err = obj.client.Global().DeleteIssuerByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllCertificates returns all children of given type
func (obj *GlobalDomain) GetAllCertificates(ctx context.Context) (
	result []*GlobalCertificate, err error) {
	result = make([]*GlobalCertificate, 0, len(obj.Spec.CertificatesGvk))
	for _, v := range obj.Spec.CertificatesGvk {
		l, err := obj.client.Global().GetCertificateByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetCertificates returns child which has given displayName
func (obj *GlobalDomain) GetCertificates(ctx context.Context,
	displayName string) (result *GlobalCertificate, err error) {
	l, ok := obj.Spec.CertificatesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "Certificates", displayName)
	}
	result, err = obj.client.Global().GetCertificateByName(ctx, l.Name)
	return
}

// AddCertificates calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddCertificates(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Certificate) (result *GlobalCertificate, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateCertificateByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteCertificates calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteCertificates(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.CertificatesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "Certificates", displayName)
	}
	err = obj.client.Global().DeleteCertificateByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// GetAllCertificateRequests returns all children of given type
func (obj *GlobalDomain) GetAllCertificateRequests(ctx context.Context) (
	result []*GlobalCertificateRequest, err error) {
	result = make([]*GlobalCertificateRequest, 0, len(obj.Spec.CertificateRequestsGvk))
	for _, v := range obj.Spec.CertificateRequestsGvk {
		l, err := obj.client.Global().GetCertificateRequestByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetCertificateRequests returns child which has given displayName
func (obj *GlobalDomain) GetCertificateRequests(ctx context.Context,
	displayName string) (result *GlobalCertificateRequest, err error) {
	l, ok := obj.Spec.CertificateRequestsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Domain", "CertificateRequests", displayName)
	}
	result, err = obj.client.Global().GetCertificateRequestByName(ctx, l.Name)
	return
}

// AddCertificateRequests calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalDomain) AddCertificateRequests(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.CertificateRequest) (result *GlobalCertificateRequest, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["domains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["domains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateCertificateRequestByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

// DeleteCertificateRequests calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalDomain) DeleteCertificateRequests(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.CertificateRequestsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Domain", "CertificateRequests", displayName)
	}
	err = obj.client.Global().DeleteCertificateRequestByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.Domain = updatedObj.Domain
	}
	return
}

type domainGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *domainGlobalTsmV1Chainer) Subscribe() {
	key := "domains.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewDomainInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *domainGlobalTsmV1Chainer) Unsubscribe() {
	key := "domains.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *domainGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "domains.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *domainGlobalTsmV1Chainer) SecretHashes(name string) *secrethashGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["secrethashes.global.tsm.tanzu.vmware.com"] = name
	return &secrethashGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetSecretHashes calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetSecretHashes(ctx context.Context, displayName string) (result *GlobalSecretHash, err error) {
	hashedName := helper.GetHashedName("secrethashes.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetSecretHashByName(ctx, hashedName)
}

// AddSecretHashes calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddSecretHashes(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SecretHash) (result *GlobalSecretHash, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("secrethashes.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateSecretHashByName(ctx, objToCreate)
}

// DeleteSecretHashes calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteSecretHashes(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("secrethashes.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteSecretHashByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) ServiceInstances(name string) *serviceinstanceGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["serviceinstances.global.tsm.tanzu.vmware.com"] = name
	return &serviceinstanceGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetServiceInstances calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetServiceInstances(ctx context.Context, displayName string) (result *GlobalServiceInstance, err error) {
	hashedName := helper.GetHashedName("serviceinstances.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceInstanceByName(ctx, hashedName)
}

// AddServiceInstances calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddServiceInstances(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceInstance) (result *GlobalServiceInstance, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("serviceinstances.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceInstanceByName(ctx, objToCreate)
}

// DeleteServiceInstances calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteServiceInstances(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("serviceinstances.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceInstanceByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) ServiceDeployments(name string) *servicedeploymentGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["servicedeployments.global.tsm.tanzu.vmware.com"] = name
	return &servicedeploymentGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetServiceDeployments calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetServiceDeployments(ctx context.Context, displayName string) (result *GlobalServiceDeployment, err error) {
	hashedName := helper.GetHashedName("servicedeployments.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceDeploymentByName(ctx, hashedName)
}

// AddServiceDeployments calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddServiceDeployments(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDeployment) (result *GlobalServiceDeployment, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("servicedeployments.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceDeploymentByName(ctx, objToCreate)
}

// DeleteServiceDeployments calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteServiceDeployments(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("servicedeployments.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceDeploymentByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) ServiceStatefulSets(name string) *servicestatefulsetGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["servicestatefulsets.global.tsm.tanzu.vmware.com"] = name
	return &servicestatefulsetGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetServiceStatefulSets calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetServiceStatefulSets(ctx context.Context, displayName string) (result *GlobalServiceStatefulSet, err error) {
	hashedName := helper.GetHashedName("servicestatefulsets.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceStatefulSetByName(ctx, hashedName)
}

// AddServiceStatefulSets calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddServiceStatefulSets(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceStatefulSet) (result *GlobalServiceStatefulSet, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("servicestatefulsets.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceStatefulSetByName(ctx, objToCreate)
}

// DeleteServiceStatefulSets calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteServiceStatefulSets(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("servicestatefulsets.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceStatefulSetByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) ServiceDaemonSets(name string) *servicedaemonsetGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["servicedaemonsets.global.tsm.tanzu.vmware.com"] = name
	return &servicedaemonsetGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetServiceDaemonSets calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetServiceDaemonSets(ctx context.Context, displayName string) (result *GlobalServiceDaemonSet, err error) {
	hashedName := helper.GetHashedName("servicedaemonsets.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceDaemonSetByName(ctx, hashedName)
}

// AddServiceDaemonSets calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddServiceDaemonSets(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDaemonSet) (result *GlobalServiceDaemonSet, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("servicedaemonsets.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceDaemonSetByName(ctx, objToCreate)
}

// DeleteServiceDaemonSets calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteServiceDaemonSets(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("servicedaemonsets.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceDaemonSetByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) ServiceReplicaSets(name string) *servicereplicasetGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["servicereplicasets.global.tsm.tanzu.vmware.com"] = name
	return &servicereplicasetGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetServiceReplicaSets calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetServiceReplicaSets(ctx context.Context, displayName string) (result *GlobalServiceReplicaSet, err error) {
	hashedName := helper.GetHashedName("servicereplicasets.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceReplicaSetByName(ctx, hashedName)
}

// AddServiceReplicaSets calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddServiceReplicaSets(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceReplicaSet) (result *GlobalServiceReplicaSet, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("servicereplicasets.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceReplicaSetByName(ctx, objToCreate)
}

// DeleteServiceReplicaSets calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteServiceReplicaSets(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("servicereplicasets.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceReplicaSetByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) ServiceCronJobs(name string) *servicecronjobGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["servicecronjobs.global.tsm.tanzu.vmware.com"] = name
	return &servicecronjobGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetServiceCronJobs calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetServiceCronJobs(ctx context.Context, displayName string) (result *GlobalServiceCronJob, err error) {
	hashedName := helper.GetHashedName("servicecronjobs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceCronJobByName(ctx, hashedName)
}

// AddServiceCronJobs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddServiceCronJobs(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceCronJob) (result *GlobalServiceCronJob, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("servicecronjobs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceCronJobByName(ctx, objToCreate)
}

// DeleteServiceCronJobs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteServiceCronJobs(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("servicecronjobs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceCronJobByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) ServiceJobs(name string) *servicejobGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["servicejobs.global.tsm.tanzu.vmware.com"] = name
	return &servicejobGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetServiceJobs calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetServiceJobs(ctx context.Context, displayName string) (result *GlobalServiceJob, err error) {
	hashedName := helper.GetHashedName("servicejobs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceJobByName(ctx, hashedName)
}

// AddServiceJobs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddServiceJobs(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceJob) (result *GlobalServiceJob, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("servicejobs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceJobByName(ctx, objToCreate)
}

// DeleteServiceJobs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteServiceJobs(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("servicejobs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceJobByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) VirtualServices(name string) *virtualserviceGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["virtualservices.global.tsm.tanzu.vmware.com"] = name
	return &virtualserviceGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetVirtualServices calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetVirtualServices(ctx context.Context, displayName string) (result *GlobalVirtualService, err error) {
	hashedName := helper.GetHashedName("virtualservices.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetVirtualServiceByName(ctx, hashedName)
}

// AddVirtualServices calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddVirtualServices(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.VirtualService) (result *GlobalVirtualService, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("virtualservices.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateVirtualServiceByName(ctx, objToCreate)
}

// DeleteVirtualServices calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteVirtualServices(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("virtualservices.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteVirtualServiceByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) ServiceEntry(name string) *serviceentryGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["serviceentries.global.tsm.tanzu.vmware.com"] = name
	return &serviceentryGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetServiceEntry calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetServiceEntry(ctx context.Context, displayName string) (result *GlobalServiceEntry, err error) {
	hashedName := helper.GetHashedName("serviceentries.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceEntryByName(ctx, hashedName)
}

// AddServiceEntry calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddServiceEntry(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceEntry) (result *GlobalServiceEntry, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("serviceentries.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceEntryByName(ctx, objToCreate)
}

// DeleteServiceEntry calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteServiceEntry(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("serviceentries.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceEntryByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) WorkloadEntry(name string) *workloadentryGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["workloadentries.global.tsm.tanzu.vmware.com"] = name
	return &workloadentryGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetWorkloadEntry calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetWorkloadEntry(ctx context.Context, displayName string) (result *GlobalWorkloadEntry, err error) {
	hashedName := helper.GetHashedName("workloadentries.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetWorkloadEntryByName(ctx, hashedName)
}

// AddWorkloadEntry calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddWorkloadEntry(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.WorkloadEntry) (result *GlobalWorkloadEntry, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("workloadentries.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateWorkloadEntryByName(ctx, objToCreate)
}

// DeleteWorkloadEntry calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteWorkloadEntry(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("workloadentries.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteWorkloadEntryByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) DestinationRules(name string) *destinationruleGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["destinationrules.global.tsm.tanzu.vmware.com"] = name
	return &destinationruleGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetDestinationRules calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetDestinationRules(ctx context.Context, displayName string) (result *GlobalDestinationRule, err error) {
	hashedName := helper.GetHashedName("destinationrules.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetDestinationRuleByName(ctx, hashedName)
}

// AddDestinationRules calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddDestinationRules(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DestinationRule) (result *GlobalDestinationRule, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("destinationrules.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateDestinationRuleByName(ctx, objToCreate)
}

// DeleteDestinationRules calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteDestinationRules(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("destinationrules.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteDestinationRuleByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) Services(name string) *serviceGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["services.global.tsm.tanzu.vmware.com"] = name
	return &serviceGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetServices calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetServices(ctx context.Context, displayName string) (result *GlobalService, err error) {
	hashedName := helper.GetHashedName("services.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceByName(ctx, hashedName)
}

// AddServices calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddServices(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Service) (result *GlobalService, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("services.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceByName(ctx, objToCreate)
}

// DeleteServices calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteServices(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("services.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) Endpoints(name string) *endpointsGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["endpoints.global.tsm.tanzu.vmware.com"] = name
	return &endpointsGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetEndpoints calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetEndpoints(ctx context.Context, displayName string) (result *GlobalEndpoints, err error) {
	hashedName := helper.GetHashedName("endpoints.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetEndpointsByName(ctx, hashedName)
}

// AddEndpoints calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddEndpoints(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Endpoints) (result *GlobalEndpoints, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("endpoints.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateEndpointsByName(ctx, objToCreate)
}

// DeleteEndpoints calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteEndpoints(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("endpoints.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteEndpointsByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) Gateways(name string) *gatewayGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gateways.global.tsm.tanzu.vmware.com"] = name
	return &gatewayGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGateways calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetGateways(ctx context.Context, displayName string) (result *GlobalGateway, err error) {
	hashedName := helper.GetHashedName("gateways.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGatewayByName(ctx, hashedName)
}

// AddGateways calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddGateways(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Gateway) (result *GlobalGateway, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gateways.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGatewayByName(ctx, objToCreate)
}

// DeleteGateways calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteGateways(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gateways.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGatewayByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) AuthenticationPolicies(name string) *authenticationpolicyGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["authenticationpolicies.global.tsm.tanzu.vmware.com"] = name
	return &authenticationpolicyGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetAuthenticationPolicies calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetAuthenticationPolicies(ctx context.Context, displayName string) (result *GlobalAuthenticationPolicy, err error) {
	hashedName := helper.GetHashedName("authenticationpolicies.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetAuthenticationPolicyByName(ctx, hashedName)
}

// AddAuthenticationPolicies calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddAuthenticationPolicies(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AuthenticationPolicy) (result *GlobalAuthenticationPolicy, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("authenticationpolicies.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateAuthenticationPolicyByName(ctx, objToCreate)
}

// DeleteAuthenticationPolicies calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteAuthenticationPolicies(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("authenticationpolicies.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteAuthenticationPolicyByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) Configmap(name string) *configmapGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["configmaps.global.tsm.tanzu.vmware.com"] = name
	return &configmapGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetConfigmap calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetConfigmap(ctx context.Context, displayName string) (result *GlobalConfigMap, err error) {
	hashedName := helper.GetHashedName("configmaps.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetConfigMapByName(ctx, hashedName)
}

// AddConfigmap calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddConfigmap(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ConfigMap) (result *GlobalConfigMap, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("configmaps.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateConfigMapByName(ctx, objToCreate)
}

// DeleteConfigmap calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteConfigmap(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("configmaps.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteConfigMapByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) Envoyfilter(name string) *envoyfilterGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["envoyfilters.global.tsm.tanzu.vmware.com"] = name
	return &envoyfilterGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetEnvoyfilter calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetEnvoyfilter(ctx context.Context, displayName string) (result *GlobalEnvoyFilter, err error) {
	hashedName := helper.GetHashedName("envoyfilters.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetEnvoyFilterByName(ctx, hashedName)
}

// AddEnvoyfilter calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddEnvoyfilter(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.EnvoyFilter) (result *GlobalEnvoyFilter, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("envoyfilters.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateEnvoyFilterByName(ctx, objToCreate)
}

// DeleteEnvoyfilter calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteEnvoyfilter(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("envoyfilters.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteEnvoyFilterByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) Autoscalers(name string) *autoscalercrGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["autoscalercrs.global.tsm.tanzu.vmware.com"] = name
	return &autoscalercrGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetAutoscalers calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetAutoscalers(ctx context.Context, displayName string) (result *GlobalAutoscalerCR, err error) {
	hashedName := helper.GetHashedName("autoscalercrs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetAutoscalerCRByName(ctx, hashedName)
}

// AddAutoscalers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddAutoscalers(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AutoscalerCR) (result *GlobalAutoscalerCR, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("autoscalercrs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateAutoscalerCRByName(ctx, objToCreate)
}

// DeleteAutoscalers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteAutoscalers(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("autoscalercrs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteAutoscalerCRByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) PeerAuthentication(name string) *peerauthenticationGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["peerauthentications.global.tsm.tanzu.vmware.com"] = name
	return &peerauthenticationGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetPeerAuthentication calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetPeerAuthentication(ctx context.Context, displayName string) (result *GlobalPeerAuthentication, err error) {
	hashedName := helper.GetHashedName("peerauthentications.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetPeerAuthenticationByName(ctx, hashedName)
}

// AddPeerAuthentication calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddPeerAuthentication(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PeerAuthentication) (result *GlobalPeerAuthentication, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("peerauthentications.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreatePeerAuthenticationByName(ctx, objToCreate)
}

// DeletePeerAuthentication calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeletePeerAuthentication(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("peerauthentications.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeletePeerAuthenticationByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) KnativeIngresses(name string) *knativeingressGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["knativeingresses.global.tsm.tanzu.vmware.com"] = name
	return &knativeingressGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetKnativeIngresses calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetKnativeIngresses(ctx context.Context, displayName string) (result *GlobalKnativeIngress, err error) {
	hashedName := helper.GetHashedName("knativeingresses.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetKnativeIngressByName(ctx, hashedName)
}

// AddKnativeIngresses calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddKnativeIngresses(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.KnativeIngress) (result *GlobalKnativeIngress, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("knativeingresses.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateKnativeIngressByName(ctx, objToCreate)
}

// DeleteKnativeIngresses calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteKnativeIngresses(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("knativeingresses.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteKnativeIngressByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) NetworkAttachmentDefinition(name string) *networkattachmentdefinitionGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["networkattachmentdefinitions.global.tsm.tanzu.vmware.com"] = name
	return &networkattachmentdefinitionGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetNetworkAttachmentDefinition calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetNetworkAttachmentDefinition(ctx context.Context, displayName string) (result *GlobalNetworkAttachmentDefinition, err error) {
	hashedName := helper.GetHashedName("networkattachmentdefinitions.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetNetworkAttachmentDefinitionByName(ctx, hashedName)
}

// AddNetworkAttachmentDefinition calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddNetworkAttachmentDefinition(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NetworkAttachmentDefinition) (result *GlobalNetworkAttachmentDefinition, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("networkattachmentdefinitions.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateNetworkAttachmentDefinitionByName(ctx, objToCreate)
}

// DeleteNetworkAttachmentDefinition calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteNetworkAttachmentDefinition(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("networkattachmentdefinitions.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteNetworkAttachmentDefinitionByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) Issuers(name string) *issuerGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["issuers.global.tsm.tanzu.vmware.com"] = name
	return &issuerGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetIssuers calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetIssuers(ctx context.Context, displayName string) (result *GlobalIssuer, err error) {
	hashedName := helper.GetHashedName("issuers.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetIssuerByName(ctx, hashedName)
}

// AddIssuers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddIssuers(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Issuer) (result *GlobalIssuer, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("issuers.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateIssuerByName(ctx, objToCreate)
}

// DeleteIssuers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteIssuers(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("issuers.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteIssuerByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) Certificates(name string) *certificateGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["certificates.global.tsm.tanzu.vmware.com"] = name
	return &certificateGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetCertificates calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetCertificates(ctx context.Context, displayName string) (result *GlobalCertificate, err error) {
	hashedName := helper.GetHashedName("certificates.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetCertificateByName(ctx, hashedName)
}

// AddCertificates calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddCertificates(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Certificate) (result *GlobalCertificate, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("certificates.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateCertificateByName(ctx, objToCreate)
}

// DeleteCertificates calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteCertificates(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("certificates.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteCertificateByName(ctx, hashedName)
}

func (c *domainGlobalTsmV1Chainer) CertificateRequests(name string) *certificaterequestGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["certificaterequests.global.tsm.tanzu.vmware.com"] = name
	return &certificaterequestGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetCertificateRequests calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *domainGlobalTsmV1Chainer) GetCertificateRequests(ctx context.Context, displayName string) (result *GlobalCertificateRequest, err error) {
	hashedName := helper.GetHashedName("certificaterequests.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetCertificateRequestByName(ctx, hashedName)
}

// AddCertificateRequests calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *domainGlobalTsmV1Chainer) AddCertificateRequests(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.CertificateRequest) (result *GlobalCertificateRequest, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("certificaterequests.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateCertificateRequestByName(ctx, objToCreate)
}

// DeleteCertificateRequests calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *domainGlobalTsmV1Chainer) DeleteCertificateRequests(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("certificaterequests.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteCertificateRequestByName(ctx, hashedName)
}

// GetEndpointsByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetEndpointsByName(ctx context.Context, hashedName string) (*GlobalEndpoints, error) {
	key := "endpoints.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Endpoints)
		return &GlobalEndpoints{
			client:    group.client,
			Endpoints: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Endpoints().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalEndpoints{
			client:    group.client,
			Endpoints: result,
		}, nil
	}
}

// DeleteEndpointsByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteEndpointsByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Endpoints().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Endpoints().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/endpointsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateEndpointsByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateEndpointsByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Endpoints) (*GlobalEndpoints, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Endpoints().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"endpointsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"Endpoints\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalEndpoints{
		client:    group.client,
		Endpoints: result,
	}, nil
}

// UpdateEndpointsByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateEndpointsByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Endpoints) (*GlobalEndpoints, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Endpoints().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueMetadata :=
		objToUpdate.Spec.Metadata
	patchOpMetadata := PatchOp{
		Op:    "replace",
		Path:  "/spec/metadata",
		Value: patchValueMetadata,
	}
	patch = append(patch, patchOpMetadata)

	patchValueSubsets :=
		objToUpdate.Spec.Subsets
	patchOpSubsets := PatchOp{
		Op:    "replace",
		Path:  "/spec/subsets",
		Value: patchValueSubsets,
	}
	patch = append(patch, patchOpSubsets)

	patchValueGnsId :=
		objToUpdate.Spec.GnsId
	patchOpGnsId := PatchOp{
		Op:    "replace",
		Path:  "/spec/gnsId",
		Value: patchValueGnsId,
	}
	patch = append(patch, patchOpGnsId)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Endpoints().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalEndpoints{
		client:    group.client,
		Endpoints: result,
	}, nil
}

// ListEndpoints returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListEndpoints(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalEndpoints, err error) {
	key := "endpoints.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalEndpoints, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Endpoints)
			result[k] = &GlobalEndpoints{
				client:    group.client,
				Endpoints: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Endpoints().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalEndpoints, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalEndpoints{
				client:    group.client,
				Endpoints: &item,
			}
		}
	}
	return
}

type GlobalEndpoints struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Endpoints
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalEndpoints) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteEndpointsByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Endpoints = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalEndpoints) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateEndpointsByName(ctx, obj.Endpoints)
	if err != nil {
		return err
	}
	obj.Endpoints = result.Endpoints
	return nil
}

func (obj *GlobalEndpoints) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

type endpointsGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *endpointsGlobalTsmV1Chainer) Subscribe() {
	key := "endpoints.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewEndpointsInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *endpointsGlobalTsmV1Chainer) Unsubscribe() {
	key := "endpoints.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *endpointsGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "endpoints.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetEnvoyFilterByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetEnvoyFilterByName(ctx context.Context, hashedName string) (*GlobalEnvoyFilter, error) {
	key := "envoyfilters.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.EnvoyFilter)
		return &GlobalEnvoyFilter{
			client:      group.client,
			EnvoyFilter: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			EnvoyFilters().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalEnvoyFilter{
			client:      group.client,
			EnvoyFilter: result,
		}, nil
	}
}

// DeleteEnvoyFilterByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteEnvoyFilterByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		EnvoyFilters().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		EnvoyFilters().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/envoyfilterGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateEnvoyFilterByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateEnvoyFilterByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.EnvoyFilter) (*GlobalEnvoyFilter, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		EnvoyFilters().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"envoyfilterGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"EnvoyFilter\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalEnvoyFilter{
		client:      group.client,
		EnvoyFilter: result,
	}, nil
}

// UpdateEnvoyFilterByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateEnvoyFilterByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.EnvoyFilter) (*GlobalEnvoyFilter, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			EnvoyFilters().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueAnnotations :=
		objToUpdate.Spec.Annotations
	patchOpAnnotations := PatchOp{
		Op:    "replace",
		Path:  "/spec/annotations",
		Value: patchValueAnnotations,
	}
	patch = append(patch, patchOpAnnotations)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		EnvoyFilters().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalEnvoyFilter{
		client:      group.client,
		EnvoyFilter: result,
	}, nil
}

// ListEnvoyFilters returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListEnvoyFilters(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalEnvoyFilter, err error) {
	key := "envoyfilters.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalEnvoyFilter, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.EnvoyFilter)
			result[k] = &GlobalEnvoyFilter{
				client:      group.client,
				EnvoyFilter: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			EnvoyFilters().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalEnvoyFilter, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalEnvoyFilter{
				client:      group.client,
				EnvoyFilter: &item,
			}
		}
	}
	return
}

type GlobalEnvoyFilter struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.EnvoyFilter
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalEnvoyFilter) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteEnvoyFilterByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.EnvoyFilter = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalEnvoyFilter) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateEnvoyFilterByName(ctx, obj.EnvoyFilter)
	if err != nil {
		return err
	}
	obj.EnvoyFilter = result.EnvoyFilter
	return nil
}

func (obj *GlobalEnvoyFilter) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

type envoyfilterGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *envoyfilterGlobalTsmV1Chainer) Subscribe() {
	key := "envoyfilters.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewEnvoyFilterInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *envoyfilterGlobalTsmV1Chainer) Unsubscribe() {
	key := "envoyfilters.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *envoyfilterGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "envoyfilters.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetExternalAccountConfigNByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetExternalAccountConfigNByName(ctx context.Context, hashedName string) (*GlobalExternalAccountConfigN, error) {
	key := "externalaccountconfigns.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ExternalAccountConfigN)
		return &GlobalExternalAccountConfigN{
			client:                 group.client,
			ExternalAccountConfigN: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalAccountConfigNs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalExternalAccountConfigN{
			client:                 group.client,
			ExternalAccountConfigN: result,
		}, nil
	}
}

// DeleteExternalAccountConfigNByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteExternalAccountConfigNByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalAccountConfigNs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ExternalAccountConfigNs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/externalAccountsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateExternalAccountConfigNByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateExternalAccountConfigNByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalAccountConfigN) (*GlobalExternalAccountConfigN, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalAccountConfigNs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"externalAccountsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ExternalAccountConfigN\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalExternalAccountConfigN{
		client:                 group.client,
		ExternalAccountConfigN: result,
	}, nil
}

// UpdateExternalAccountConfigNByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateExternalAccountConfigNByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ExternalAccountConfigN) (*GlobalExternalAccountConfigN, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalAccountConfigNs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueConfig :=
		objToUpdate.Spec.Config
	patchOpConfig := PatchOp{
		Op:    "replace",
		Path:  "/spec/config",
		Value: patchValueConfig,
	}
	patch = append(patch, patchOpConfig)

	patchValueProxyConfig :=
		objToUpdate.Spec.ProxyConfig
	patchOpProxyConfig := PatchOp{
		Op:    "replace",
		Path:  "/spec/proxyConfig",
		Value: patchValueProxyConfig,
	}
	patch = append(patch, patchOpProxyConfig)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalAccountConfigNs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalExternalAccountConfigN{
		client:                 group.client,
		ExternalAccountConfigN: result,
	}, nil
}

// ListExternalAccountConfigNs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListExternalAccountConfigNs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalExternalAccountConfigN, err error) {
	key := "externalaccountconfigns.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalExternalAccountConfigN, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ExternalAccountConfigN)
			result[k] = &GlobalExternalAccountConfigN{
				client:                 group.client,
				ExternalAccountConfigN: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ExternalAccountConfigNs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalExternalAccountConfigN, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalExternalAccountConfigN{
				client:                 group.client,
				ExternalAccountConfigN: &item,
			}
		}
	}
	return
}

type GlobalExternalAccountConfigN struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ExternalAccountConfigN
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalExternalAccountConfigN) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteExternalAccountConfigNByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ExternalAccountConfigN = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalExternalAccountConfigN) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateExternalAccountConfigNByName(ctx, obj.ExternalAccountConfigN)
	if err != nil {
		return err
	}
	obj.ExternalAccountConfigN = result.ExternalAccountConfigN
	return nil
}

func (obj *GlobalExternalAccountConfigN) GetParent(ctx context.Context) (result *GlobalConfig, err error) {
	hashedName := helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetConfigByName(ctx, hashedName)
}

type externalaccountconfignGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *externalaccountconfignGlobalTsmV1Chainer) Subscribe() {
	key := "externalaccountconfigns.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalAccountConfigNInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *externalaccountconfignGlobalTsmV1Chainer) Unsubscribe() {
	key := "externalaccountconfigns.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *externalaccountconfignGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "externalaccountconfigns.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetExternalAuditStorageByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetExternalAuditStorageByName(ctx context.Context, hashedName string) (*GlobalExternalAuditStorage, error) {
	key := "externalauditstorages.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ExternalAuditStorage)
		return &GlobalExternalAuditStorage{
			client:               group.client,
			ExternalAuditStorage: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalAuditStorages().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalExternalAuditStorage{
			client:               group.client,
			ExternalAuditStorage: result,
		}, nil
	}
}

// DeleteExternalAuditStorageByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteExternalAuditStorageByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalAuditStorages().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ExternalAuditStorages().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/externalAuditStorageGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateExternalAuditStorageByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateExternalAuditStorageByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalAuditStorage) (*GlobalExternalAuditStorage, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalAuditStorages().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/externalAuditStorageGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "ExternalAuditStorage",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalExternalAuditStorage{
		client:               group.client,
		ExternalAuditStorage: result,
	}, nil
}

// UpdateExternalAuditStorageByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateExternalAuditStorageByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ExternalAuditStorage) (*GlobalExternalAuditStorage, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalAuditStorages().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueConfig :=
		objToUpdate.Spec.Config
	patchOpConfig := PatchOp{
		Op:    "replace",
		Path:  "/spec/config",
		Value: patchValueConfig,
	}
	patch = append(patch, patchOpConfig)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalAuditStorages().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalExternalAuditStorage{
		client:               group.client,
		ExternalAuditStorage: result,
	}, nil
}

// ListExternalAuditStorages returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListExternalAuditStorages(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalExternalAuditStorage, err error) {
	key := "externalauditstorages.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalExternalAuditStorage, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ExternalAuditStorage)
			result[k] = &GlobalExternalAuditStorage{
				client:               group.client,
				ExternalAuditStorage: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ExternalAuditStorages().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalExternalAuditStorage, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalExternalAuditStorage{
				client:               group.client,
				ExternalAuditStorage: &item,
			}
		}
	}
	return
}

type GlobalExternalAuditStorage struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ExternalAuditStorage
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalExternalAuditStorage) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteExternalAuditStorageByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ExternalAuditStorage = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalExternalAuditStorage) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateExternalAuditStorageByName(ctx, obj.ExternalAuditStorage)
	if err != nil {
		return err
	}
	obj.ExternalAuditStorage = result.ExternalAuditStorage
	return nil
}

func (obj *GlobalExternalAuditStorage) GetParent(ctx context.Context) (result *GlobalConfig, err error) {
	hashedName := helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetConfigByName(ctx, hashedName)
}

type externalauditstorageGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *externalauditstorageGlobalTsmV1Chainer) Subscribe() {
	key := "externalauditstorages.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalAuditStorageInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *externalauditstorageGlobalTsmV1Chainer) Unsubscribe() {
	key := "externalauditstorages.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *externalauditstorageGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "externalauditstorages.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetExternalDNSConfigNByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetExternalDNSConfigNByName(ctx context.Context, hashedName string) (*GlobalExternalDNSConfigN, error) {
	key := "externaldnsconfigns.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ExternalDNSConfigN)
		return &GlobalExternalDNSConfigN{
			client:             group.client,
			ExternalDNSConfigN: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalDNSConfigNs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalExternalDNSConfigN{
			client:             group.client,
			ExternalDNSConfigN: result,
		}, nil
	}
}

// DeleteExternalDNSConfigNByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteExternalDNSConfigNByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSConfigNs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSConfigNs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/externalDNSGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateExternalDNSConfigNByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateExternalDNSConfigNByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSConfigN) (*GlobalExternalDNSConfigN, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.AccountGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSConfigNs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"externalDNSGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ExternalDNSConfigN\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalExternalDNSConfigN{
		client:             group.client,
		ExternalDNSConfigN: result,
	}, nil
}

// UpdateExternalDNSConfigNByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateExternalDNSConfigNByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSConfigN) (*GlobalExternalDNSConfigN, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalDNSConfigNs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueConfig :=
		objToUpdate.Spec.Config
	patchOpConfig := PatchOp{
		Op:    "replace",
		Path:  "/spec/config",
		Value: patchValueConfig,
	}
	patch = append(patch, patchOpConfig)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSConfigNs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalExternalDNSConfigN{
		client:             group.client,
		ExternalDNSConfigN: result,
	}, nil
}

// ListExternalDNSConfigNs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListExternalDNSConfigNs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalExternalDNSConfigN, err error) {
	key := "externaldnsconfigns.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalExternalDNSConfigN, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ExternalDNSConfigN)
			result[k] = &GlobalExternalDNSConfigN{
				client:             group.client,
				ExternalDNSConfigN: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ExternalDNSConfigNs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalExternalDNSConfigN, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalExternalDNSConfigN{
				client:             group.client,
				ExternalDNSConfigN: &item,
			}
		}
	}
	return
}

type GlobalExternalDNSConfigN struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ExternalDNSConfigN
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalExternalDNSConfigN) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteExternalDNSConfigNByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ExternalDNSConfigN = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalExternalDNSConfigN) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateExternalDNSConfigNByName(ctx, obj.ExternalDNSConfigN)
	if err != nil {
		return err
	}
	obj.ExternalDNSConfigN = result.ExternalDNSConfigN
	return nil
}

func (obj *GlobalExternalDNSConfigN) GetParent(ctx context.Context) (result *GlobalConfig, err error) {
	hashedName := helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetConfigByName(ctx, hashedName)
}

// GetAccount returns link of given type
func (obj *GlobalExternalDNSConfigN) GetAccount(ctx context.Context) (
	result *GlobalExternalAccountConfigN, err error) {
	if obj.Spec.AccountGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ExternalDNSConfigN", "Account")
	}
	return obj.client.Global().GetExternalAccountConfigNByName(ctx, obj.Spec.AccountGvk.Name)
}

// LinkAccount links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalExternalDNSConfigN) LinkAccount(ctx context.Context,
	linkToAdd *GlobalExternalAccountConfigN) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/accountGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "ExternalAccountConfigN",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ExternalDNSConfigNs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ExternalDNSConfigN = result
	return nil
}

// UnlinkAccount unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalExternalDNSConfigN) UnlinkAccount(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/accountGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ExternalDNSConfigNs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ExternalDNSConfigN = result
	return nil

}

type externaldnsconfignGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *externaldnsconfignGlobalTsmV1Chainer) Subscribe() {
	key := "externaldnsconfigns.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalDNSConfigNInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *externaldnsconfignGlobalTsmV1Chainer) Unsubscribe() {
	key := "externaldnsconfigns.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *externaldnsconfignGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "externaldnsconfigns.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetExternalDNSInventoryHealthCheckByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetExternalDNSInventoryHealthCheckByName(ctx context.Context, hashedName string) (*GlobalExternalDNSInventoryHealthCheck, error) {
	key := "externaldnsinventoryhealthchecks.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryHealthCheck)
		return &GlobalExternalDNSInventoryHealthCheck{
			client:                          group.client,
			ExternalDNSInventoryHealthCheck: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalDNSInventoryHealthChecks().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalExternalDNSInventoryHealthCheck{
			client:                          group.client,
			ExternalDNSInventoryHealthCheck: result,
		}, nil
	}
}

// DeleteExternalDNSInventoryHealthCheckByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteExternalDNSInventoryHealthCheckByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventoryHealthChecks().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventoryHealthChecks().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/healthChecksGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["externaldnsinventories.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("externaldnsinventories.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventories().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateExternalDNSInventoryHealthCheckByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateExternalDNSInventoryHealthCheckByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryHealthCheck) (*GlobalExternalDNSInventoryHealthCheck, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventoryHealthChecks().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["externaldnsinventories.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("externaldnsinventories.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"healthChecksGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ExternalDNSInventoryHealthCheck\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventories().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalExternalDNSInventoryHealthCheck{
		client:                          group.client,
		ExternalDNSInventoryHealthCheck: result,
	}, nil
}

// UpdateExternalDNSInventoryHealthCheckByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateExternalDNSInventoryHealthCheckByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryHealthCheck) (*GlobalExternalDNSInventoryHealthCheck, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalDNSInventoryHealthChecks().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueProtocol :=
		objToUpdate.Spec.Protocol
	patchOpProtocol := PatchOp{
		Op:    "replace",
		Path:  "/spec/protocol",
		Value: patchValueProtocol,
	}
	patch = append(patch, patchOpProtocol)

	patchValuePort :=
		objToUpdate.Spec.Port
	patchOpPort := PatchOp{
		Op:    "replace",
		Path:  "/spec/port",
		Value: patchValuePort,
	}
	patch = append(patch, patchOpPort)

	patchValuePath :=
		objToUpdate.Spec.Path
	patchOpPath := PatchOp{
		Op:    "replace",
		Path:  "/spec/path",
		Value: patchValuePath,
	}
	patch = append(patch, patchOpPath)

	patchValueHealthThreshold :=
		objToUpdate.Spec.HealthThreshold
	patchOpHealthThreshold := PatchOp{
		Op:    "replace",
		Path:  "/spec/healthThreshold",
		Value: patchValueHealthThreshold,
	}
	patch = append(patch, patchOpHealthThreshold)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventoryHealthChecks().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalExternalDNSInventoryHealthCheck{
		client:                          group.client,
		ExternalDNSInventoryHealthCheck: result,
	}, nil
}

// ListExternalDNSInventoryHealthChecks returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListExternalDNSInventoryHealthChecks(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalExternalDNSInventoryHealthCheck, err error) {
	key := "externaldnsinventoryhealthchecks.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalExternalDNSInventoryHealthCheck, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryHealthCheck)
			result[k] = &GlobalExternalDNSInventoryHealthCheck{
				client:                          group.client,
				ExternalDNSInventoryHealthCheck: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ExternalDNSInventoryHealthChecks().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalExternalDNSInventoryHealthCheck, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalExternalDNSInventoryHealthCheck{
				client:                          group.client,
				ExternalDNSInventoryHealthCheck: &item,
			}
		}
	}
	return
}

type GlobalExternalDNSInventoryHealthCheck struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryHealthCheck
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalExternalDNSInventoryHealthCheck) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteExternalDNSInventoryHealthCheckByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ExternalDNSInventoryHealthCheck = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalExternalDNSInventoryHealthCheck) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateExternalDNSInventoryHealthCheckByName(ctx, obj.ExternalDNSInventoryHealthCheck)
	if err != nil {
		return err
	}
	obj.ExternalDNSInventoryHealthCheck = result.ExternalDNSInventoryHealthCheck
	return nil
}

func (obj *GlobalExternalDNSInventoryHealthCheck) GetParent(ctx context.Context) (result *GlobalExternalDNSInventory, err error) {
	hashedName := helper.GetHashedName("externaldnsinventories.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["externaldnsinventories.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetExternalDNSInventoryByName(ctx, hashedName)
}

type externaldnsinventoryhealthcheckGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *externaldnsinventoryhealthcheckGlobalTsmV1Chainer) Subscribe() {
	key := "externaldnsinventoryhealthchecks.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalDNSInventoryHealthCheckInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *externaldnsinventoryhealthcheckGlobalTsmV1Chainer) Unsubscribe() {
	key := "externaldnsinventoryhealthchecks.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *externaldnsinventoryhealthcheckGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "externaldnsinventoryhealthchecks.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetExternalDNSInventoryPrimaryDomainByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetExternalDNSInventoryPrimaryDomainByName(ctx context.Context, hashedName string) (*GlobalExternalDNSInventoryPrimaryDomain, error) {
	key := "externaldnsinventoryprimarydomains.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryPrimaryDomain)
		return &GlobalExternalDNSInventoryPrimaryDomain{
			client:                            group.client,
			ExternalDNSInventoryPrimaryDomain: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalDNSInventoryPrimaryDomains().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalExternalDNSInventoryPrimaryDomain{
			client:                            group.client,
			ExternalDNSInventoryPrimaryDomain: result,
		}, nil
	}
}

// DeleteExternalDNSInventoryPrimaryDomainByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteExternalDNSInventoryPrimaryDomainByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventoryPrimaryDomains().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.DnsRecordsGvk {
		err := group.client.
			Global().DeleteExternalDNSInventoryRecordByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventoryPrimaryDomains().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/primaryDomainsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["externaldnsinventories.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("externaldnsinventories.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventories().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateExternalDNSInventoryPrimaryDomainByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateExternalDNSInventoryPrimaryDomainByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryPrimaryDomain) (*GlobalExternalDNSInventoryPrimaryDomain, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.DnsRecordsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventoryPrimaryDomains().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["externaldnsinventories.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("externaldnsinventories.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"primaryDomainsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ExternalDNSInventoryPrimaryDomain\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventories().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalExternalDNSInventoryPrimaryDomain{
		client:                            group.client,
		ExternalDNSInventoryPrimaryDomain: result,
	}, nil
}

// UpdateExternalDNSInventoryPrimaryDomainByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateExternalDNSInventoryPrimaryDomainByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryPrimaryDomain) (*GlobalExternalDNSInventoryPrimaryDomain, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalDNSInventoryPrimaryDomains().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueRegion :=
		objToUpdate.Spec.Region
	patchOpRegion := PatchOp{
		Op:    "replace",
		Path:  "/spec/region",
		Value: patchValueRegion,
	}
	patch = append(patch, patchOpRegion)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventoryPrimaryDomains().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalExternalDNSInventoryPrimaryDomain{
		client:                            group.client,
		ExternalDNSInventoryPrimaryDomain: result,
	}, nil
}

// ListExternalDNSInventoryPrimaryDomains returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListExternalDNSInventoryPrimaryDomains(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalExternalDNSInventoryPrimaryDomain, err error) {
	key := "externaldnsinventoryprimarydomains.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalExternalDNSInventoryPrimaryDomain, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryPrimaryDomain)
			result[k] = &GlobalExternalDNSInventoryPrimaryDomain{
				client:                            group.client,
				ExternalDNSInventoryPrimaryDomain: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ExternalDNSInventoryPrimaryDomains().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalExternalDNSInventoryPrimaryDomain, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalExternalDNSInventoryPrimaryDomain{
				client:                            group.client,
				ExternalDNSInventoryPrimaryDomain: &item,
			}
		}
	}
	return
}

type GlobalExternalDNSInventoryPrimaryDomain struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryPrimaryDomain
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalExternalDNSInventoryPrimaryDomain) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteExternalDNSInventoryPrimaryDomainByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ExternalDNSInventoryPrimaryDomain = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalExternalDNSInventoryPrimaryDomain) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateExternalDNSInventoryPrimaryDomainByName(ctx, obj.ExternalDNSInventoryPrimaryDomain)
	if err != nil {
		return err
	}
	obj.ExternalDNSInventoryPrimaryDomain = result.ExternalDNSInventoryPrimaryDomain
	return nil
}

func (obj *GlobalExternalDNSInventoryPrimaryDomain) GetParent(ctx context.Context) (result *GlobalExternalDNSInventory, err error) {
	hashedName := helper.GetHashedName("externaldnsinventories.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["externaldnsinventories.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetExternalDNSInventoryByName(ctx, hashedName)
}

// GetAllDnsRecords returns all children of given type
func (obj *GlobalExternalDNSInventoryPrimaryDomain) GetAllDnsRecords(ctx context.Context) (
	result []*GlobalExternalDNSInventoryRecord, err error) {
	result = make([]*GlobalExternalDNSInventoryRecord, 0, len(obj.Spec.DnsRecordsGvk))
	for _, v := range obj.Spec.DnsRecordsGvk {
		l, err := obj.client.Global().GetExternalDNSInventoryRecordByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetDnsRecords returns child which has given displayName
func (obj *GlobalExternalDNSInventoryPrimaryDomain) GetDnsRecords(ctx context.Context,
	displayName string) (result *GlobalExternalDNSInventoryRecord, err error) {
	l, ok := obj.Spec.DnsRecordsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ExternalDNSInventoryPrimaryDomain", "DnsRecords", displayName)
	}
	result, err = obj.client.Global().GetExternalDNSInventoryRecordByName(ctx, l.Name)
	return
}

// AddDnsRecords calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalExternalDNSInventoryPrimaryDomain) AddDnsRecords(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryRecord) (result *GlobalExternalDNSInventoryRecord, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["externaldnsinventoryprimarydomains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["externaldnsinventoryprimarydomains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateExternalDNSInventoryRecordByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetExternalDNSInventoryPrimaryDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ExternalDNSInventoryPrimaryDomain = updatedObj.ExternalDNSInventoryPrimaryDomain
	}
	return
}

// DeleteDnsRecords calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalExternalDNSInventoryPrimaryDomain) DeleteDnsRecords(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.DnsRecordsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ExternalDNSInventoryPrimaryDomain", "DnsRecords", displayName)
	}
	err = obj.client.Global().DeleteExternalDNSInventoryRecordByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetExternalDNSInventoryPrimaryDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.ExternalDNSInventoryPrimaryDomain = updatedObj.ExternalDNSInventoryPrimaryDomain
	}
	return
}

type externaldnsinventoryprimarydomainGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *externaldnsinventoryprimarydomainGlobalTsmV1Chainer) Subscribe() {
	key := "externaldnsinventoryprimarydomains.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalDNSInventoryPrimaryDomainInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *externaldnsinventoryprimarydomainGlobalTsmV1Chainer) Unsubscribe() {
	key := "externaldnsinventoryprimarydomains.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *externaldnsinventoryprimarydomainGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "externaldnsinventoryprimarydomains.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *externaldnsinventoryprimarydomainGlobalTsmV1Chainer) DnsRecords(name string) *externaldnsinventoryrecordGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["externaldnsinventoryrecords.global.tsm.tanzu.vmware.com"] = name
	return &externaldnsinventoryrecordGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetDnsRecords calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *externaldnsinventoryprimarydomainGlobalTsmV1Chainer) GetDnsRecords(ctx context.Context, displayName string) (result *GlobalExternalDNSInventoryRecord, err error) {
	hashedName := helper.GetHashedName("externaldnsinventoryrecords.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetExternalDNSInventoryRecordByName(ctx, hashedName)
}

// AddDnsRecords calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *externaldnsinventoryprimarydomainGlobalTsmV1Chainer) AddDnsRecords(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryRecord) (result *GlobalExternalDNSInventoryRecord, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("externaldnsinventoryrecords.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateExternalDNSInventoryRecordByName(ctx, objToCreate)
}

// DeleteDnsRecords calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *externaldnsinventoryprimarydomainGlobalTsmV1Chainer) DeleteDnsRecords(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("externaldnsinventoryrecords.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteExternalDNSInventoryRecordByName(ctx, hashedName)
}

// GetExternalDNSInventoryRecordByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetExternalDNSInventoryRecordByName(ctx context.Context, hashedName string) (*GlobalExternalDNSInventoryRecord, error) {
	key := "externaldnsinventoryrecords.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryRecord)
		return &GlobalExternalDNSInventoryRecord{
			client:                     group.client,
			ExternalDNSInventoryRecord: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalDNSInventoryRecords().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalExternalDNSInventoryRecord{
			client:                     group.client,
			ExternalDNSInventoryRecord: result,
		}, nil
	}
}

// DeleteExternalDNSInventoryRecordByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteExternalDNSInventoryRecordByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventoryRecords().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventoryRecords().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/dnsRecordsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["externaldnsinventoryprimarydomains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("externaldnsinventoryprimarydomains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventoryPrimaryDomains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateExternalDNSInventoryRecordByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateExternalDNSInventoryRecordByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryRecord) (*GlobalExternalDNSInventoryRecord, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.HealthCheckGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventoryRecords().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["externaldnsinventoryprimarydomains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("externaldnsinventoryprimarydomains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"dnsRecordsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ExternalDNSInventoryRecord\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventoryPrimaryDomains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalExternalDNSInventoryRecord{
		client:                     group.client,
		ExternalDNSInventoryRecord: result,
	}, nil
}

// UpdateExternalDNSInventoryRecordByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateExternalDNSInventoryRecordByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryRecord) (*GlobalExternalDNSInventoryRecord, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalDNSInventoryRecords().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDnsRecordType :=
		objToUpdate.Spec.DnsRecordType
	patchOpDnsRecordType := PatchOp{
		Op:    "replace",
		Path:  "/spec/dnsRecordType",
		Value: patchValueDnsRecordType,
	}
	patch = append(patch, patchOpDnsRecordType)

	patchValueTtl :=
		objToUpdate.Spec.Ttl
	patchOpTtl := PatchOp{
		Op:    "replace",
		Path:  "/spec/ttl",
		Value: patchValueTtl,
	}
	patch = append(patch, patchOpTtl)

	patchValueValue :=
		objToUpdate.Spec.Value
	patchOpValue := PatchOp{
		Op:    "replace",
		Path:  "/spec/value",
		Value: patchValueValue,
	}
	patch = append(patch, patchOpValue)

	patchValueWeight :=
		objToUpdate.Spec.Weight
	patchOpWeight := PatchOp{
		Op:    "replace",
		Path:  "/spec/weight",
		Value: patchValueWeight,
	}
	patch = append(patch, patchOpWeight)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventoryRecords().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalExternalDNSInventoryRecord{
		client:                     group.client,
		ExternalDNSInventoryRecord: result,
	}, nil
}

// ListExternalDNSInventoryRecords returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListExternalDNSInventoryRecords(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalExternalDNSInventoryRecord, err error) {
	key := "externaldnsinventoryrecords.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalExternalDNSInventoryRecord, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryRecord)
			result[k] = &GlobalExternalDNSInventoryRecord{
				client:                     group.client,
				ExternalDNSInventoryRecord: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ExternalDNSInventoryRecords().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalExternalDNSInventoryRecord, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalExternalDNSInventoryRecord{
				client:                     group.client,
				ExternalDNSInventoryRecord: &item,
			}
		}
	}
	return
}

type GlobalExternalDNSInventoryRecord struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryRecord
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalExternalDNSInventoryRecord) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteExternalDNSInventoryRecordByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ExternalDNSInventoryRecord = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalExternalDNSInventoryRecord) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateExternalDNSInventoryRecordByName(ctx, obj.ExternalDNSInventoryRecord)
	if err != nil {
		return err
	}
	obj.ExternalDNSInventoryRecord = result.ExternalDNSInventoryRecord
	return nil
}

func (obj *GlobalExternalDNSInventoryRecord) GetParent(ctx context.Context) (result *GlobalExternalDNSInventoryPrimaryDomain, err error) {
	hashedName := helper.GetHashedName("externaldnsinventoryprimarydomains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["externaldnsinventoryprimarydomains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetExternalDNSInventoryPrimaryDomainByName(ctx, hashedName)
}

// GetHealthCheck returns link of given type
func (obj *GlobalExternalDNSInventoryRecord) GetHealthCheck(ctx context.Context) (
	result *GlobalExternalDNSInventoryHealthCheck, err error) {
	if obj.Spec.HealthCheckGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ExternalDNSInventoryRecord", "HealthCheck")
	}
	return obj.client.Global().GetExternalDNSInventoryHealthCheckByName(ctx, obj.Spec.HealthCheckGvk.Name)
}

// LinkHealthCheck links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalExternalDNSInventoryRecord) LinkHealthCheck(ctx context.Context,
	linkToAdd *GlobalExternalDNSInventoryHealthCheck) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/healthCheckGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "ExternalDNSInventoryHealthCheck",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ExternalDNSInventoryRecords().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ExternalDNSInventoryRecord = result
	return nil
}

// UnlinkHealthCheck unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalExternalDNSInventoryRecord) UnlinkHealthCheck(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/healthCheckGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ExternalDNSInventoryRecords().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ExternalDNSInventoryRecord = result
	return nil

}

type externaldnsinventoryrecordGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *externaldnsinventoryrecordGlobalTsmV1Chainer) Subscribe() {
	key := "externaldnsinventoryrecords.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalDNSInventoryRecordInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *externaldnsinventoryrecordGlobalTsmV1Chainer) Unsubscribe() {
	key := "externaldnsinventoryrecords.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *externaldnsinventoryrecordGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "externaldnsinventoryrecords.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetExternalDNSInventoryZoneByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetExternalDNSInventoryZoneByName(ctx context.Context, hashedName string) (*GlobalExternalDNSInventoryZone, error) {
	key := "externaldnsinventoryzones.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryZone)
		return &GlobalExternalDNSInventoryZone{
			client:                   group.client,
			ExternalDNSInventoryZone: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalDNSInventoryZones().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalExternalDNSInventoryZone{
			client:                   group.client,
			ExternalDNSInventoryZone: result,
		}, nil
	}
}

// DeleteExternalDNSInventoryZoneByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteExternalDNSInventoryZoneByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventoryZones().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventoryZones().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/zonesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["externaldnsinventories.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("externaldnsinventories.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventories().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateExternalDNSInventoryZoneByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateExternalDNSInventoryZoneByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryZone) (*GlobalExternalDNSInventoryZone, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.PrimaryDomainsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventoryZones().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["externaldnsinventories.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("externaldnsinventories.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"zonesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ExternalDNSInventoryZone\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventories().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalExternalDNSInventoryZone{
		client:                   group.client,
		ExternalDNSInventoryZone: result,
	}, nil
}

// UpdateExternalDNSInventoryZoneByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateExternalDNSInventoryZoneByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryZone) (*GlobalExternalDNSInventoryZone, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalDNSInventoryZones().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueRecords :=
		objToUpdate.Spec.Records
	patchOpRecords := PatchOp{
		Op:    "replace",
		Path:  "/spec/records",
		Value: patchValueRecords,
	}
	patch = append(patch, patchOpRecords)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventoryZones().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalExternalDNSInventoryZone{
		client:                   group.client,
		ExternalDNSInventoryZone: result,
	}, nil
}

// ListExternalDNSInventoryZones returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListExternalDNSInventoryZones(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalExternalDNSInventoryZone, err error) {
	key := "externaldnsinventoryzones.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalExternalDNSInventoryZone, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryZone)
			result[k] = &GlobalExternalDNSInventoryZone{
				client:                   group.client,
				ExternalDNSInventoryZone: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ExternalDNSInventoryZones().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalExternalDNSInventoryZone, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalExternalDNSInventoryZone{
				client:                   group.client,
				ExternalDNSInventoryZone: &item,
			}
		}
	}
	return
}

type GlobalExternalDNSInventoryZone struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryZone
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalExternalDNSInventoryZone) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteExternalDNSInventoryZoneByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ExternalDNSInventoryZone = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalExternalDNSInventoryZone) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateExternalDNSInventoryZoneByName(ctx, obj.ExternalDNSInventoryZone)
	if err != nil {
		return err
	}
	obj.ExternalDNSInventoryZone = result.ExternalDNSInventoryZone
	return nil
}

func (obj *GlobalExternalDNSInventoryZone) GetParent(ctx context.Context) (result *GlobalExternalDNSInventory, err error) {
	hashedName := helper.GetHashedName("externaldnsinventories.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["externaldnsinventories.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetExternalDNSInventoryByName(ctx, hashedName)
}

// GetAllPrimaryDomains returns all links of given type
func (obj *GlobalExternalDNSInventoryZone) GetAllPrimaryDomains(ctx context.Context) (
	result []*GlobalExternalDNSInventoryPrimaryDomain, err error) {
	result = make([]*GlobalExternalDNSInventoryPrimaryDomain, 0, len(obj.Spec.PrimaryDomainsGvk))
	for _, v := range obj.Spec.PrimaryDomainsGvk {
		l, err := obj.client.Global().GetExternalDNSInventoryPrimaryDomainByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetPrimaryDomains returns link which has given displayName
func (obj *GlobalExternalDNSInventoryZone) GetPrimaryDomains(ctx context.Context,
	displayName string) (result *GlobalExternalDNSInventoryPrimaryDomain, err error) {
	l, ok := obj.Spec.PrimaryDomainsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ExternalDNSInventoryZone", "PrimaryDomains", displayName)
	}
	result, err = obj.client.Global().GetExternalDNSInventoryPrimaryDomainByName(ctx, l.Name)
	return
}

// LinkPrimaryDomains links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalExternalDNSInventoryZone) LinkPrimaryDomains(ctx context.Context,
	linkToAdd *GlobalExternalDNSInventoryPrimaryDomain) error {

	payload := "{\"spec\": {\"primaryDomainsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ExternalDNSInventoryPrimaryDomain\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ExternalDNSInventoryZones().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ExternalDNSInventoryZone = result
	return nil
}

// UnlinkPrimaryDomains unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalExternalDNSInventoryZone) UnlinkPrimaryDomains(ctx context.Context,
	linkToRemove *GlobalExternalDNSInventoryPrimaryDomain) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/primaryDomainsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ExternalDNSInventoryZones().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ExternalDNSInventoryZone = result
	return nil

}

type externaldnsinventoryzoneGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *externaldnsinventoryzoneGlobalTsmV1Chainer) Subscribe() {
	key := "externaldnsinventoryzones.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalDNSInventoryZoneInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *externaldnsinventoryzoneGlobalTsmV1Chainer) Unsubscribe() {
	key := "externaldnsinventoryzones.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *externaldnsinventoryzoneGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "externaldnsinventoryzones.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetExternalDNSInventoryByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetExternalDNSInventoryByName(ctx context.Context, hashedName string) (*GlobalExternalDNSInventory, error) {
	key := "externaldnsinventories.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventory)
		return &GlobalExternalDNSInventory{
			client:               group.client,
			ExternalDNSInventory: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalDNSInventories().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalExternalDNSInventory{
			client:               group.client,
			ExternalDNSInventory: result,
		}, nil
	}
}

// DeleteExternalDNSInventoryByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteExternalDNSInventoryByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventories().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.ZonesGvk {
		err := group.client.
			Global().DeleteExternalDNSInventoryZoneByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.PrimaryDomainsGvk {
		err := group.client.
			Global().DeleteExternalDNSInventoryPrimaryDomainByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.HealthChecksGvk {
		err := group.client.
			Global().DeleteExternalDNSInventoryHealthCheckByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventories().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/externalDNSGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["inventories.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("inventories.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Inventories().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateExternalDNSInventoryByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateExternalDNSInventoryByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventory) (*GlobalExternalDNSInventory, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ZonesGvk = nil
	objToCreate.Spec.PrimaryDomainsGvk = nil
	objToCreate.Spec.HealthChecksGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventories().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["inventories.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("inventories.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"externalDNSGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ExternalDNSInventory\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Inventories().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalExternalDNSInventory{
		client:               group.client,
		ExternalDNSInventory: result,
	}, nil
}

// UpdateExternalDNSInventoryByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateExternalDNSInventoryByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventory) (*GlobalExternalDNSInventory, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalDNSInventories().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	if objToUpdate.Spec.EnabledForProjects != nil {
		patchValueEnabledForProjects :=
			objToUpdate.Spec.EnabledForProjects
		patchOpEnabledForProjects := PatchOp{
			Op:    "replace",
			Path:  "/spec/enabledForProjects",
			Value: patchValueEnabledForProjects,
		}
		patch = append(patch, patchOpEnabledForProjects)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSInventories().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalExternalDNSInventory{
		client:               group.client,
		ExternalDNSInventory: result,
	}, nil
}

// ListExternalDNSInventories returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListExternalDNSInventories(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalExternalDNSInventory, err error) {
	key := "externaldnsinventories.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalExternalDNSInventory, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventory)
			result[k] = &GlobalExternalDNSInventory{
				client:               group.client,
				ExternalDNSInventory: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ExternalDNSInventories().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalExternalDNSInventory, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalExternalDNSInventory{
				client:               group.client,
				ExternalDNSInventory: &item,
			}
		}
	}
	return
}

type GlobalExternalDNSInventory struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventory
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalExternalDNSInventory) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteExternalDNSInventoryByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ExternalDNSInventory = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalExternalDNSInventory) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateExternalDNSInventoryByName(ctx, obj.ExternalDNSInventory)
	if err != nil {
		return err
	}
	obj.ExternalDNSInventory = result.ExternalDNSInventory
	return nil
}

func (obj *GlobalExternalDNSInventory) GetParent(ctx context.Context) (result *GlobalInventory, err error) {
	hashedName := helper.GetHashedName("inventories.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["inventories.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetInventoryByName(ctx, hashedName)
}

// GetAllZones returns all children of given type
func (obj *GlobalExternalDNSInventory) GetAllZones(ctx context.Context) (
	result []*GlobalExternalDNSInventoryZone, err error) {
	result = make([]*GlobalExternalDNSInventoryZone, 0, len(obj.Spec.ZonesGvk))
	for _, v := range obj.Spec.ZonesGvk {
		l, err := obj.client.Global().GetExternalDNSInventoryZoneByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetZones returns child which has given displayName
func (obj *GlobalExternalDNSInventory) GetZones(ctx context.Context,
	displayName string) (result *GlobalExternalDNSInventoryZone, err error) {
	l, ok := obj.Spec.ZonesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ExternalDNSInventory", "Zones", displayName)
	}
	result, err = obj.client.Global().GetExternalDNSInventoryZoneByName(ctx, l.Name)
	return
}

// AddZones calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalExternalDNSInventory) AddZones(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryZone) (result *GlobalExternalDNSInventoryZone, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["externaldnsinventories.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["externaldnsinventories.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateExternalDNSInventoryZoneByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetExternalDNSInventoryByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ExternalDNSInventory = updatedObj.ExternalDNSInventory
	}
	return
}

// DeleteZones calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalExternalDNSInventory) DeleteZones(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ZonesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ExternalDNSInventory", "Zones", displayName)
	}
	err = obj.client.Global().DeleteExternalDNSInventoryZoneByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetExternalDNSInventoryByName(ctx, obj.GetName())
	if err == nil {
		obj.ExternalDNSInventory = updatedObj.ExternalDNSInventory
	}
	return
}

// GetAllPrimaryDomains returns all children of given type
func (obj *GlobalExternalDNSInventory) GetAllPrimaryDomains(ctx context.Context) (
	result []*GlobalExternalDNSInventoryPrimaryDomain, err error) {
	result = make([]*GlobalExternalDNSInventoryPrimaryDomain, 0, len(obj.Spec.PrimaryDomainsGvk))
	for _, v := range obj.Spec.PrimaryDomainsGvk {
		l, err := obj.client.Global().GetExternalDNSInventoryPrimaryDomainByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetPrimaryDomains returns child which has given displayName
func (obj *GlobalExternalDNSInventory) GetPrimaryDomains(ctx context.Context,
	displayName string) (result *GlobalExternalDNSInventoryPrimaryDomain, err error) {
	l, ok := obj.Spec.PrimaryDomainsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ExternalDNSInventory", "PrimaryDomains", displayName)
	}
	result, err = obj.client.Global().GetExternalDNSInventoryPrimaryDomainByName(ctx, l.Name)
	return
}

// AddPrimaryDomains calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalExternalDNSInventory) AddPrimaryDomains(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryPrimaryDomain) (result *GlobalExternalDNSInventoryPrimaryDomain, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["externaldnsinventories.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["externaldnsinventories.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateExternalDNSInventoryPrimaryDomainByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetExternalDNSInventoryByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ExternalDNSInventory = updatedObj.ExternalDNSInventory
	}
	return
}

// DeletePrimaryDomains calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalExternalDNSInventory) DeletePrimaryDomains(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.PrimaryDomainsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ExternalDNSInventory", "PrimaryDomains", displayName)
	}
	err = obj.client.Global().DeleteExternalDNSInventoryPrimaryDomainByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetExternalDNSInventoryByName(ctx, obj.GetName())
	if err == nil {
		obj.ExternalDNSInventory = updatedObj.ExternalDNSInventory
	}
	return
}

// GetAllHealthChecks returns all children of given type
func (obj *GlobalExternalDNSInventory) GetAllHealthChecks(ctx context.Context) (
	result []*GlobalExternalDNSInventoryHealthCheck, err error) {
	result = make([]*GlobalExternalDNSInventoryHealthCheck, 0, len(obj.Spec.HealthChecksGvk))
	for _, v := range obj.Spec.HealthChecksGvk {
		l, err := obj.client.Global().GetExternalDNSInventoryHealthCheckByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetHealthChecks returns child which has given displayName
func (obj *GlobalExternalDNSInventory) GetHealthChecks(ctx context.Context,
	displayName string) (result *GlobalExternalDNSInventoryHealthCheck, err error) {
	l, ok := obj.Spec.HealthChecksGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ExternalDNSInventory", "HealthChecks", displayName)
	}
	result, err = obj.client.Global().GetExternalDNSInventoryHealthCheckByName(ctx, l.Name)
	return
}

// AddHealthChecks calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalExternalDNSInventory) AddHealthChecks(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryHealthCheck) (result *GlobalExternalDNSInventoryHealthCheck, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["externaldnsinventories.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["externaldnsinventories.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateExternalDNSInventoryHealthCheckByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetExternalDNSInventoryByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ExternalDNSInventory = updatedObj.ExternalDNSInventory
	}
	return
}

// DeleteHealthChecks calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalExternalDNSInventory) DeleteHealthChecks(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.HealthChecksGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ExternalDNSInventory", "HealthChecks", displayName)
	}
	err = obj.client.Global().DeleteExternalDNSInventoryHealthCheckByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetExternalDNSInventoryByName(ctx, obj.GetName())
	if err == nil {
		obj.ExternalDNSInventory = updatedObj.ExternalDNSInventory
	}
	return
}

type externaldnsinventoryGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *externaldnsinventoryGlobalTsmV1Chainer) Subscribe() {
	key := "externaldnsinventories.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalDNSInventoryInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *externaldnsinventoryGlobalTsmV1Chainer) Unsubscribe() {
	key := "externaldnsinventories.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *externaldnsinventoryGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "externaldnsinventories.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *externaldnsinventoryGlobalTsmV1Chainer) Zones(name string) *externaldnsinventoryzoneGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["externaldnsinventoryzones.global.tsm.tanzu.vmware.com"] = name
	return &externaldnsinventoryzoneGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetZones calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *externaldnsinventoryGlobalTsmV1Chainer) GetZones(ctx context.Context, displayName string) (result *GlobalExternalDNSInventoryZone, err error) {
	hashedName := helper.GetHashedName("externaldnsinventoryzones.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetExternalDNSInventoryZoneByName(ctx, hashedName)
}

// AddZones calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *externaldnsinventoryGlobalTsmV1Chainer) AddZones(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryZone) (result *GlobalExternalDNSInventoryZone, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("externaldnsinventoryzones.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateExternalDNSInventoryZoneByName(ctx, objToCreate)
}

// DeleteZones calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *externaldnsinventoryGlobalTsmV1Chainer) DeleteZones(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("externaldnsinventoryzones.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteExternalDNSInventoryZoneByName(ctx, hashedName)
}

func (c *externaldnsinventoryGlobalTsmV1Chainer) PrimaryDomains(name string) *externaldnsinventoryprimarydomainGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["externaldnsinventoryprimarydomains.global.tsm.tanzu.vmware.com"] = name
	return &externaldnsinventoryprimarydomainGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetPrimaryDomains calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *externaldnsinventoryGlobalTsmV1Chainer) GetPrimaryDomains(ctx context.Context, displayName string) (result *GlobalExternalDNSInventoryPrimaryDomain, err error) {
	hashedName := helper.GetHashedName("externaldnsinventoryprimarydomains.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetExternalDNSInventoryPrimaryDomainByName(ctx, hashedName)
}

// AddPrimaryDomains calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *externaldnsinventoryGlobalTsmV1Chainer) AddPrimaryDomains(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryPrimaryDomain) (result *GlobalExternalDNSInventoryPrimaryDomain, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("externaldnsinventoryprimarydomains.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateExternalDNSInventoryPrimaryDomainByName(ctx, objToCreate)
}

// DeletePrimaryDomains calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *externaldnsinventoryGlobalTsmV1Chainer) DeletePrimaryDomains(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("externaldnsinventoryprimarydomains.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteExternalDNSInventoryPrimaryDomainByName(ctx, hashedName)
}

func (c *externaldnsinventoryGlobalTsmV1Chainer) HealthChecks(name string) *externaldnsinventoryhealthcheckGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["externaldnsinventoryhealthchecks.global.tsm.tanzu.vmware.com"] = name
	return &externaldnsinventoryhealthcheckGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetHealthChecks calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *externaldnsinventoryGlobalTsmV1Chainer) GetHealthChecks(ctx context.Context, displayName string) (result *GlobalExternalDNSInventoryHealthCheck, err error) {
	hashedName := helper.GetHashedName("externaldnsinventoryhealthchecks.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetExternalDNSInventoryHealthCheckByName(ctx, hashedName)
}

// AddHealthChecks calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *externaldnsinventoryGlobalTsmV1Chainer) AddHealthChecks(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventoryHealthCheck) (result *GlobalExternalDNSInventoryHealthCheck, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("externaldnsinventoryhealthchecks.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateExternalDNSInventoryHealthCheckByName(ctx, objToCreate)
}

// DeleteHealthChecks calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *externaldnsinventoryGlobalTsmV1Chainer) DeleteHealthChecks(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("externaldnsinventoryhealthchecks.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteExternalDNSInventoryHealthCheckByName(ctx, hashedName)
}

// GetExternalDNSRuntimeEndpointByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetExternalDNSRuntimeEndpointByName(ctx context.Context, hashedName string) (*GlobalExternalDNSRuntimeEndpoint, error) {
	key := "externaldnsruntimeendpoints.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntimeEndpoint)
		return &GlobalExternalDNSRuntimeEndpoint{
			client:                     group.client,
			ExternalDNSRuntimeEndpoint: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalDNSRuntimeEndpoints().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalExternalDNSRuntimeEndpoint{
			client:                     group.client,
			ExternalDNSRuntimeEndpoint: result,
		}, nil
	}
}

// DeleteExternalDNSRuntimeEndpointByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteExternalDNSRuntimeEndpointByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSRuntimeEndpoints().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSRuntimeEndpoints().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/endpointsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["externaldnsruntimesubdomains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("externaldnsruntimesubdomains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSRuntimeSubdomains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateExternalDNSRuntimeEndpointByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateExternalDNSRuntimeEndpointByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntimeEndpoint) (*GlobalExternalDNSRuntimeEndpoint, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSRuntimeEndpoints().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["externaldnsruntimesubdomains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("externaldnsruntimesubdomains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"endpointsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ExternalDNSRuntimeEndpoint\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSRuntimeSubdomains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalExternalDNSRuntimeEndpoint{
		client:                     group.client,
		ExternalDNSRuntimeEndpoint: result,
	}, nil
}

// UpdateExternalDNSRuntimeEndpointByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateExternalDNSRuntimeEndpointByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntimeEndpoint) (*GlobalExternalDNSRuntimeEndpoint, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalDNSRuntimeEndpoints().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueWeight :=
		objToUpdate.Spec.Weight
	patchOpWeight := PatchOp{
		Op:    "replace",
		Path:  "/spec/weight",
		Value: patchValueWeight,
	}
	patch = append(patch, patchOpWeight)

	patchValueActive :=
		objToUpdate.Spec.Active
	patchOpActive := PatchOp{
		Op:    "replace",
		Path:  "/spec/active",
		Value: patchValueActive,
	}
	patch = append(patch, patchOpActive)

	patchValueGnsVersion :=
		objToUpdate.Spec.GnsVersion
	patchOpGnsVersion := PatchOp{
		Op:    "replace",
		Path:  "/spec/gnsVersion",
		Value: patchValueGnsVersion,
	}
	patch = append(patch, patchOpGnsVersion)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSRuntimeEndpoints().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalExternalDNSRuntimeEndpoint{
		client:                     group.client,
		ExternalDNSRuntimeEndpoint: result,
	}, nil
}

// ListExternalDNSRuntimeEndpoints returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListExternalDNSRuntimeEndpoints(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalExternalDNSRuntimeEndpoint, err error) {
	key := "externaldnsruntimeendpoints.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalExternalDNSRuntimeEndpoint, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntimeEndpoint)
			result[k] = &GlobalExternalDNSRuntimeEndpoint{
				client:                     group.client,
				ExternalDNSRuntimeEndpoint: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ExternalDNSRuntimeEndpoints().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalExternalDNSRuntimeEndpoint, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalExternalDNSRuntimeEndpoint{
				client:                     group.client,
				ExternalDNSRuntimeEndpoint: &item,
			}
		}
	}
	return
}

type GlobalExternalDNSRuntimeEndpoint struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntimeEndpoint
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalExternalDNSRuntimeEndpoint) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteExternalDNSRuntimeEndpointByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ExternalDNSRuntimeEndpoint = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalExternalDNSRuntimeEndpoint) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateExternalDNSRuntimeEndpointByName(ctx, obj.ExternalDNSRuntimeEndpoint)
	if err != nil {
		return err
	}
	obj.ExternalDNSRuntimeEndpoint = result.ExternalDNSRuntimeEndpoint
	return nil
}

func (obj *GlobalExternalDNSRuntimeEndpoint) GetParent(ctx context.Context) (result *GlobalExternalDNSRuntimeSubdomain, err error) {
	hashedName := helper.GetHashedName("externaldnsruntimesubdomains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["externaldnsruntimesubdomains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetExternalDNSRuntimeSubdomainByName(ctx, hashedName)
}

type externaldnsruntimeendpointGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *externaldnsruntimeendpointGlobalTsmV1Chainer) Subscribe() {
	key := "externaldnsruntimeendpoints.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalDNSRuntimeEndpointInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *externaldnsruntimeendpointGlobalTsmV1Chainer) Unsubscribe() {
	key := "externaldnsruntimeendpoints.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *externaldnsruntimeendpointGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "externaldnsruntimeendpoints.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetExternalDNSRuntimePrimaryDomainByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetExternalDNSRuntimePrimaryDomainByName(ctx context.Context, hashedName string) (*GlobalExternalDNSRuntimePrimaryDomain, error) {
	key := "externaldnsruntimeprimarydomains.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntimePrimaryDomain)
		return &GlobalExternalDNSRuntimePrimaryDomain{
			client:                          group.client,
			ExternalDNSRuntimePrimaryDomain: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalDNSRuntimePrimaryDomains().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalExternalDNSRuntimePrimaryDomain{
			client:                          group.client,
			ExternalDNSRuntimePrimaryDomain: result,
		}, nil
	}
}

// DeleteExternalDNSRuntimePrimaryDomainByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteExternalDNSRuntimePrimaryDomainByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSRuntimePrimaryDomains().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.SubdomainsGvk {
		err := group.client.
			Global().DeleteExternalDNSRuntimeSubdomainByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSRuntimePrimaryDomains().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/primaryDomainsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["externaldnsruntimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("externaldnsruntimes.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSRuntimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateExternalDNSRuntimePrimaryDomainByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateExternalDNSRuntimePrimaryDomainByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntimePrimaryDomain) (*GlobalExternalDNSRuntimePrimaryDomain, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.SubdomainsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSRuntimePrimaryDomains().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["externaldnsruntimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("externaldnsruntimes.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"primaryDomainsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ExternalDNSRuntimePrimaryDomain\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSRuntimes().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalExternalDNSRuntimePrimaryDomain{
		client:                          group.client,
		ExternalDNSRuntimePrimaryDomain: result,
	}, nil
}

// UpdateExternalDNSRuntimePrimaryDomainByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateExternalDNSRuntimePrimaryDomainByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntimePrimaryDomain) (*GlobalExternalDNSRuntimePrimaryDomain, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalDNSRuntimePrimaryDomains().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValuePrimaryDomain :=
		objToUpdate.Spec.PrimaryDomain
	patchOpPrimaryDomain := PatchOp{
		Op:    "replace",
		Path:  "/spec/primaryDomain",
		Value: patchValuePrimaryDomain,
	}
	patch = append(patch, patchOpPrimaryDomain)

	patchValueDnsServerID :=
		objToUpdate.Spec.DnsServerID
	patchOpDnsServerID := PatchOp{
		Op:    "replace",
		Path:  "/spec/dnsServerID",
		Value: patchValueDnsServerID,
	}
	patch = append(patch, patchOpDnsServerID)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSRuntimePrimaryDomains().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalExternalDNSRuntimePrimaryDomain{
		client:                          group.client,
		ExternalDNSRuntimePrimaryDomain: result,
	}, nil
}

// ListExternalDNSRuntimePrimaryDomains returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListExternalDNSRuntimePrimaryDomains(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalExternalDNSRuntimePrimaryDomain, err error) {
	key := "externaldnsruntimeprimarydomains.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalExternalDNSRuntimePrimaryDomain, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntimePrimaryDomain)
			result[k] = &GlobalExternalDNSRuntimePrimaryDomain{
				client:                          group.client,
				ExternalDNSRuntimePrimaryDomain: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ExternalDNSRuntimePrimaryDomains().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalExternalDNSRuntimePrimaryDomain, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalExternalDNSRuntimePrimaryDomain{
				client:                          group.client,
				ExternalDNSRuntimePrimaryDomain: &item,
			}
		}
	}
	return
}

type GlobalExternalDNSRuntimePrimaryDomain struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntimePrimaryDomain
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalExternalDNSRuntimePrimaryDomain) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteExternalDNSRuntimePrimaryDomainByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ExternalDNSRuntimePrimaryDomain = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalExternalDNSRuntimePrimaryDomain) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateExternalDNSRuntimePrimaryDomainByName(ctx, obj.ExternalDNSRuntimePrimaryDomain)
	if err != nil {
		return err
	}
	obj.ExternalDNSRuntimePrimaryDomain = result.ExternalDNSRuntimePrimaryDomain
	return nil
}

func (obj *GlobalExternalDNSRuntimePrimaryDomain) GetParent(ctx context.Context) (result *GlobalExternalDNSRuntime, err error) {
	hashedName := helper.GetHashedName("externaldnsruntimes.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["externaldnsruntimes.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetExternalDNSRuntimeByName(ctx, hashedName)
}

// GetAllSubdomains returns all children of given type
func (obj *GlobalExternalDNSRuntimePrimaryDomain) GetAllSubdomains(ctx context.Context) (
	result []*GlobalExternalDNSRuntimeSubdomain, err error) {
	result = make([]*GlobalExternalDNSRuntimeSubdomain, 0, len(obj.Spec.SubdomainsGvk))
	for _, v := range obj.Spec.SubdomainsGvk {
		l, err := obj.client.Global().GetExternalDNSRuntimeSubdomainByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetSubdomains returns child which has given displayName
func (obj *GlobalExternalDNSRuntimePrimaryDomain) GetSubdomains(ctx context.Context,
	displayName string) (result *GlobalExternalDNSRuntimeSubdomain, err error) {
	l, ok := obj.Spec.SubdomainsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ExternalDNSRuntimePrimaryDomain", "Subdomains", displayName)
	}
	result, err = obj.client.Global().GetExternalDNSRuntimeSubdomainByName(ctx, l.Name)
	return
}

// AddSubdomains calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalExternalDNSRuntimePrimaryDomain) AddSubdomains(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntimeSubdomain) (result *GlobalExternalDNSRuntimeSubdomain, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["externaldnsruntimeprimarydomains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["externaldnsruntimeprimarydomains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateExternalDNSRuntimeSubdomainByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetExternalDNSRuntimePrimaryDomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ExternalDNSRuntimePrimaryDomain = updatedObj.ExternalDNSRuntimePrimaryDomain
	}
	return
}

// DeleteSubdomains calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalExternalDNSRuntimePrimaryDomain) DeleteSubdomains(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.SubdomainsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ExternalDNSRuntimePrimaryDomain", "Subdomains", displayName)
	}
	err = obj.client.Global().DeleteExternalDNSRuntimeSubdomainByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetExternalDNSRuntimePrimaryDomainByName(ctx, obj.GetName())
	if err == nil {
		obj.ExternalDNSRuntimePrimaryDomain = updatedObj.ExternalDNSRuntimePrimaryDomain
	}
	return
}

type externaldnsruntimeprimarydomainGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *externaldnsruntimeprimarydomainGlobalTsmV1Chainer) Subscribe() {
	key := "externaldnsruntimeprimarydomains.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalDNSRuntimePrimaryDomainInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *externaldnsruntimeprimarydomainGlobalTsmV1Chainer) Unsubscribe() {
	key := "externaldnsruntimeprimarydomains.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *externaldnsruntimeprimarydomainGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "externaldnsruntimeprimarydomains.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *externaldnsruntimeprimarydomainGlobalTsmV1Chainer) Subdomains(name string) *externaldnsruntimesubdomainGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["externaldnsruntimesubdomains.global.tsm.tanzu.vmware.com"] = name
	return &externaldnsruntimesubdomainGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetSubdomains calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *externaldnsruntimeprimarydomainGlobalTsmV1Chainer) GetSubdomains(ctx context.Context, displayName string) (result *GlobalExternalDNSRuntimeSubdomain, err error) {
	hashedName := helper.GetHashedName("externaldnsruntimesubdomains.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetExternalDNSRuntimeSubdomainByName(ctx, hashedName)
}

// AddSubdomains calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *externaldnsruntimeprimarydomainGlobalTsmV1Chainer) AddSubdomains(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntimeSubdomain) (result *GlobalExternalDNSRuntimeSubdomain, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("externaldnsruntimesubdomains.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateExternalDNSRuntimeSubdomainByName(ctx, objToCreate)
}

// DeleteSubdomains calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *externaldnsruntimeprimarydomainGlobalTsmV1Chainer) DeleteSubdomains(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("externaldnsruntimesubdomains.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteExternalDNSRuntimeSubdomainByName(ctx, hashedName)
}

// GetExternalDNSRuntimeByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetExternalDNSRuntimeByName(ctx context.Context, hashedName string) (*GlobalExternalDNSRuntime, error) {
	key := "externaldnsruntimes.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntime)
		return &GlobalExternalDNSRuntime{
			client:             group.client,
			ExternalDNSRuntime: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalDNSRuntimes().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalExternalDNSRuntime{
			client:             group.client,
			ExternalDNSRuntime: result,
		}, nil
	}
}

// DeleteExternalDNSRuntimeByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteExternalDNSRuntimeByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSRuntimes().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.PrimaryDomainsGvk {
		err := group.client.
			Global().DeleteExternalDNSRuntimePrimaryDomainByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSRuntimes().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/externalDNSGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["runtimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateExternalDNSRuntimeByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateExternalDNSRuntimeByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntime) (*GlobalExternalDNSRuntime, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.PrimaryDomainsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSRuntimes().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["runtimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/externalDNSGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "ExternalDNSRuntime",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalExternalDNSRuntime{
		client:             group.client,
		ExternalDNSRuntime: result,
	}, nil
}

// UpdateExternalDNSRuntimeByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateExternalDNSRuntimeByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntime) (*GlobalExternalDNSRuntime, error) {
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalDNSRuntimes().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSRuntimes().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalExternalDNSRuntime{
		client:             group.client,
		ExternalDNSRuntime: result,
	}, nil
}

// ListExternalDNSRuntimes returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListExternalDNSRuntimes(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalExternalDNSRuntime, err error) {
	key := "externaldnsruntimes.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalExternalDNSRuntime, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntime)
			result[k] = &GlobalExternalDNSRuntime{
				client:             group.client,
				ExternalDNSRuntime: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ExternalDNSRuntimes().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalExternalDNSRuntime, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalExternalDNSRuntime{
				client:             group.client,
				ExternalDNSRuntime: &item,
			}
		}
	}
	return
}

type GlobalExternalDNSRuntime struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntime
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalExternalDNSRuntime) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteExternalDNSRuntimeByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ExternalDNSRuntime = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalExternalDNSRuntime) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateExternalDNSRuntimeByName(ctx, obj.ExternalDNSRuntime)
	if err != nil {
		return err
	}
	obj.ExternalDNSRuntime = result.ExternalDNSRuntime
	return nil
}

func (obj *GlobalExternalDNSRuntime) GetParent(ctx context.Context) (result *GlobalRuntime, err error) {
	hashedName := helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["runtimes.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetRuntimeByName(ctx, hashedName)
}

// GetAllPrimaryDomains returns all children of given type
func (obj *GlobalExternalDNSRuntime) GetAllPrimaryDomains(ctx context.Context) (
	result []*GlobalExternalDNSRuntimePrimaryDomain, err error) {
	result = make([]*GlobalExternalDNSRuntimePrimaryDomain, 0, len(obj.Spec.PrimaryDomainsGvk))
	for _, v := range obj.Spec.PrimaryDomainsGvk {
		l, err := obj.client.Global().GetExternalDNSRuntimePrimaryDomainByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetPrimaryDomains returns child which has given displayName
func (obj *GlobalExternalDNSRuntime) GetPrimaryDomains(ctx context.Context,
	displayName string) (result *GlobalExternalDNSRuntimePrimaryDomain, err error) {
	l, ok := obj.Spec.PrimaryDomainsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ExternalDNSRuntime", "PrimaryDomains", displayName)
	}
	result, err = obj.client.Global().GetExternalDNSRuntimePrimaryDomainByName(ctx, l.Name)
	return
}

// AddPrimaryDomains calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalExternalDNSRuntime) AddPrimaryDomains(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntimePrimaryDomain) (result *GlobalExternalDNSRuntimePrimaryDomain, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["externaldnsruntimes.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["externaldnsruntimes.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateExternalDNSRuntimePrimaryDomainByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetExternalDNSRuntimeByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ExternalDNSRuntime = updatedObj.ExternalDNSRuntime
	}
	return
}

// DeletePrimaryDomains calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalExternalDNSRuntime) DeletePrimaryDomains(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.PrimaryDomainsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ExternalDNSRuntime", "PrimaryDomains", displayName)
	}
	err = obj.client.Global().DeleteExternalDNSRuntimePrimaryDomainByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetExternalDNSRuntimeByName(ctx, obj.GetName())
	if err == nil {
		obj.ExternalDNSRuntime = updatedObj.ExternalDNSRuntime
	}
	return
}

type externaldnsruntimeGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *externaldnsruntimeGlobalTsmV1Chainer) Subscribe() {
	key := "externaldnsruntimes.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalDNSRuntimeInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *externaldnsruntimeGlobalTsmV1Chainer) Unsubscribe() {
	key := "externaldnsruntimes.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *externaldnsruntimeGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "externaldnsruntimes.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *externaldnsruntimeGlobalTsmV1Chainer) PrimaryDomains(name string) *externaldnsruntimeprimarydomainGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["externaldnsruntimeprimarydomains.global.tsm.tanzu.vmware.com"] = name
	return &externaldnsruntimeprimarydomainGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetPrimaryDomains calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *externaldnsruntimeGlobalTsmV1Chainer) GetPrimaryDomains(ctx context.Context, displayName string) (result *GlobalExternalDNSRuntimePrimaryDomain, err error) {
	hashedName := helper.GetHashedName("externaldnsruntimeprimarydomains.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetExternalDNSRuntimePrimaryDomainByName(ctx, hashedName)
}

// AddPrimaryDomains calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *externaldnsruntimeGlobalTsmV1Chainer) AddPrimaryDomains(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntimePrimaryDomain) (result *GlobalExternalDNSRuntimePrimaryDomain, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("externaldnsruntimeprimarydomains.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateExternalDNSRuntimePrimaryDomainByName(ctx, objToCreate)
}

// DeletePrimaryDomains calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *externaldnsruntimeGlobalTsmV1Chainer) DeletePrimaryDomains(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("externaldnsruntimeprimarydomains.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteExternalDNSRuntimePrimaryDomainByName(ctx, hashedName)
}

// GetExternalDNSRuntimeSubdomainByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetExternalDNSRuntimeSubdomainByName(ctx context.Context, hashedName string) (*GlobalExternalDNSRuntimeSubdomain, error) {
	key := "externaldnsruntimesubdomains.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntimeSubdomain)
		return &GlobalExternalDNSRuntimeSubdomain{
			client:                      group.client,
			ExternalDNSRuntimeSubdomain: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalDNSRuntimeSubdomains().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalExternalDNSRuntimeSubdomain{
			client:                      group.client,
			ExternalDNSRuntimeSubdomain: result,
		}, nil
	}
}

// DeleteExternalDNSRuntimeSubdomainByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteExternalDNSRuntimeSubdomainByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSRuntimeSubdomains().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.EndpointsGvk {
		err := group.client.
			Global().DeleteExternalDNSRuntimeEndpointByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSRuntimeSubdomains().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/subdomainsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["externaldnsruntimeprimarydomains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("externaldnsruntimeprimarydomains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSRuntimePrimaryDomains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateExternalDNSRuntimeSubdomainByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateExternalDNSRuntimeSubdomainByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntimeSubdomain) (*GlobalExternalDNSRuntimeSubdomain, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.EndpointsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSRuntimeSubdomains().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["externaldnsruntimeprimarydomains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("externaldnsruntimeprimarydomains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"subdomainsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ExternalDNSRuntimeSubdomain\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSRuntimePrimaryDomains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalExternalDNSRuntimeSubdomain{
		client:                      group.client,
		ExternalDNSRuntimeSubdomain: result,
	}, nil
}

// UpdateExternalDNSRuntimeSubdomainByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateExternalDNSRuntimeSubdomainByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntimeSubdomain) (*GlobalExternalDNSRuntimeSubdomain, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalDNSRuntimeSubdomains().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueRecordType :=
		objToUpdate.Spec.RecordType
	patchOpRecordType := PatchOp{
		Op:    "replace",
		Path:  "/spec/recordType",
		Value: patchValueRecordType,
	}
	patch = append(patch, patchOpRecordType)

	patchValueTtl :=
		objToUpdate.Spec.Ttl
	patchOpTtl := PatchOp{
		Op:    "replace",
		Path:  "/spec/ttl",
		Value: patchValueTtl,
	}
	patch = append(patch, patchOpTtl)

	patchValueHealthCheckDomain :=
		objToUpdate.Spec.HealthCheckDomain
	patchOpHealthCheckDomain := PatchOp{
		Op:    "replace",
		Path:  "/spec/healthCheckDomain",
		Value: patchValueHealthCheckDomain,
	}
	patch = append(patch, patchOpHealthCheckDomain)

	patchValueHealthCheckExternalPort :=
		objToUpdate.Spec.HealthCheckExternalPort
	patchOpHealthCheckExternalPort := PatchOp{
		Op:    "replace",
		Path:  "/spec/healthCheckExternalPort",
		Value: patchValueHealthCheckExternalPort,
	}
	patch = append(patch, patchOpHealthCheckExternalPort)

	patchValueHealthCheckPort :=
		objToUpdate.Spec.HealthCheckPort
	patchOpHealthCheckPort := PatchOp{
		Op:    "replace",
		Path:  "/spec/healthCheckPort",
		Value: patchValueHealthCheckPort,
	}
	patch = append(patch, patchOpHealthCheckPort)

	patchValueHealthCheckPath :=
		objToUpdate.Spec.HealthCheckPath
	patchOpHealthCheckPath := PatchOp{
		Op:    "replace",
		Path:  "/spec/healthCheckPath",
		Value: patchValueHealthCheckPath,
	}
	patch = append(patch, patchOpHealthCheckPath)

	patchValueHealthCheckThreshold :=
		objToUpdate.Spec.HealthCheckThreshold
	patchOpHealthCheckThreshold := PatchOp{
		Op:    "replace",
		Path:  "/spec/healthCheckThreshold",
		Value: patchValueHealthCheckThreshold,
	}
	patch = append(patch, patchOpHealthCheckThreshold)

	patchValueHealthCheckInterval :=
		objToUpdate.Spec.HealthCheckInterval
	patchOpHealthCheckInterval := PatchOp{
		Op:    "replace",
		Path:  "/spec/healthCheckInterval",
		Value: patchValueHealthCheckInterval,
	}
	patch = append(patch, patchOpHealthCheckInterval)

	patchValueHealthCheckProtocol :=
		objToUpdate.Spec.HealthCheckProtocol
	patchOpHealthCheckProtocol := PatchOp{
		Op:    "replace",
		Path:  "/spec/healthCheckProtocol",
		Value: patchValueHealthCheckProtocol,
	}
	patch = append(patch, patchOpHealthCheckProtocol)

	patchValueGnsVersion :=
		objToUpdate.Spec.GnsVersion
	patchOpGnsVersion := PatchOp{
		Op:    "replace",
		Path:  "/spec/gnsVersion",
		Value: patchValueGnsVersion,
	}
	patch = append(patch, patchOpGnsVersion)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalDNSRuntimeSubdomains().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalExternalDNSRuntimeSubdomain{
		client:                      group.client,
		ExternalDNSRuntimeSubdomain: result,
	}, nil
}

// ListExternalDNSRuntimeSubdomains returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListExternalDNSRuntimeSubdomains(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalExternalDNSRuntimeSubdomain, err error) {
	key := "externaldnsruntimesubdomains.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalExternalDNSRuntimeSubdomain, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntimeSubdomain)
			result[k] = &GlobalExternalDNSRuntimeSubdomain{
				client:                      group.client,
				ExternalDNSRuntimeSubdomain: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ExternalDNSRuntimeSubdomains().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalExternalDNSRuntimeSubdomain, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalExternalDNSRuntimeSubdomain{
				client:                      group.client,
				ExternalDNSRuntimeSubdomain: &item,
			}
		}
	}
	return
}

type GlobalExternalDNSRuntimeSubdomain struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntimeSubdomain
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalExternalDNSRuntimeSubdomain) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteExternalDNSRuntimeSubdomainByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ExternalDNSRuntimeSubdomain = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalExternalDNSRuntimeSubdomain) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateExternalDNSRuntimeSubdomainByName(ctx, obj.ExternalDNSRuntimeSubdomain)
	if err != nil {
		return err
	}
	obj.ExternalDNSRuntimeSubdomain = result.ExternalDNSRuntimeSubdomain
	return nil
}

func (obj *GlobalExternalDNSRuntimeSubdomain) GetParent(ctx context.Context) (result *GlobalExternalDNSRuntimePrimaryDomain, err error) {
	hashedName := helper.GetHashedName("externaldnsruntimeprimarydomains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["externaldnsruntimeprimarydomains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetExternalDNSRuntimePrimaryDomainByName(ctx, hashedName)
}

// GetAllEndpoints returns all children of given type
func (obj *GlobalExternalDNSRuntimeSubdomain) GetAllEndpoints(ctx context.Context) (
	result []*GlobalExternalDNSRuntimeEndpoint, err error) {
	result = make([]*GlobalExternalDNSRuntimeEndpoint, 0, len(obj.Spec.EndpointsGvk))
	for _, v := range obj.Spec.EndpointsGvk {
		l, err := obj.client.Global().GetExternalDNSRuntimeEndpointByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetEndpoints returns child which has given displayName
func (obj *GlobalExternalDNSRuntimeSubdomain) GetEndpoints(ctx context.Context,
	displayName string) (result *GlobalExternalDNSRuntimeEndpoint, err error) {
	l, ok := obj.Spec.EndpointsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ExternalDNSRuntimeSubdomain", "Endpoints", displayName)
	}
	result, err = obj.client.Global().GetExternalDNSRuntimeEndpointByName(ctx, l.Name)
	return
}

// AddEndpoints calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalExternalDNSRuntimeSubdomain) AddEndpoints(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntimeEndpoint) (result *GlobalExternalDNSRuntimeEndpoint, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["externaldnsruntimesubdomains.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["externaldnsruntimesubdomains.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateExternalDNSRuntimeEndpointByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetExternalDNSRuntimeSubdomainByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ExternalDNSRuntimeSubdomain = updatedObj.ExternalDNSRuntimeSubdomain
	}
	return
}

// DeleteEndpoints calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalExternalDNSRuntimeSubdomain) DeleteEndpoints(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.EndpointsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ExternalDNSRuntimeSubdomain", "Endpoints", displayName)
	}
	err = obj.client.Global().DeleteExternalDNSRuntimeEndpointByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetExternalDNSRuntimeSubdomainByName(ctx, obj.GetName())
	if err == nil {
		obj.ExternalDNSRuntimeSubdomain = updatedObj.ExternalDNSRuntimeSubdomain
	}
	return
}

type externaldnsruntimesubdomainGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *externaldnsruntimesubdomainGlobalTsmV1Chainer) Subscribe() {
	key := "externaldnsruntimesubdomains.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalDNSRuntimeSubdomainInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *externaldnsruntimesubdomainGlobalTsmV1Chainer) Unsubscribe() {
	key := "externaldnsruntimesubdomains.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *externaldnsruntimesubdomainGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "externaldnsruntimesubdomains.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *externaldnsruntimesubdomainGlobalTsmV1Chainer) Endpoints(name string) *externaldnsruntimeendpointGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["externaldnsruntimeendpoints.global.tsm.tanzu.vmware.com"] = name
	return &externaldnsruntimeendpointGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetEndpoints calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *externaldnsruntimesubdomainGlobalTsmV1Chainer) GetEndpoints(ctx context.Context, displayName string) (result *GlobalExternalDNSRuntimeEndpoint, err error) {
	hashedName := helper.GetHashedName("externaldnsruntimeendpoints.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetExternalDNSRuntimeEndpointByName(ctx, hashedName)
}

// AddEndpoints calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *externaldnsruntimesubdomainGlobalTsmV1Chainer) AddEndpoints(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntimeEndpoint) (result *GlobalExternalDNSRuntimeEndpoint, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("externaldnsruntimeendpoints.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateExternalDNSRuntimeEndpointByName(ctx, objToCreate)
}

// DeleteEndpoints calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *externaldnsruntimesubdomainGlobalTsmV1Chainer) DeleteEndpoints(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("externaldnsruntimeendpoints.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteExternalDNSRuntimeEndpointByName(ctx, hashedName)
}

// GetExternalLBConfigNByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetExternalLBConfigNByName(ctx context.Context, hashedName string) (*GlobalExternalLBConfigN, error) {
	key := "externallbconfigns.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ExternalLBConfigN)
		return &GlobalExternalLBConfigN{
			client:            group.client,
			ExternalLBConfigN: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalLBConfigNs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalExternalLBConfigN{
			client:            group.client,
			ExternalLBConfigN: result,
		}, nil
	}
}

// DeleteExternalLBConfigNByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteExternalLBConfigNByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalLBConfigNs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ExternalLBConfigNs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/externalLBGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateExternalLBConfigNByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateExternalLBConfigNByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalLBConfigN) (*GlobalExternalLBConfigN, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalLBConfigNs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"externalLBGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ExternalLBConfigN\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalExternalLBConfigN{
		client:            group.client,
		ExternalLBConfigN: result,
	}, nil
}

// UpdateExternalLBConfigNByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateExternalLBConfigNByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ExternalLBConfigN) (*GlobalExternalLBConfigN, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalLBConfigNs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueConfig :=
		objToUpdate.Spec.Config
	patchOpConfig := PatchOp{
		Op:    "replace",
		Path:  "/spec/config",
		Value: patchValueConfig,
	}
	patch = append(patch, patchOpConfig)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalLBConfigNs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalExternalLBConfigN{
		client:            group.client,
		ExternalLBConfigN: result,
	}, nil
}

// ListExternalLBConfigNs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListExternalLBConfigNs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalExternalLBConfigN, err error) {
	key := "externallbconfigns.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalExternalLBConfigN, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ExternalLBConfigN)
			result[k] = &GlobalExternalLBConfigN{
				client:            group.client,
				ExternalLBConfigN: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ExternalLBConfigNs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalExternalLBConfigN, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalExternalLBConfigN{
				client:            group.client,
				ExternalLBConfigN: &item,
			}
		}
	}
	return
}

type GlobalExternalLBConfigN struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ExternalLBConfigN
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalExternalLBConfigN) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteExternalLBConfigNByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ExternalLBConfigN = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalExternalLBConfigN) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateExternalLBConfigNByName(ctx, obj.ExternalLBConfigN)
	if err != nil {
		return err
	}
	obj.ExternalLBConfigN = result.ExternalLBConfigN
	return nil
}

func (obj *GlobalExternalLBConfigN) GetParent(ctx context.Context) (result *GlobalConfig, err error) {
	hashedName := helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetConfigByName(ctx, hashedName)
}

type externallbconfignGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *externallbconfignGlobalTsmV1Chainer) Subscribe() {
	key := "externallbconfigns.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalLBConfigNInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *externallbconfignGlobalTsmV1Chainer) Unsubscribe() {
	key := "externallbconfigns.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *externallbconfignGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "externallbconfigns.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetExternalPluginCapabilityByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetExternalPluginCapabilityByName(ctx context.Context, hashedName string) (*GlobalExternalPluginCapability, error) {
	key := "externalplugincapabilities.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ExternalPluginCapability)
		return &GlobalExternalPluginCapability{
			client:                   group.client,
			ExternalPluginCapability: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalPluginCapabilities().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalExternalPluginCapability{
			client:                   group.client,
			ExternalPluginCapability: result,
		}, nil
	}
}

// DeleteExternalPluginCapabilityByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteExternalPluginCapabilityByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginCapabilities().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginCapabilities().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/capabilitiyGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["externalplugininstanceconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("externalplugininstanceconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginInstanceConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateExternalPluginCapabilityByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateExternalPluginCapabilityByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalPluginCapability) (*GlobalExternalPluginCapability, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginCapabilities().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["externalplugininstanceconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("externalplugininstanceconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/capabilitiyGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "ExternalPluginCapability",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginInstanceConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalExternalPluginCapability{
		client:                   group.client,
		ExternalPluginCapability: result,
	}, nil
}

// UpdateExternalPluginCapabilityByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateExternalPluginCapabilityByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ExternalPluginCapability) (*GlobalExternalPluginCapability, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalPluginCapabilities().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueCapability :=
		objToUpdate.Spec.Capability
	patchOpCapability := PatchOp{
		Op:    "replace",
		Path:  "/spec/capability",
		Value: patchValueCapability,
	}
	patch = append(patch, patchOpCapability)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginCapabilities().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalExternalPluginCapability{
		client:                   group.client,
		ExternalPluginCapability: result,
	}, nil
}

// ListExternalPluginCapabilities returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListExternalPluginCapabilities(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalExternalPluginCapability, err error) {
	key := "externalplugincapabilities.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalExternalPluginCapability, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ExternalPluginCapability)
			result[k] = &GlobalExternalPluginCapability{
				client:                   group.client,
				ExternalPluginCapability: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ExternalPluginCapabilities().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalExternalPluginCapability, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalExternalPluginCapability{
				client:                   group.client,
				ExternalPluginCapability: &item,
			}
		}
	}
	return
}

type GlobalExternalPluginCapability struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ExternalPluginCapability
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalExternalPluginCapability) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteExternalPluginCapabilityByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ExternalPluginCapability = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalExternalPluginCapability) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateExternalPluginCapabilityByName(ctx, obj.ExternalPluginCapability)
	if err != nil {
		return err
	}
	obj.ExternalPluginCapability = result.ExternalPluginCapability
	return nil
}

func (obj *GlobalExternalPluginCapability) GetParent(ctx context.Context) (result *GlobalExternalPluginInstanceConfig, err error) {
	hashedName := helper.GetHashedName("externalplugininstanceconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["externalplugininstanceconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetExternalPluginInstanceConfigByName(ctx, hashedName)
}

type externalplugincapabilityGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *externalplugincapabilityGlobalTsmV1Chainer) Subscribe() {
	key := "externalplugincapabilities.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalPluginCapabilityInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *externalplugincapabilityGlobalTsmV1Chainer) Unsubscribe() {
	key := "externalplugincapabilities.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *externalplugincapabilityGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "externalplugincapabilities.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetExternalPluginConfigFolderByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetExternalPluginConfigFolderByName(ctx context.Context, hashedName string) (*GlobalExternalPluginConfigFolder, error) {
	key := "externalpluginconfigfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ExternalPluginConfigFolder)
		return &GlobalExternalPluginConfigFolder{
			client:                     group.client,
			ExternalPluginConfigFolder: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalPluginConfigFolders().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalExternalPluginConfigFolder{
			client:                     group.client,
			ExternalPluginConfigFolder: result,
		}, nil
	}
}

// DeleteExternalPluginConfigFolderByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteExternalPluginConfigFolderByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginConfigFolders().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.PluginsGvk {
		err := group.client.
			Global().DeleteExternalPluginConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginConfigFolders().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/externalPluginsGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateExternalPluginConfigFolderByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateExternalPluginConfigFolderByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalPluginConfigFolder) (*GlobalExternalPluginConfigFolder, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.PluginsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginConfigFolders().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/externalPluginsGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "ExternalPluginConfigFolder",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalExternalPluginConfigFolder{
		client:                     group.client,
		ExternalPluginConfigFolder: result,
	}, nil
}

// UpdateExternalPluginConfigFolderByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateExternalPluginConfigFolderByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ExternalPluginConfigFolder) (*GlobalExternalPluginConfigFolder, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalPluginConfigFolders().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginConfigFolders().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalExternalPluginConfigFolder{
		client:                     group.client,
		ExternalPluginConfigFolder: result,
	}, nil
}

// ListExternalPluginConfigFolders returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListExternalPluginConfigFolders(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalExternalPluginConfigFolder, err error) {
	key := "externalpluginconfigfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalExternalPluginConfigFolder, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ExternalPluginConfigFolder)
			result[k] = &GlobalExternalPluginConfigFolder{
				client:                     group.client,
				ExternalPluginConfigFolder: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ExternalPluginConfigFolders().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalExternalPluginConfigFolder, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalExternalPluginConfigFolder{
				client:                     group.client,
				ExternalPluginConfigFolder: &item,
			}
		}
	}
	return
}

type GlobalExternalPluginConfigFolder struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ExternalPluginConfigFolder
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalExternalPluginConfigFolder) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteExternalPluginConfigFolderByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ExternalPluginConfigFolder = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalExternalPluginConfigFolder) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateExternalPluginConfigFolderByName(ctx, obj.ExternalPluginConfigFolder)
	if err != nil {
		return err
	}
	obj.ExternalPluginConfigFolder = result.ExternalPluginConfigFolder
	return nil
}

func (obj *GlobalExternalPluginConfigFolder) GetParent(ctx context.Context) (result *GlobalConfig, err error) {
	hashedName := helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetConfigByName(ctx, hashedName)
}

// GetAllPlugins returns all children of given type
func (obj *GlobalExternalPluginConfigFolder) GetAllPlugins(ctx context.Context) (
	result []*GlobalExternalPluginConfig, err error) {
	result = make([]*GlobalExternalPluginConfig, 0, len(obj.Spec.PluginsGvk))
	for _, v := range obj.Spec.PluginsGvk {
		l, err := obj.client.Global().GetExternalPluginConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetPlugins returns child which has given displayName
func (obj *GlobalExternalPluginConfigFolder) GetPlugins(ctx context.Context,
	displayName string) (result *GlobalExternalPluginConfig, err error) {
	l, ok := obj.Spec.PluginsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ExternalPluginConfigFolder", "Plugins", displayName)
	}
	result, err = obj.client.Global().GetExternalPluginConfigByName(ctx, l.Name)
	return
}

// AddPlugins calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalExternalPluginConfigFolder) AddPlugins(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalPluginConfig) (result *GlobalExternalPluginConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["externalpluginconfigfolders.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["externalpluginconfigfolders.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateExternalPluginConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetExternalPluginConfigFolderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ExternalPluginConfigFolder = updatedObj.ExternalPluginConfigFolder
	}
	return
}

// DeletePlugins calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalExternalPluginConfigFolder) DeletePlugins(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.PluginsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ExternalPluginConfigFolder", "Plugins", displayName)
	}
	err = obj.client.Global().DeleteExternalPluginConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetExternalPluginConfigFolderByName(ctx, obj.GetName())
	if err == nil {
		obj.ExternalPluginConfigFolder = updatedObj.ExternalPluginConfigFolder
	}
	return
}

type externalpluginconfigfolderGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *externalpluginconfigfolderGlobalTsmV1Chainer) Subscribe() {
	key := "externalpluginconfigfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalPluginConfigFolderInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *externalpluginconfigfolderGlobalTsmV1Chainer) Unsubscribe() {
	key := "externalpluginconfigfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *externalpluginconfigfolderGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "externalpluginconfigfolders.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *externalpluginconfigfolderGlobalTsmV1Chainer) Plugins(name string) *externalpluginconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["externalpluginconfigs.global.tsm.tanzu.vmware.com"] = name
	return &externalpluginconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetPlugins calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *externalpluginconfigfolderGlobalTsmV1Chainer) GetPlugins(ctx context.Context, displayName string) (result *GlobalExternalPluginConfig, err error) {
	hashedName := helper.GetHashedName("externalpluginconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetExternalPluginConfigByName(ctx, hashedName)
}

// AddPlugins calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *externalpluginconfigfolderGlobalTsmV1Chainer) AddPlugins(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalPluginConfig) (result *GlobalExternalPluginConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("externalpluginconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateExternalPluginConfigByName(ctx, objToCreate)
}

// DeletePlugins calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *externalpluginconfigfolderGlobalTsmV1Chainer) DeletePlugins(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("externalpluginconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteExternalPluginConfigByName(ctx, hashedName)
}

// GetExternalPluginConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetExternalPluginConfigByName(ctx context.Context, hashedName string) (*GlobalExternalPluginConfig, error) {
	key := "externalpluginconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ExternalPluginConfig)
		return &GlobalExternalPluginConfig{
			client:               group.client,
			ExternalPluginConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalPluginConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalExternalPluginConfig{
			client:               group.client,
			ExternalPluginConfig: result,
		}, nil
	}
}

// DeleteExternalPluginConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteExternalPluginConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.PluginInstancesGvk {
		err := group.client.
			Global().DeleteExternalPluginInstanceConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/pluginsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["externalpluginconfigfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("externalpluginconfigfolders.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginConfigFolders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateExternalPluginConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateExternalPluginConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalPluginConfig) (*GlobalExternalPluginConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.PluginInstancesGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["externalpluginconfigfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("externalpluginconfigfolders.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"pluginsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ExternalPluginConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginConfigFolders().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalExternalPluginConfig{
		client:               group.client,
		ExternalPluginConfig: result,
	}, nil
}

// UpdateExternalPluginConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateExternalPluginConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ExternalPluginConfig) (*GlobalExternalPluginConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalPluginConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueProviderName :=
		objToUpdate.Spec.ProviderName
	patchOpProviderName := PatchOp{
		Op:    "replace",
		Path:  "/spec/providerName",
		Value: patchValueProviderName,
	}
	patch = append(patch, patchOpProviderName)

	patchValueInstallConfig :=
		objToUpdate.Spec.InstallConfig
	patchOpInstallConfig := PatchOp{
		Op:    "replace",
		Path:  "/spec/installConfig",
		Value: patchValueInstallConfig,
	}
	patch = append(patch, patchOpInstallConfig)

	patchValueType :=
		objToUpdate.Spec.Type
	patchOpType := PatchOp{
		Op:    "replace",
		Path:  "/spec/type",
		Value: patchValueType,
	}
	patch = append(patch, patchOpType)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalExternalPluginConfig{
		client:               group.client,
		ExternalPluginConfig: result,
	}, nil
}

// ListExternalPluginConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListExternalPluginConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalExternalPluginConfig, err error) {
	key := "externalpluginconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalExternalPluginConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ExternalPluginConfig)
			result[k] = &GlobalExternalPluginConfig{
				client:               group.client,
				ExternalPluginConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ExternalPluginConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalExternalPluginConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalExternalPluginConfig{
				client:               group.client,
				ExternalPluginConfig: &item,
			}
		}
	}
	return
}

type GlobalExternalPluginConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ExternalPluginConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalExternalPluginConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteExternalPluginConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ExternalPluginConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalExternalPluginConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateExternalPluginConfigByName(ctx, obj.ExternalPluginConfig)
	if err != nil {
		return err
	}
	obj.ExternalPluginConfig = result.ExternalPluginConfig
	return nil
}

func (obj *GlobalExternalPluginConfig) GetParent(ctx context.Context) (result *GlobalExternalPluginConfigFolder, err error) {
	hashedName := helper.GetHashedName("externalpluginconfigfolders.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["externalpluginconfigfolders.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetExternalPluginConfigFolderByName(ctx, hashedName)
}

// GetAllPluginInstances returns all children of given type
func (obj *GlobalExternalPluginConfig) GetAllPluginInstances(ctx context.Context) (
	result []*GlobalExternalPluginInstanceConfig, err error) {
	result = make([]*GlobalExternalPluginInstanceConfig, 0, len(obj.Spec.PluginInstancesGvk))
	for _, v := range obj.Spec.PluginInstancesGvk {
		l, err := obj.client.Global().GetExternalPluginInstanceConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetPluginInstances returns child which has given displayName
func (obj *GlobalExternalPluginConfig) GetPluginInstances(ctx context.Context,
	displayName string) (result *GlobalExternalPluginInstanceConfig, err error) {
	l, ok := obj.Spec.PluginInstancesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ExternalPluginConfig", "PluginInstances", displayName)
	}
	result, err = obj.client.Global().GetExternalPluginInstanceConfigByName(ctx, l.Name)
	return
}

// AddPluginInstances calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalExternalPluginConfig) AddPluginInstances(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalPluginInstanceConfig) (result *GlobalExternalPluginInstanceConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["externalpluginconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["externalpluginconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateExternalPluginInstanceConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetExternalPluginConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ExternalPluginConfig = updatedObj.ExternalPluginConfig
	}
	return
}

// DeletePluginInstances calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalExternalPluginConfig) DeletePluginInstances(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.PluginInstancesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ExternalPluginConfig", "PluginInstances", displayName)
	}
	err = obj.client.Global().DeleteExternalPluginInstanceConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetExternalPluginConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.ExternalPluginConfig = updatedObj.ExternalPluginConfig
	}
	return
}

type externalpluginconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *externalpluginconfigGlobalTsmV1Chainer) Subscribe() {
	key := "externalpluginconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalPluginConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *externalpluginconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "externalpluginconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *externalpluginconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "externalpluginconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *externalpluginconfigGlobalTsmV1Chainer) PluginInstances(name string) *externalplugininstanceconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["externalplugininstanceconfigs.global.tsm.tanzu.vmware.com"] = name
	return &externalplugininstanceconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetPluginInstances calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *externalpluginconfigGlobalTsmV1Chainer) GetPluginInstances(ctx context.Context, displayName string) (result *GlobalExternalPluginInstanceConfig, err error) {
	hashedName := helper.GetHashedName("externalplugininstanceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetExternalPluginInstanceConfigByName(ctx, hashedName)
}

// AddPluginInstances calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *externalpluginconfigGlobalTsmV1Chainer) AddPluginInstances(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalPluginInstanceConfig) (result *GlobalExternalPluginInstanceConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("externalplugininstanceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateExternalPluginInstanceConfigByName(ctx, objToCreate)
}

// DeletePluginInstances calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *externalpluginconfigGlobalTsmV1Chainer) DeletePluginInstances(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("externalplugininstanceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteExternalPluginInstanceConfigByName(ctx, hashedName)
}

// GetExternalPluginInstanceConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetExternalPluginInstanceConfigByName(ctx context.Context, hashedName string) (*GlobalExternalPluginInstanceConfig, error) {
	key := "externalplugininstanceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ExternalPluginInstanceConfig)
		return &GlobalExternalPluginInstanceConfig{
			client:                       group.client,
			ExternalPluginInstanceConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalPluginInstanceConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalExternalPluginInstanceConfig{
			client:                       group.client,
			ExternalPluginInstanceConfig: result,
		}, nil
	}
}

// DeleteExternalPluginInstanceConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteExternalPluginInstanceConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginInstanceConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.CapabilitiyGvk != nil {
		err := group.client.
			Global().
			DeleteExternalPluginCapabilityByName(ctx, result.Spec.CapabilitiyGvk.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.MonitorsGvk {
		err := group.client.
			Global().DeleteExternalPluginMonitorByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginInstanceConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/pluginInstancesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["externalpluginconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("externalpluginconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateExternalPluginInstanceConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateExternalPluginInstanceConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalPluginInstanceConfig) (*GlobalExternalPluginInstanceConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.CapabilitiyGvk = nil
	objToCreate.Spec.MonitorsGvk = nil
	objToCreate.Spec.ClustersGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginInstanceConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["externalpluginconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("externalpluginconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"pluginInstancesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ExternalPluginInstanceConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalExternalPluginInstanceConfig{
		client:                       group.client,
		ExternalPluginInstanceConfig: result,
	}, nil
}

// UpdateExternalPluginInstanceConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateExternalPluginInstanceConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ExternalPluginInstanceConfig) (*GlobalExternalPluginInstanceConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalPluginInstanceConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueSecurityToken :=
		objToUpdate.Spec.SecurityToken
	patchOpSecurityToken := PatchOp{
		Op:    "replace",
		Path:  "/spec/securityToken",
		Value: patchValueSecurityToken,
	}
	patch = append(patch, patchOpSecurityToken)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginInstanceConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalExternalPluginInstanceConfig{
		client:                       group.client,
		ExternalPluginInstanceConfig: result,
	}, nil
}

// ListExternalPluginInstanceConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListExternalPluginInstanceConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalExternalPluginInstanceConfig, err error) {
	key := "externalplugininstanceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalExternalPluginInstanceConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ExternalPluginInstanceConfig)
			result[k] = &GlobalExternalPluginInstanceConfig{
				client:                       group.client,
				ExternalPluginInstanceConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ExternalPluginInstanceConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalExternalPluginInstanceConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalExternalPluginInstanceConfig{
				client:                       group.client,
				ExternalPluginInstanceConfig: &item,
			}
		}
	}
	return
}

type GlobalExternalPluginInstanceConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ExternalPluginInstanceConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalExternalPluginInstanceConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteExternalPluginInstanceConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ExternalPluginInstanceConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalExternalPluginInstanceConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateExternalPluginInstanceConfigByName(ctx, obj.ExternalPluginInstanceConfig)
	if err != nil {
		return err
	}
	obj.ExternalPluginInstanceConfig = result.ExternalPluginInstanceConfig
	return nil
}

func (obj *GlobalExternalPluginInstanceConfig) GetParent(ctx context.Context) (result *GlobalExternalPluginConfig, err error) {
	hashedName := helper.GetHashedName("externalpluginconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["externalpluginconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetExternalPluginConfigByName(ctx, hashedName)
}

// GetCapabilitiy returns child of given type
func (obj *GlobalExternalPluginInstanceConfig) GetCapabilitiy(ctx context.Context) (
	result *GlobalExternalPluginCapability, err error) {
	if obj.Spec.CapabilitiyGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ExternalPluginInstanceConfig", "Capabilitiy")
	}
	return obj.client.Global().GetExternalPluginCapabilityByName(ctx, obj.Spec.CapabilitiyGvk.Name)
}

// AddCapabilitiy calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalExternalPluginInstanceConfig) AddCapabilitiy(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalPluginCapability) (result *GlobalExternalPluginCapability, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["externalplugininstanceconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["externalplugininstanceconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateExternalPluginCapabilityByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetExternalPluginInstanceConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ExternalPluginInstanceConfig = updatedObj.ExternalPluginInstanceConfig
	}
	return
}

// DeleteCapabilitiy calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalExternalPluginInstanceConfig) DeleteCapabilitiy(ctx context.Context) (err error) {
	if obj.Spec.CapabilitiyGvk != nil {
		err = obj.client.
			Global().DeleteExternalPluginCapabilityByName(ctx, obj.Spec.CapabilitiyGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetExternalPluginInstanceConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.ExternalPluginInstanceConfig = updatedObj.ExternalPluginInstanceConfig
	}
	return
}

// GetAllMonitors returns all children of given type
func (obj *GlobalExternalPluginInstanceConfig) GetAllMonitors(ctx context.Context) (
	result []*GlobalExternalPluginMonitor, err error) {
	result = make([]*GlobalExternalPluginMonitor, 0, len(obj.Spec.MonitorsGvk))
	for _, v := range obj.Spec.MonitorsGvk {
		l, err := obj.client.Global().GetExternalPluginMonitorByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetMonitors returns child which has given displayName
func (obj *GlobalExternalPluginInstanceConfig) GetMonitors(ctx context.Context,
	displayName string) (result *GlobalExternalPluginMonitor, err error) {
	l, ok := obj.Spec.MonitorsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ExternalPluginInstanceConfig", "Monitors", displayName)
	}
	result, err = obj.client.Global().GetExternalPluginMonitorByName(ctx, l.Name)
	return
}

// AddMonitors calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalExternalPluginInstanceConfig) AddMonitors(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalPluginMonitor) (result *GlobalExternalPluginMonitor, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["externalplugininstanceconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["externalplugininstanceconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateExternalPluginMonitorByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetExternalPluginInstanceConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ExternalPluginInstanceConfig = updatedObj.ExternalPluginInstanceConfig
	}
	return
}

// DeleteMonitors calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalExternalPluginInstanceConfig) DeleteMonitors(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.MonitorsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ExternalPluginInstanceConfig", "Monitors", displayName)
	}
	err = obj.client.Global().DeleteExternalPluginMonitorByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetExternalPluginInstanceConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.ExternalPluginInstanceConfig = updatedObj.ExternalPluginInstanceConfig
	}
	return
}

// GetAllClusters returns all links of given type
func (obj *GlobalExternalPluginInstanceConfig) GetAllClusters(ctx context.Context) (
	result []*GlobalCluster, err error) {
	result = make([]*GlobalCluster, 0, len(obj.Spec.ClustersGvk))
	for _, v := range obj.Spec.ClustersGvk {
		l, err := obj.client.Global().GetClusterByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetClusters returns link which has given displayName
func (obj *GlobalExternalPluginInstanceConfig) GetClusters(ctx context.Context,
	displayName string) (result *GlobalCluster, err error) {
	l, ok := obj.Spec.ClustersGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ExternalPluginInstanceConfig", "Clusters", displayName)
	}
	result, err = obj.client.Global().GetClusterByName(ctx, l.Name)
	return
}

// LinkClusters links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalExternalPluginInstanceConfig) LinkClusters(ctx context.Context,
	linkToAdd *GlobalCluster) error {

	payload := "{\"spec\": {\"clustersGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"Cluster\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ExternalPluginInstanceConfigs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ExternalPluginInstanceConfig = result
	return nil
}

// UnlinkClusters unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalExternalPluginInstanceConfig) UnlinkClusters(ctx context.Context,
	linkToRemove *GlobalCluster) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/clustersGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ExternalPluginInstanceConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ExternalPluginInstanceConfig = result
	return nil

}

type externalplugininstanceconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *externalplugininstanceconfigGlobalTsmV1Chainer) Subscribe() {
	key := "externalplugininstanceconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalPluginInstanceConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *externalplugininstanceconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "externalplugininstanceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *externalplugininstanceconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "externalplugininstanceconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *externalplugininstanceconfigGlobalTsmV1Chainer) Capabilitiy(name string) *externalplugincapabilityGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["externalplugincapabilities.global.tsm.tanzu.vmware.com"] = name
	return &externalplugincapabilityGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetCapabilitiy calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *externalplugininstanceconfigGlobalTsmV1Chainer) GetCapabilitiy(ctx context.Context, displayName string) (result *GlobalExternalPluginCapability, err error) {
	hashedName := helper.GetHashedName("externalplugincapabilities.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetExternalPluginCapabilityByName(ctx, hashedName)
}

// AddCapabilitiy calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *externalplugininstanceconfigGlobalTsmV1Chainer) AddCapabilitiy(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalPluginCapability) (result *GlobalExternalPluginCapability, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("externalplugincapabilities.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateExternalPluginCapabilityByName(ctx, objToCreate)
}

// DeleteCapabilitiy calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *externalplugininstanceconfigGlobalTsmV1Chainer) DeleteCapabilitiy(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("externalplugincapabilities.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteExternalPluginCapabilityByName(ctx, hashedName)
}

func (c *externalplugininstanceconfigGlobalTsmV1Chainer) Monitors(name string) *externalpluginmonitorGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["externalpluginmonitors.global.tsm.tanzu.vmware.com"] = name
	return &externalpluginmonitorGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetMonitors calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *externalplugininstanceconfigGlobalTsmV1Chainer) GetMonitors(ctx context.Context, displayName string) (result *GlobalExternalPluginMonitor, err error) {
	hashedName := helper.GetHashedName("externalpluginmonitors.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetExternalPluginMonitorByName(ctx, hashedName)
}

// AddMonitors calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *externalplugininstanceconfigGlobalTsmV1Chainer) AddMonitors(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalPluginMonitor) (result *GlobalExternalPluginMonitor, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("externalpluginmonitors.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateExternalPluginMonitorByName(ctx, objToCreate)
}

// DeleteMonitors calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *externalplugininstanceconfigGlobalTsmV1Chainer) DeleteMonitors(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("externalpluginmonitors.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteExternalPluginMonitorByName(ctx, hashedName)
}

// GetExternalPluginMonitorByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetExternalPluginMonitorByName(ctx context.Context, hashedName string) (*GlobalExternalPluginMonitor, error) {
	key := "externalpluginmonitors.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ExternalPluginMonitor)
		return &GlobalExternalPluginMonitor{
			client:                group.client,
			ExternalPluginMonitor: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalPluginMonitors().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalExternalPluginMonitor{
			client:                group.client,
			ExternalPluginMonitor: result,
		}, nil
	}
}

// DeleteExternalPluginMonitorByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteExternalPluginMonitorByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginMonitors().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginMonitors().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/monitorsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["externalplugininstanceconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("externalplugininstanceconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginInstanceConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateExternalPluginMonitorByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateExternalPluginMonitorByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalPluginMonitor) (*GlobalExternalPluginMonitor, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginMonitors().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["externalplugininstanceconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("externalplugininstanceconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"monitorsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ExternalPluginMonitor\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginInstanceConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalExternalPluginMonitor{
		client:                group.client,
		ExternalPluginMonitor: result,
	}, nil
}

// UpdateExternalPluginMonitorByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateExternalPluginMonitorByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ExternalPluginMonitor) (*GlobalExternalPluginMonitor, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalPluginMonitors().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueObjType :=
		objToUpdate.Spec.ObjType
	patchOpObjType := PatchOp{
		Op:    "replace",
		Path:  "/spec/objType",
		Value: patchValueObjType,
	}
	patch = append(patch, patchOpObjType)

	patchValuePluginCapability :=
		objToUpdate.Spec.PluginCapability
	patchOpPluginCapability := PatchOp{
		Op:    "replace",
		Path:  "/spec/pluginCapability",
		Value: patchValuePluginCapability,
	}
	patch = append(patch, patchOpPluginCapability)

	patchValueFn :=
		objToUpdate.Spec.Fn
	patchOpFn := PatchOp{
		Op:    "replace",
		Path:  "/spec/fn",
		Value: patchValueFn,
	}
	patch = append(patch, patchOpFn)

	patchValueArg1 :=
		objToUpdate.Spec.Arg1
	patchOpArg1 := PatchOp{
		Op:    "replace",
		Path:  "/spec/arg1",
		Value: patchValueArg1,
	}
	patch = append(patch, patchOpArg1)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalPluginMonitors().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalExternalPluginMonitor{
		client:                group.client,
		ExternalPluginMonitor: result,
	}, nil
}

// ListExternalPluginMonitors returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListExternalPluginMonitors(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalExternalPluginMonitor, err error) {
	key := "externalpluginmonitors.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalExternalPluginMonitor, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ExternalPluginMonitor)
			result[k] = &GlobalExternalPluginMonitor{
				client:                group.client,
				ExternalPluginMonitor: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ExternalPluginMonitors().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalExternalPluginMonitor, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalExternalPluginMonitor{
				client:                group.client,
				ExternalPluginMonitor: &item,
			}
		}
	}
	return
}

type GlobalExternalPluginMonitor struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ExternalPluginMonitor
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalExternalPluginMonitor) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteExternalPluginMonitorByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ExternalPluginMonitor = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalExternalPluginMonitor) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateExternalPluginMonitorByName(ctx, obj.ExternalPluginMonitor)
	if err != nil {
		return err
	}
	obj.ExternalPluginMonitor = result.ExternalPluginMonitor
	return nil
}

func (obj *GlobalExternalPluginMonitor) GetParent(ctx context.Context) (result *GlobalExternalPluginInstanceConfig, err error) {
	hashedName := helper.GetHashedName("externalplugininstanceconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["externalplugininstanceconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetExternalPluginInstanceConfigByName(ctx, hashedName)
}

type externalpluginmonitorGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *externalpluginmonitorGlobalTsmV1Chainer) Subscribe() {
	key := "externalpluginmonitors.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalPluginMonitorInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *externalpluginmonitorGlobalTsmV1Chainer) Unsubscribe() {
	key := "externalpluginmonitors.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *externalpluginmonitorGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "externalpluginmonitors.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetExternalServicesRTByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetExternalServicesRTByName(ctx context.Context, hashedName string) (*GlobalExternalServicesRT, error) {
	key := "externalservicesrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ExternalServicesRT)
		return &GlobalExternalServicesRT{
			client:             group.client,
			ExternalServicesRT: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalServicesRTs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalExternalServicesRT{
			client:             group.client,
			ExternalServicesRT: result,
		}, nil
	}
}

// DeleteExternalServicesRTByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteExternalServicesRTByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalServicesRTs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ExternalServicesRTs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/externalServicesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateExternalServicesRTByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateExternalServicesRTByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalServicesRT) (*GlobalExternalServicesRT, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalServicesRTs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"externalServicesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ExternalServicesRT\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalExternalServicesRT{
		client:             group.client,
		ExternalServicesRT: result,
	}, nil
}

// UpdateExternalServicesRTByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateExternalServicesRTByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ExternalServicesRT) (*GlobalExternalServicesRT, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalServicesRTs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueOwnedBy :=
		objToUpdate.Spec.OwnedBy
	patchOpOwnedBy := PatchOp{
		Op:    "replace",
		Path:  "/spec/ownedBy",
		Value: patchValueOwnedBy,
	}
	patch = append(patch, patchOpOwnedBy)

	patchValueCreatedByGNS :=
		objToUpdate.Spec.CreatedByGNS
	patchOpCreatedByGNS := PatchOp{
		Op:    "replace",
		Path:  "/spec/createdByGNS",
		Value: patchValueCreatedByGNS,
	}
	patch = append(patch, patchOpCreatedByGNS)

	patchValueCreatedByESName :=
		objToUpdate.Spec.CreatedByESName
	patchOpCreatedByESName := PatchOp{
		Op:    "replace",
		Path:  "/spec/createdByESName",
		Value: patchValueCreatedByESName,
	}
	patch = append(patch, patchOpCreatedByESName)

	patchValueCreatedBySDFolder :=
		objToUpdate.Spec.CreatedBySDFolder
	patchOpCreatedBySDFolder := PatchOp{
		Op:    "replace",
		Path:  "/spec/createdBySDFolder",
		Value: patchValueCreatedBySDFolder,
	}
	patch = append(patch, patchOpCreatedBySDFolder)

	patchValueCreatedBySDEntry :=
		objToUpdate.Spec.CreatedBySDEntry
	patchOpCreatedBySDEntry := PatchOp{
		Op:    "replace",
		Path:  "/spec/createdBySDEntry",
		Value: patchValueCreatedBySDEntry,
	}
	patch = append(patch, patchOpCreatedBySDEntry)

	patchValueServicePort :=
		objToUpdate.Spec.ServicePort
	patchOpServicePort := PatchOp{
		Op:    "replace",
		Path:  "/spec/servicePort",
		Value: patchValueServicePort,
	}
	patch = append(patch, patchOpServicePort)

	patchValueProtocol :=
		objToUpdate.Spec.Protocol
	patchOpProtocol := PatchOp{
		Op:    "replace",
		Path:  "/spec/protocol",
		Value: patchValueProtocol,
	}
	patch = append(patch, patchOpProtocol)

	patchValueHostname :=
		objToUpdate.Spec.Hostname
	patchOpHostname := PatchOp{
		Op:    "replace",
		Path:  "/spec/hostname",
		Value: patchValueHostname,
	}
	patch = append(patch, patchOpHostname)

	patchValuePort :=
		objToUpdate.Spec.Port
	patchOpPort := PatchOp{
		Op:    "replace",
		Path:  "/spec/port",
		Value: patchValuePort,
	}
	patch = append(patch, patchOpPort)

	patchValueServerCertificate :=
		objToUpdate.Spec.ServerCertificate
	patchOpServerCertificate := PatchOp{
		Op:    "replace",
		Path:  "/spec/serverCertificate",
		Value: patchValueServerCertificate,
	}
	patch = append(patch, patchOpServerCertificate)

	patchValueHostnameAlias :=
		objToUpdate.Spec.HostnameAlias
	patchOpHostnameAlias := PatchOp{
		Op:    "replace",
		Path:  "/spec/hostnameAlias",
		Value: patchValueHostnameAlias,
	}
	patch = append(patch, patchOpHostnameAlias)

	if objToUpdate.Spec.EndpointList != nil {
		patchValueEndpointList :=
			objToUpdate.Spec.EndpointList
		patchOpEndpointList := PatchOp{
			Op:    "replace",
			Path:  "/spec/endpointList",
			Value: patchValueEndpointList,
		}
		patch = append(patch, patchOpEndpointList)
	}

	if objToUpdate.Spec.EgressGateways != nil {
		patchValueEgressGateways :=
			objToUpdate.Spec.EgressGateways
		patchOpEgressGateways := PatchOp{
			Op:    "replace",
			Path:  "/spec/egressGateways",
			Value: patchValueEgressGateways,
		}
		patch = append(patch, patchOpEgressGateways)
	}

	patchValueClientCertificate :=
		objToUpdate.Spec.ClientCertificate
	patchOpClientCertificate := PatchOp{
		Op:    "replace",
		Path:  "/spec/clientCertificate",
		Value: patchValueClientCertificate,
	}
	patch = append(patch, patchOpClientCertificate)

	patchValueClientKey :=
		objToUpdate.Spec.ClientKey
	patchOpClientKey := PatchOp{
		Op:    "replace",
		Path:  "/spec/clientKey",
		Value: patchValueClientKey,
	}
	patch = append(patch, patchOpClientKey)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalServicesRTs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalExternalServicesRT{
		client:             group.client,
		ExternalServicesRT: result,
	}, nil
}

// ListExternalServicesRTs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListExternalServicesRTs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalExternalServicesRT, err error) {
	key := "externalservicesrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalExternalServicesRT, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ExternalServicesRT)
			result[k] = &GlobalExternalServicesRT{
				client:             group.client,
				ExternalServicesRT: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ExternalServicesRTs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalExternalServicesRT, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalExternalServicesRT{
				client:             group.client,
				ExternalServicesRT: &item,
			}
		}
	}
	return
}

type GlobalExternalServicesRT struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ExternalServicesRT
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalExternalServicesRT) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteExternalServicesRTByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ExternalServicesRT = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalExternalServicesRT) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateExternalServicesRTByName(ctx, obj.ExternalServicesRT)
	if err != nil {
		return err
	}
	obj.ExternalServicesRT = result.ExternalServicesRT
	return nil
}

func (obj *GlobalExternalServicesRT) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

type externalservicesrtGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *externalservicesrtGlobalTsmV1Chainer) Subscribe() {
	key := "externalservicesrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalServicesRTInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *externalservicesrtGlobalTsmV1Chainer) Unsubscribe() {
	key := "externalservicesrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *externalservicesrtGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "externalservicesrts.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetFeatureFlagByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetFeatureFlagByName(ctx context.Context, hashedName string) (*GlobalFeatureFlag, error) {
	key := "featureflags.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.FeatureFlag)
		return &GlobalFeatureFlag{
			client:      group.client,
			FeatureFlag: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			FeatureFlags().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalFeatureFlag{
			client:      group.client,
			FeatureFlag: result,
		}, nil
	}
}

// DeleteFeatureFlagByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteFeatureFlagByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		FeatureFlags().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		FeatureFlags().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/featureFlagsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateFeatureFlagByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateFeatureFlagByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.FeatureFlag) (*GlobalFeatureFlag, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		FeatureFlags().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"featureFlagsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"FeatureFlag\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalFeatureFlag{
		client:      group.client,
		FeatureFlag: result,
	}, nil
}

// UpdateFeatureFlagByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateFeatureFlagByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.FeatureFlag) (*GlobalFeatureFlag, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			FeatureFlags().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueEnable :=
		objToUpdate.Spec.Enable
	patchOpEnable := PatchOp{
		Op:    "replace",
		Path:  "/spec/enable",
		Value: patchValueEnable,
	}
	patch = append(patch, patchOpEnable)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		FeatureFlags().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalFeatureFlag{
		client:      group.client,
		FeatureFlag: result,
	}, nil
}

// ListFeatureFlags returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListFeatureFlags(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalFeatureFlag, err error) {
	key := "featureflags.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalFeatureFlag, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.FeatureFlag)
			result[k] = &GlobalFeatureFlag{
				client:      group.client,
				FeatureFlag: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			FeatureFlags().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalFeatureFlag, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalFeatureFlag{
				client:      group.client,
				FeatureFlag: &item,
			}
		}
	}
	return
}

type GlobalFeatureFlag struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.FeatureFlag
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalFeatureFlag) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteFeatureFlagByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.FeatureFlag = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalFeatureFlag) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateFeatureFlagByName(ctx, obj.FeatureFlag)
	if err != nil {
		return err
	}
	obj.FeatureFlag = result.FeatureFlag
	return nil
}

func (obj *GlobalFeatureFlag) GetParent(ctx context.Context) (result *GlobalConfig, err error) {
	hashedName := helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetConfigByName(ctx, hashedName)
}

type featureflagGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *featureflagGlobalTsmV1Chainer) Subscribe() {
	key := "featureflags.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewFeatureFlagInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *featureflagGlobalTsmV1Chainer) Unsubscribe() {
	key := "featureflags.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *featureflagGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "featureflags.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetGatewayConfigListenerCertificateByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGatewayConfigListenerCertificateByName(ctx context.Context, hashedName string) (*GlobalGatewayConfigListenerCertificate, error) {
	key := "gatewayconfiglistenercertificates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.GatewayConfigListenerCertificate)
		return &GlobalGatewayConfigListenerCertificate{
			client:                           group.client,
			GatewayConfigListenerCertificate: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			GatewayConfigListenerCertificates().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGatewayConfigListenerCertificate{
			client:                           group.client,
			GatewayConfigListenerCertificate: result,
		}, nil
	}
}

// DeleteGatewayConfigListenerCertificateByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGatewayConfigListenerCertificateByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GatewayConfigListenerCertificates().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		GatewayConfigListenerCertificates().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/certificateGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GatewayConfigAdditionalListenerses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGatewayConfigListenerCertificateByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGatewayConfigListenerCertificateByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GatewayConfigListenerCertificate) (*GlobalGatewayConfigListenerCertificate, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GatewayConfigListenerCertificates().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/certificateGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "GatewayConfigListenerCertificate",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GatewayConfigAdditionalListenerses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGatewayConfigListenerCertificate{
		client:                           group.client,
		GatewayConfigListenerCertificate: result,
	}, nil
}

// UpdateGatewayConfigListenerCertificateByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGatewayConfigListenerCertificateByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.GatewayConfigListenerCertificate) (*GlobalGatewayConfigListenerCertificate, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			GatewayConfigListenerCertificates().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueEncryptedCertificate :=
		objToUpdate.Spec.EncryptedCertificate
	patchOpEncryptedCertificate := PatchOp{
		Op:    "replace",
		Path:  "/spec/encryptedCertificate",
		Value: patchValueEncryptedCertificate,
	}
	patch = append(patch, patchOpEncryptedCertificate)

	patchValueEncryptedPrivateKey :=
		objToUpdate.Spec.EncryptedPrivateKey
	patchOpEncryptedPrivateKey := PatchOp{
		Op:    "replace",
		Path:  "/spec/encryptedPrivateKey",
		Value: patchValueEncryptedPrivateKey,
	}
	patch = append(patch, patchOpEncryptedPrivateKey)

	patchValueEncryptedCertChain :=
		objToUpdate.Spec.EncryptedCertChain
	patchOpEncryptedCertChain := PatchOp{
		Op:    "replace",
		Path:  "/spec/encryptedCertChain",
		Value: patchValueEncryptedCertChain,
	}
	patch = append(patch, patchOpEncryptedCertChain)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		GatewayConfigListenerCertificates().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGatewayConfigListenerCertificate{
		client:                           group.client,
		GatewayConfigListenerCertificate: result,
	}, nil
}

// ListGatewayConfigListenerCertificates returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGatewayConfigListenerCertificates(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGatewayConfigListenerCertificate, err error) {
	key := "gatewayconfiglistenercertificates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGatewayConfigListenerCertificate, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.GatewayConfigListenerCertificate)
			result[k] = &GlobalGatewayConfigListenerCertificate{
				client:                           group.client,
				GatewayConfigListenerCertificate: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			GatewayConfigListenerCertificates().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGatewayConfigListenerCertificate, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGatewayConfigListenerCertificate{
				client:                           group.client,
				GatewayConfigListenerCertificate: &item,
			}
		}
	}
	return
}

type GlobalGatewayConfigListenerCertificate struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.GatewayConfigListenerCertificate
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGatewayConfigListenerCertificate) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGatewayConfigListenerCertificateByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.GatewayConfigListenerCertificate = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGatewayConfigListenerCertificate) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGatewayConfigListenerCertificateByName(ctx, obj.GatewayConfigListenerCertificate)
	if err != nil {
		return err
	}
	obj.GatewayConfigListenerCertificate = result.GatewayConfigListenerCertificate
	return nil
}

func (obj *GlobalGatewayConfigListenerCertificate) GetParent(ctx context.Context) (result *GlobalGatewayConfigAdditionalListeners, err error) {
	hashedName := helper.GetHashedName("gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGatewayConfigAdditionalListenersByName(ctx, hashedName)
}

type gatewayconfiglistenercertificateGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *gatewayconfiglistenercertificateGlobalTsmV1Chainer) Subscribe() {
	key := "gatewayconfiglistenercertificates.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGatewayConfigListenerCertificateInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *gatewayconfiglistenercertificateGlobalTsmV1Chainer) Unsubscribe() {
	key := "gatewayconfiglistenercertificates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *gatewayconfiglistenercertificateGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "gatewayconfiglistenercertificates.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetGatewayConfigAdditionalListenersByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGatewayConfigAdditionalListenersByName(ctx context.Context, hashedName string) (*GlobalGatewayConfigAdditionalListeners, error) {
	key := "gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.GatewayConfigAdditionalListeners)
		return &GlobalGatewayConfigAdditionalListeners{
			client:                           group.client,
			GatewayConfigAdditionalListeners: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			GatewayConfigAdditionalListenerses().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGatewayConfigAdditionalListeners{
			client:                           group.client,
			GatewayConfigAdditionalListeners: result,
		}, nil
	}
}

// DeleteGatewayConfigAdditionalListenersByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGatewayConfigAdditionalListenersByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GatewayConfigAdditionalListenerses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.CertificateGvk != nil {
		err := group.client.
			Global().
			DeleteGatewayConfigListenerCertificateByName(ctx, result.Spec.CertificateGvk.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ListenerRoutesGvk {
		err := group.client.
			Global().DeleteGatewayConfigListenerDestinationRouteByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		GatewayConfigAdditionalListenerses().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/additionalListenersGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gatewayconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gatewayconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GatewayConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGatewayConfigAdditionalListenersByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGatewayConfigAdditionalListenersByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GatewayConfigAdditionalListeners) (*GlobalGatewayConfigAdditionalListeners, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.CertificateGvk = nil
	objToCreate.Spec.ListenerRoutesGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GatewayConfigAdditionalListenerses().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gatewayconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gatewayconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"additionalListenersGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"GatewayConfigAdditionalListeners\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GatewayConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGatewayConfigAdditionalListeners{
		client:                           group.client,
		GatewayConfigAdditionalListeners: result,
	}, nil
}

// UpdateGatewayConfigAdditionalListenersByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGatewayConfigAdditionalListenersByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.GatewayConfigAdditionalListeners) (*GlobalGatewayConfigAdditionalListeners, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			GatewayConfigAdditionalListenerses().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValuePort :=
		objToUpdate.Spec.Port
	patchOpPort := PatchOp{
		Op:    "replace",
		Path:  "/spec/port",
		Value: patchValuePort,
	}
	patch = append(patch, patchOpPort)

	patchValueProtocol :=
		objToUpdate.Spec.Protocol
	patchOpProtocol := PatchOp{
		Op:    "replace",
		Path:  "/spec/protocol",
		Value: patchValueProtocol,
	}
	patch = append(patch, patchOpProtocol)

	patchValueTlsMode :=
		objToUpdate.Spec.TlsMode
	patchOpTlsMode := PatchOp{
		Op:    "replace",
		Path:  "/spec/tlsMode",
		Value: patchValueTlsMode,
	}
	patch = append(patch, patchOpTlsMode)

	patchValueOwnedBy :=
		objToUpdate.Spec.OwnedBy
	patchOpOwnedBy := PatchOp{
		Op:    "replace",
		Path:  "/spec/ownedBy",
		Value: patchValueOwnedBy,
	}
	patch = append(patch, patchOpOwnedBy)

	if objToUpdate.Spec.Hosts != nil {
		patchValueHosts :=
			objToUpdate.Spec.Hosts
		patchOpHosts := PatchOp{
			Op:    "replace",
			Path:  "/spec/hosts",
			Value: patchValueHosts,
		}
		patch = append(patch, patchOpHosts)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		GatewayConfigAdditionalListenerses().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGatewayConfigAdditionalListeners{
		client:                           group.client,
		GatewayConfigAdditionalListeners: result,
	}, nil
}

// ListGatewayConfigAdditionalListenerses returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGatewayConfigAdditionalListenerses(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGatewayConfigAdditionalListeners, err error) {
	key := "gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGatewayConfigAdditionalListeners, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.GatewayConfigAdditionalListeners)
			result[k] = &GlobalGatewayConfigAdditionalListeners{
				client:                           group.client,
				GatewayConfigAdditionalListeners: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			GatewayConfigAdditionalListenerses().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGatewayConfigAdditionalListeners, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGatewayConfigAdditionalListeners{
				client:                           group.client,
				GatewayConfigAdditionalListeners: &item,
			}
		}
	}
	return
}

type GlobalGatewayConfigAdditionalListeners struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.GatewayConfigAdditionalListeners
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGatewayConfigAdditionalListeners) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGatewayConfigAdditionalListenersByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.GatewayConfigAdditionalListeners = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGatewayConfigAdditionalListeners) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGatewayConfigAdditionalListenersByName(ctx, obj.GatewayConfigAdditionalListeners)
	if err != nil {
		return err
	}
	obj.GatewayConfigAdditionalListeners = result.GatewayConfigAdditionalListeners
	return nil
}

func (obj *GlobalGatewayConfigAdditionalListeners) GetParent(ctx context.Context) (result *GlobalGatewayConfig, err error) {
	hashedName := helper.GetHashedName("gatewayconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gatewayconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGatewayConfigByName(ctx, hashedName)
}

// GetCertificate returns child of given type
func (obj *GlobalGatewayConfigAdditionalListeners) GetCertificate(ctx context.Context) (
	result *GlobalGatewayConfigListenerCertificate, err error) {
	if obj.Spec.CertificateGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GatewayConfigAdditionalListeners", "Certificate")
	}
	return obj.client.Global().GetGatewayConfigListenerCertificateByName(ctx, obj.Spec.CertificateGvk.Name)
}

// AddCertificate calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGatewayConfigAdditionalListeners) AddCertificate(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GatewayConfigListenerCertificate) (result *GlobalGatewayConfigListenerCertificate, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGatewayConfigListenerCertificateByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGatewayConfigAdditionalListenersByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GatewayConfigAdditionalListeners = updatedObj.GatewayConfigAdditionalListeners
	}
	return
}

// DeleteCertificate calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGatewayConfigAdditionalListeners) DeleteCertificate(ctx context.Context) (err error) {
	if obj.Spec.CertificateGvk != nil {
		err = obj.client.
			Global().DeleteGatewayConfigListenerCertificateByName(ctx, obj.Spec.CertificateGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetGatewayConfigAdditionalListenersByName(ctx, obj.GetName())
	if err == nil {
		obj.GatewayConfigAdditionalListeners = updatedObj.GatewayConfigAdditionalListeners
	}
	return
}

// GetAllListenerRoutes returns all children of given type
func (obj *GlobalGatewayConfigAdditionalListeners) GetAllListenerRoutes(ctx context.Context) (
	result []*GlobalGatewayConfigListenerDestinationRoute, err error) {
	result = make([]*GlobalGatewayConfigListenerDestinationRoute, 0, len(obj.Spec.ListenerRoutesGvk))
	for _, v := range obj.Spec.ListenerRoutesGvk {
		l, err := obj.client.Global().GetGatewayConfigListenerDestinationRouteByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetListenerRoutes returns child which has given displayName
func (obj *GlobalGatewayConfigAdditionalListeners) GetListenerRoutes(ctx context.Context,
	displayName string) (result *GlobalGatewayConfigListenerDestinationRoute, err error) {
	l, ok := obj.Spec.ListenerRoutesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GatewayConfigAdditionalListeners", "ListenerRoutes", displayName)
	}
	result, err = obj.client.Global().GetGatewayConfigListenerDestinationRouteByName(ctx, l.Name)
	return
}

// AddListenerRoutes calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGatewayConfigAdditionalListeners) AddListenerRoutes(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GatewayConfigListenerDestinationRoute) (result *GlobalGatewayConfigListenerDestinationRoute, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGatewayConfigListenerDestinationRouteByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGatewayConfigAdditionalListenersByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GatewayConfigAdditionalListeners = updatedObj.GatewayConfigAdditionalListeners
	}
	return
}

// DeleteListenerRoutes calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGatewayConfigAdditionalListeners) DeleteListenerRoutes(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ListenerRoutesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GatewayConfigAdditionalListeners", "ListenerRoutes", displayName)
	}
	err = obj.client.Global().DeleteGatewayConfigListenerDestinationRouteByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGatewayConfigAdditionalListenersByName(ctx, obj.GetName())
	if err == nil {
		obj.GatewayConfigAdditionalListeners = updatedObj.GatewayConfigAdditionalListeners
	}
	return
}

type gatewayconfigadditionallistenersGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *gatewayconfigadditionallistenersGlobalTsmV1Chainer) Subscribe() {
	key := "gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGatewayConfigAdditionalListenersInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *gatewayconfigadditionallistenersGlobalTsmV1Chainer) Unsubscribe() {
	key := "gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *gatewayconfigadditionallistenersGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *gatewayconfigadditionallistenersGlobalTsmV1Chainer) Certificate(name string) *gatewayconfiglistenercertificateGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gatewayconfiglistenercertificates.global.tsm.tanzu.vmware.com"] = name
	return &gatewayconfiglistenercertificateGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetCertificate calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gatewayconfigadditionallistenersGlobalTsmV1Chainer) GetCertificate(ctx context.Context, displayName string) (result *GlobalGatewayConfigListenerCertificate, err error) {
	hashedName := helper.GetHashedName("gatewayconfiglistenercertificates.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGatewayConfigListenerCertificateByName(ctx, hashedName)
}

// AddCertificate calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gatewayconfigadditionallistenersGlobalTsmV1Chainer) AddCertificate(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GatewayConfigListenerCertificate) (result *GlobalGatewayConfigListenerCertificate, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gatewayconfiglistenercertificates.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGatewayConfigListenerCertificateByName(ctx, objToCreate)
}

// DeleteCertificate calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gatewayconfigadditionallistenersGlobalTsmV1Chainer) DeleteCertificate(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gatewayconfiglistenercertificates.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGatewayConfigListenerCertificateByName(ctx, hashedName)
}

func (c *gatewayconfigadditionallistenersGlobalTsmV1Chainer) ListenerRoutes(name string) *gatewayconfiglistenerdestinationrouteGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gatewayconfiglistenerdestinationroutes.global.tsm.tanzu.vmware.com"] = name
	return &gatewayconfiglistenerdestinationrouteGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetListenerRoutes calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gatewayconfigadditionallistenersGlobalTsmV1Chainer) GetListenerRoutes(ctx context.Context, displayName string) (result *GlobalGatewayConfigListenerDestinationRoute, err error) {
	hashedName := helper.GetHashedName("gatewayconfiglistenerdestinationroutes.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGatewayConfigListenerDestinationRouteByName(ctx, hashedName)
}

// AddListenerRoutes calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gatewayconfigadditionallistenersGlobalTsmV1Chainer) AddListenerRoutes(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GatewayConfigListenerDestinationRoute) (result *GlobalGatewayConfigListenerDestinationRoute, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gatewayconfiglistenerdestinationroutes.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGatewayConfigListenerDestinationRouteByName(ctx, objToCreate)
}

// DeleteListenerRoutes calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gatewayconfigadditionallistenersGlobalTsmV1Chainer) DeleteListenerRoutes(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gatewayconfiglistenerdestinationroutes.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGatewayConfigListenerDestinationRouteByName(ctx, hashedName)
}

// GetGatewayConfigListenerDestinationRouteByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGatewayConfigListenerDestinationRouteByName(ctx context.Context, hashedName string) (*GlobalGatewayConfigListenerDestinationRoute, error) {
	key := "gatewayconfiglistenerdestinationroutes.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.GatewayConfigListenerDestinationRoute)
		return &GlobalGatewayConfigListenerDestinationRoute{
			client:                                group.client,
			GatewayConfigListenerDestinationRoute: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			GatewayConfigListenerDestinationRoutes().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGatewayConfigListenerDestinationRoute{
			client:                                group.client,
			GatewayConfigListenerDestinationRoute: result,
		}, nil
	}
}

// DeleteGatewayConfigListenerDestinationRouteByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGatewayConfigListenerDestinationRouteByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GatewayConfigListenerDestinationRoutes().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		GatewayConfigListenerDestinationRoutes().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/listenerRoutesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GatewayConfigAdditionalListenerses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGatewayConfigListenerDestinationRouteByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGatewayConfigListenerDestinationRouteByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GatewayConfigListenerDestinationRoute) (*GlobalGatewayConfigListenerDestinationRoute, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GatewayConfigListenerDestinationRoutes().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"listenerRoutesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"GatewayConfigListenerDestinationRoute\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GatewayConfigAdditionalListenerses().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGatewayConfigListenerDestinationRoute{
		client:                                group.client,
		GatewayConfigListenerDestinationRoute: result,
	}, nil
}

// UpdateGatewayConfigListenerDestinationRouteByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGatewayConfigListenerDestinationRouteByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.GatewayConfigListenerDestinationRoute) (*GlobalGatewayConfigListenerDestinationRoute, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			GatewayConfigListenerDestinationRoutes().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueHost :=
		objToUpdate.Spec.Host
	patchOpHost := PatchOp{
		Op:    "replace",
		Path:  "/spec/host",
		Value: patchValueHost,
	}
	patch = append(patch, patchOpHost)

	patchValueTarget :=
		objToUpdate.Spec.Target
	patchOpTarget := PatchOp{
		Op:    "replace",
		Path:  "/spec/target",
		Value: patchValueTarget,
	}
	patch = append(patch, patchOpTarget)

	if objToUpdate.Spec.Paths != nil {
		patchValuePaths :=
			objToUpdate.Spec.Paths
		patchOpPaths := PatchOp{
			Op:    "replace",
			Path:  "/spec/paths",
			Value: patchValuePaths,
		}
		patch = append(patch, patchOpPaths)
	}

	patchValuePort :=
		objToUpdate.Spec.Port
	patchOpPort := PatchOp{
		Op:    "replace",
		Path:  "/spec/port",
		Value: patchValuePort,
	}
	patch = append(patch, patchOpPort)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		GatewayConfigListenerDestinationRoutes().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGatewayConfigListenerDestinationRoute{
		client:                                group.client,
		GatewayConfigListenerDestinationRoute: result,
	}, nil
}

// ListGatewayConfigListenerDestinationRoutes returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGatewayConfigListenerDestinationRoutes(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGatewayConfigListenerDestinationRoute, err error) {
	key := "gatewayconfiglistenerdestinationroutes.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGatewayConfigListenerDestinationRoute, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.GatewayConfigListenerDestinationRoute)
			result[k] = &GlobalGatewayConfigListenerDestinationRoute{
				client:                                group.client,
				GatewayConfigListenerDestinationRoute: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			GatewayConfigListenerDestinationRoutes().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGatewayConfigListenerDestinationRoute, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGatewayConfigListenerDestinationRoute{
				client:                                group.client,
				GatewayConfigListenerDestinationRoute: &item,
			}
		}
	}
	return
}

type GlobalGatewayConfigListenerDestinationRoute struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.GatewayConfigListenerDestinationRoute
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGatewayConfigListenerDestinationRoute) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGatewayConfigListenerDestinationRouteByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.GatewayConfigListenerDestinationRoute = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGatewayConfigListenerDestinationRoute) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGatewayConfigListenerDestinationRouteByName(ctx, obj.GatewayConfigListenerDestinationRoute)
	if err != nil {
		return err
	}
	obj.GatewayConfigListenerDestinationRoute = result.GatewayConfigListenerDestinationRoute
	return nil
}

func (obj *GlobalGatewayConfigListenerDestinationRoute) GetParent(ctx context.Context) (result *GlobalGatewayConfigAdditionalListeners, err error) {
	hashedName := helper.GetHashedName("gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGatewayConfigAdditionalListenersByName(ctx, hashedName)
}

type gatewayconfiglistenerdestinationrouteGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *gatewayconfiglistenerdestinationrouteGlobalTsmV1Chainer) Subscribe() {
	key := "gatewayconfiglistenerdestinationroutes.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGatewayConfigListenerDestinationRouteInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *gatewayconfiglistenerdestinationrouteGlobalTsmV1Chainer) Unsubscribe() {
	key := "gatewayconfiglistenerdestinationroutes.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *gatewayconfiglistenerdestinationrouteGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "gatewayconfiglistenerdestinationroutes.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetGatewayConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGatewayConfigByName(ctx context.Context, hashedName string) (*GlobalGatewayConfig, error) {
	key := "gatewayconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.GatewayConfig)
		return &GlobalGatewayConfig{
			client:        group.client,
			GatewayConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			GatewayConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGatewayConfig{
			client:        group.client,
			GatewayConfig: result,
		}, nil
	}
}

// DeleteGatewayConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGatewayConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GatewayConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.AdditionalListenersGvk {
		err := group.client.
			Global().DeleteGatewayConfigAdditionalListenersByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		GatewayConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gatewayConfigGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGatewayConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGatewayConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GatewayConfig) (*GlobalGatewayConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.AdditionalListenersGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GatewayConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"gatewayConfigGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"GatewayConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGatewayConfig{
		client:        group.client,
		GatewayConfig: result,
	}, nil
}

// UpdateGatewayConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGatewayConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.GatewayConfig) (*GlobalGatewayConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			GatewayConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueOwnedBy :=
		objToUpdate.Spec.OwnedBy
	patchOpOwnedBy := PatchOp{
		Op:    "replace",
		Path:  "/spec/ownedBy",
		Value: patchValueOwnedBy,
	}
	patch = append(patch, patchOpOwnedBy)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueListeners :=
		objToUpdate.Spec.Listeners
	patchOpListeners := PatchOp{
		Op:    "replace",
		Path:  "/spec/listeners",
		Value: patchValueListeners,
	}
	patch = append(patch, patchOpListeners)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		GatewayConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGatewayConfig{
		client:        group.client,
		GatewayConfig: result,
	}, nil
}

// ListGatewayConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGatewayConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGatewayConfig, err error) {
	key := "gatewayconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGatewayConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.GatewayConfig)
			result[k] = &GlobalGatewayConfig{
				client:        group.client,
				GatewayConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			GatewayConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGatewayConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGatewayConfig{
				client:        group.client,
				GatewayConfig: &item,
			}
		}
	}
	return
}

type GlobalGatewayConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.GatewayConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGatewayConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGatewayConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.GatewayConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGatewayConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGatewayConfigByName(ctx, obj.GatewayConfig)
	if err != nil {
		return err
	}
	obj.GatewayConfig = result.GatewayConfig
	return nil
}

func (obj *GlobalGatewayConfig) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

// GetAllAdditionalListeners returns all children of given type
func (obj *GlobalGatewayConfig) GetAllAdditionalListeners(ctx context.Context) (
	result []*GlobalGatewayConfigAdditionalListeners, err error) {
	result = make([]*GlobalGatewayConfigAdditionalListeners, 0, len(obj.Spec.AdditionalListenersGvk))
	for _, v := range obj.Spec.AdditionalListenersGvk {
		l, err := obj.client.Global().GetGatewayConfigAdditionalListenersByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetAdditionalListeners returns child which has given displayName
func (obj *GlobalGatewayConfig) GetAdditionalListeners(ctx context.Context,
	displayName string) (result *GlobalGatewayConfigAdditionalListeners, err error) {
	l, ok := obj.Spec.AdditionalListenersGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GatewayConfig", "AdditionalListeners", displayName)
	}
	result, err = obj.client.Global().GetGatewayConfigAdditionalListenersByName(ctx, l.Name)
	return
}

// AddAdditionalListeners calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGatewayConfig) AddAdditionalListeners(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GatewayConfigAdditionalListeners) (result *GlobalGatewayConfigAdditionalListeners, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gatewayconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gatewayconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGatewayConfigAdditionalListenersByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGatewayConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GatewayConfig = updatedObj.GatewayConfig
	}
	return
}

// DeleteAdditionalListeners calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGatewayConfig) DeleteAdditionalListeners(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.AdditionalListenersGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GatewayConfig", "AdditionalListeners", displayName)
	}
	err = obj.client.Global().DeleteGatewayConfigAdditionalListenersByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGatewayConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.GatewayConfig = updatedObj.GatewayConfig
	}
	return
}

type gatewayconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *gatewayconfigGlobalTsmV1Chainer) Subscribe() {
	key := "gatewayconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGatewayConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *gatewayconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "gatewayconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *gatewayconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "gatewayconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *gatewayconfigGlobalTsmV1Chainer) AdditionalListeners(name string) *gatewayconfigadditionallistenersGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com"] = name
	return &gatewayconfigadditionallistenersGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetAdditionalListeners calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gatewayconfigGlobalTsmV1Chainer) GetAdditionalListeners(ctx context.Context, displayName string) (result *GlobalGatewayConfigAdditionalListeners, err error) {
	hashedName := helper.GetHashedName("gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGatewayConfigAdditionalListenersByName(ctx, hashedName)
}

// AddAdditionalListeners calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gatewayconfigGlobalTsmV1Chainer) AddAdditionalListeners(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GatewayConfigAdditionalListeners) (result *GlobalGatewayConfigAdditionalListeners, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGatewayConfigAdditionalListenersByName(ctx, objToCreate)
}

// DeleteAdditionalListeners calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gatewayconfigGlobalTsmV1Chainer) DeleteAdditionalListeners(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gatewayconfigadditionallistenerses.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGatewayConfigAdditionalListenersByName(ctx, hashedName)
}

// GetGatewayByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGatewayByName(ctx context.Context, hashedName string) (*GlobalGateway, error) {
	key := "gateways.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Gateway)
		return &GlobalGateway{
			client:  group.client,
			Gateway: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Gateways().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGateway{
			client:  group.client,
			Gateway: result,
		}, nil
	}
}

// DeleteGatewayByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGatewayByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Gateways().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Gateways().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gatewaysGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGatewayByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGatewayByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Gateway) (*GlobalGateway, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ServicesGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Gateways().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"gatewaysGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"Gateway\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGateway{
		client:  group.client,
		Gateway: result,
	}, nil
}

// UpdateGatewayByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGatewayByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Gateway) (*GlobalGateway, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Gateways().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueAnnotations :=
		objToUpdate.Spec.Annotations
	patchOpAnnotations := PatchOp{
		Op:    "replace",
		Path:  "/spec/annotations",
		Value: patchValueAnnotations,
	}
	patch = append(patch, patchOpAnnotations)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Gateways().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGateway{
		client:  group.client,
		Gateway: result,
	}, nil
}

// ListGateways returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGateways(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGateway, err error) {
	key := "gateways.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGateway, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Gateway)
			result[k] = &GlobalGateway{
				client:  group.client,
				Gateway: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Gateways().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGateway, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGateway{
				client:  group.client,
				Gateway: &item,
			}
		}
	}
	return
}

type GlobalGateway struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Gateway
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGateway) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGatewayByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Gateway = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGateway) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGatewayByName(ctx, obj.Gateway)
	if err != nil {
		return err
	}
	obj.Gateway = result.Gateway
	return nil
}

func (obj *GlobalGateway) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

// GetAllServices returns all links of given type
func (obj *GlobalGateway) GetAllServices(ctx context.Context) (
	result []*GlobalService, err error) {
	result = make([]*GlobalService, 0, len(obj.Spec.ServicesGvk))
	for _, v := range obj.Spec.ServicesGvk {
		l, err := obj.client.Global().GetServiceByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServices returns link which has given displayName
func (obj *GlobalGateway) GetServices(ctx context.Context,
	displayName string) (result *GlobalService, err error) {
	l, ok := obj.Spec.ServicesGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.Gateway", "Services", displayName)
	}
	result, err = obj.client.Global().GetServiceByName(ctx, l.Name)
	return
}

// LinkServices links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalGateway) LinkServices(ctx context.Context,
	linkToAdd *GlobalService) error {

	payload := "{\"spec\": {\"servicesGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"Service\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().Gateways().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Gateway = result
	return nil
}

// UnlinkServices unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalGateway) UnlinkServices(ctx context.Context,
	linkToRemove *GlobalService) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/servicesGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Gateways().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Gateway = result
	return nil

}

type gatewayGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *gatewayGlobalTsmV1Chainer) Subscribe() {
	key := "gateways.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGatewayInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *gatewayGlobalTsmV1Chainer) Unsubscribe() {
	key := "gateways.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *gatewayGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "gateways.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetGeoDiscoveryRTByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGeoDiscoveryRTByName(ctx context.Context, hashedName string) (*GlobalGeoDiscoveryRT, error) {
	key := "geodiscoveryrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.GeoDiscoveryRT)
		return &GlobalGeoDiscoveryRT{
			client:         group.client,
			GeoDiscoveryRT: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			GeoDiscoveryRTs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGeoDiscoveryRT{
			client:         group.client,
			GeoDiscoveryRT: result,
		}, nil
	}
}

// DeleteGeoDiscoveryRTByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGeoDiscoveryRTByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GeoDiscoveryRTs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		GeoDiscoveryRTs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/geoDiscoveryGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGeoDiscoveryRTByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGeoDiscoveryRTByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GeoDiscoveryRT) (*GlobalGeoDiscoveryRT, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GeoDiscoveryRTs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"geoDiscoveryGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"GeoDiscoveryRT\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGeoDiscoveryRT{
		client:         group.client,
		GeoDiscoveryRT: result,
	}, nil
}

// UpdateGeoDiscoveryRTByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGeoDiscoveryRTByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.GeoDiscoveryRT) (*GlobalGeoDiscoveryRT, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			GeoDiscoveryRTs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueGnsid :=
		objToUpdate.Spec.Gnsid
	patchOpGnsid := PatchOp{
		Op:    "replace",
		Path:  "/spec/gnsid",
		Value: patchValueGnsid,
	}
	patch = append(patch, patchOpGnsid)

	patchValueSelectors :=
		objToUpdate.Spec.Selectors
	patchOpSelectors := PatchOp{
		Op:    "replace",
		Path:  "/spec/selectors",
		Value: patchValueSelectors,
	}
	patch = append(patch, patchOpSelectors)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		GeoDiscoveryRTs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGeoDiscoveryRT{
		client:         group.client,
		GeoDiscoveryRT: result,
	}, nil
}

// ListGeoDiscoveryRTs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGeoDiscoveryRTs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGeoDiscoveryRT, err error) {
	key := "geodiscoveryrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGeoDiscoveryRT, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.GeoDiscoveryRT)
			result[k] = &GlobalGeoDiscoveryRT{
				client:         group.client,
				GeoDiscoveryRT: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			GeoDiscoveryRTs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGeoDiscoveryRT, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGeoDiscoveryRT{
				client:         group.client,
				GeoDiscoveryRT: &item,
			}
		}
	}
	return
}

type GlobalGeoDiscoveryRT struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.GeoDiscoveryRT
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGeoDiscoveryRT) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGeoDiscoveryRTByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.GeoDiscoveryRT = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGeoDiscoveryRT) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGeoDiscoveryRTByName(ctx, obj.GeoDiscoveryRT)
	if err != nil {
		return err
	}
	obj.GeoDiscoveryRT = result.GeoDiscoveryRT
	return nil
}

func (obj *GlobalGeoDiscoveryRT) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

type geodiscoveryrtGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *geodiscoveryrtGlobalTsmV1Chainer) Subscribe() {
	key := "geodiscoveryrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGeoDiscoveryRTInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *geodiscoveryrtGlobalTsmV1Chainer) Unsubscribe() {
	key := "geodiscoveryrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *geodiscoveryrtGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "geodiscoveryrts.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetGeoDiscoveryByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGeoDiscoveryByName(ctx context.Context, hashedName string) (*GlobalGeoDiscovery, error) {
	key := "geodiscoveries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.GeoDiscovery)
		return &GlobalGeoDiscovery{
			client:       group.client,
			GeoDiscovery: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			GeoDiscoveries().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGeoDiscovery{
			client:       group.client,
			GeoDiscovery: result,
		}, nil
	}
}

// DeleteGeoDiscoveryByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGeoDiscoveryByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GeoDiscoveries().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		GeoDiscoveries().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/geoDiscoveryGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGeoDiscoveryByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGeoDiscoveryByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GeoDiscovery) (*GlobalGeoDiscovery, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GeoDiscoveries().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"geoDiscoveryGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"GeoDiscovery\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGeoDiscovery{
		client:       group.client,
		GeoDiscovery: result,
	}, nil
}

// UpdateGeoDiscoveryByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGeoDiscoveryByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.GeoDiscovery) (*GlobalGeoDiscovery, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			GeoDiscoveries().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		GeoDiscoveries().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGeoDiscovery{
		client:       group.client,
		GeoDiscovery: result,
	}, nil
}

// ListGeoDiscoveries returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGeoDiscoveries(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGeoDiscovery, err error) {
	key := "geodiscoveries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGeoDiscovery, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.GeoDiscovery)
			result[k] = &GlobalGeoDiscovery{
				client:       group.client,
				GeoDiscovery: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			GeoDiscoveries().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGeoDiscovery, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGeoDiscovery{
				client:       group.client,
				GeoDiscovery: &item,
			}
		}
	}
	return
}

type GlobalGeoDiscovery struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.GeoDiscovery
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGeoDiscovery) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGeoDiscoveryByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.GeoDiscovery = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGeoDiscovery) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGeoDiscoveryByName(ctx, obj.GeoDiscovery)
	if err != nil {
		return err
	}
	obj.GeoDiscovery = result.GeoDiscovery
	return nil
}

func (obj *GlobalGeoDiscovery) GetParent(ctx context.Context) (result *GlobalGNS, err error) {
	hashedName := helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnss.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGNSByName(ctx, hashedName)
}

type geodiscoveryGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *geodiscoveryGlobalTsmV1Chainer) Subscribe() {
	key := "geodiscoveries.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGeoDiscoveryInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *geodiscoveryGlobalTsmV1Chainer) Unsubscribe() {
	key := "geodiscoveries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *geodiscoveryGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "geodiscoveries.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetGlobalNsByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGlobalNsByName(ctx context.Context, hashedName string) (*GlobalGlobalNs, error) {
	key := "globalnses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.GlobalNs)
		return &GlobalGlobalNs{
			client:   group.client,
			GlobalNs: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			GlobalNses().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGlobalNs{
			client:   group.client,
			GlobalNs: result,
		}, nil
	}
}

// DeleteGlobalNsByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGlobalNsByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GlobalNses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.RoutingPoliciesGvk {
		err := group.client.
			Global().DeleteRPolicyByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		GlobalNses().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gnsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["awsconnectors.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("awsconnectors.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		AwsConnectors().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGlobalNsByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGlobalNsByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GlobalNs) (*GlobalGlobalNs, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.RoutingPoliciesGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GlobalNses().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["awsconnectors.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("awsconnectors.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"gnsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"GlobalNs\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		AwsConnectors().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGlobalNs{
		client:   group.client,
		GlobalNs: result,
	}, nil
}

// UpdateGlobalNsByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGlobalNsByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.GlobalNs) (*GlobalGlobalNs, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			GlobalNses().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueGnsName :=
		objToUpdate.Spec.GnsName
	patchOpGnsName := PatchOp{
		Op:    "replace",
		Path:  "/spec/gnsName",
		Value: patchValueGnsName,
	}
	patch = append(patch, patchOpGnsName)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		GlobalNses().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGlobalNs{
		client:   group.client,
		GlobalNs: result,
	}, nil
}

// ListGlobalNses returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGlobalNses(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGlobalNs, err error) {
	key := "globalnses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGlobalNs, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.GlobalNs)
			result[k] = &GlobalGlobalNs{
				client:   group.client,
				GlobalNs: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			GlobalNses().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGlobalNs, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGlobalNs{
				client:   group.client,
				GlobalNs: &item,
			}
		}
	}
	return
}

type GlobalGlobalNs struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.GlobalNs
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGlobalNs) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGlobalNsByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.GlobalNs = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGlobalNs) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGlobalNsByName(ctx, obj.GlobalNs)
	if err != nil {
		return err
	}
	obj.GlobalNs = result.GlobalNs
	return nil
}

func (obj *GlobalGlobalNs) GetParent(ctx context.Context) (result *GlobalAwsConnector, err error) {
	hashedName := helper.GetHashedName("awsconnectors.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["awsconnectors.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetAwsConnectorByName(ctx, hashedName)
}

// GetAllRoutingPolicies returns all children of given type
func (obj *GlobalGlobalNs) GetAllRoutingPolicies(ctx context.Context) (
	result []*GlobalRPolicy, err error) {
	result = make([]*GlobalRPolicy, 0, len(obj.Spec.RoutingPoliciesGvk))
	for _, v := range obj.Spec.RoutingPoliciesGvk {
		l, err := obj.client.Global().GetRPolicyByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetRoutingPolicies returns child which has given displayName
func (obj *GlobalGlobalNs) GetRoutingPolicies(ctx context.Context,
	displayName string) (result *GlobalRPolicy, err error) {
	l, ok := obj.Spec.RoutingPoliciesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GlobalNs", "RoutingPolicies", displayName)
	}
	result, err = obj.client.Global().GetRPolicyByName(ctx, l.Name)
	return
}

// AddRoutingPolicies calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGlobalNs) AddRoutingPolicies(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.RPolicy) (result *GlobalRPolicy, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["globalnses.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["globalnses.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateRPolicyByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGlobalNsByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GlobalNs = updatedObj.GlobalNs
	}
	return
}

// DeleteRoutingPolicies calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGlobalNs) DeleteRoutingPolicies(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.RoutingPoliciesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GlobalNs", "RoutingPolicies", displayName)
	}
	err = obj.client.Global().DeleteRPolicyByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGlobalNsByName(ctx, obj.GetName())
	if err == nil {
		obj.GlobalNs = updatedObj.GlobalNs
	}
	return
}

type globalnsGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *globalnsGlobalTsmV1Chainer) Subscribe() {
	key := "globalnses.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGlobalNsInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *globalnsGlobalTsmV1Chainer) Unsubscribe() {
	key := "globalnses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *globalnsGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "globalnses.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *globalnsGlobalTsmV1Chainer) RoutingPolicies(name string) *rpolicyGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["rpolicies.global.tsm.tanzu.vmware.com"] = name
	return &rpolicyGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetRoutingPolicies calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *globalnsGlobalTsmV1Chainer) GetRoutingPolicies(ctx context.Context, displayName string) (result *GlobalRPolicy, err error) {
	hashedName := helper.GetHashedName("rpolicies.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetRPolicyByName(ctx, hashedName)
}

// AddRoutingPolicies calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *globalnsGlobalTsmV1Chainer) AddRoutingPolicies(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.RPolicy) (result *GlobalRPolicy, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("rpolicies.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateRPolicyByName(ctx, objToCreate)
}

// DeleteRoutingPolicies calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *globalnsGlobalTsmV1Chainer) DeleteRoutingPolicies(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("rpolicies.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteRPolicyByName(ctx, hashedName)
}

// GetGlobalRegistrationServiceByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGlobalRegistrationServiceByName(ctx context.Context, hashedName string) (*GlobalGlobalRegistrationService, error) {
	key := "globalregistrationservices.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.GlobalRegistrationService)
		return &GlobalGlobalRegistrationService{
			client:                    group.client,
			GlobalRegistrationService: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			GlobalRegistrationServices().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGlobalRegistrationService{
			client:                    group.client,
			GlobalRegistrationService: result,
		}, nil
	}
}

// DeleteGlobalRegistrationServiceByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGlobalRegistrationServiceByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GlobalRegistrationServices().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.TenantsGvk {
		err := group.client.
			Global().DeleteTenantByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.TenantTokenGvk {
		err := group.client.
			Global().DeleteTenantTokenByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		GlobalRegistrationServices().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/globalRegistrationServiceGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["allsparkserviceses.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("allsparkserviceses.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		AllSparkServiceses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGlobalRegistrationServiceByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGlobalRegistrationServiceByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GlobalRegistrationService) (*GlobalGlobalRegistrationService, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.TenantsGvk = nil
	objToCreate.Spec.TenantTokenGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GlobalRegistrationServices().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["allsparkserviceses.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("allsparkserviceses.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/globalRegistrationServiceGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "GlobalRegistrationService",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		AllSparkServiceses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGlobalRegistrationService{
		client:                    group.client,
		GlobalRegistrationService: result,
	}, nil
}

// UpdateGlobalRegistrationServiceByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGlobalRegistrationServiceByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.GlobalRegistrationService) (*GlobalGlobalRegistrationService, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			GlobalRegistrationServices().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueBuildID :=
		objToUpdate.Spec.BuildID
	patchOpBuildID := PatchOp{
		Op:    "replace",
		Path:  "/spec/buildID",
		Value: patchValueBuildID,
	}
	patch = append(patch, patchOpBuildID)

	patchValueVersion :=
		objToUpdate.Spec.Version
	patchOpVersion := PatchOp{
		Op:    "replace",
		Path:  "/spec/version",
		Value: patchValueVersion,
	}
	patch = append(patch, patchOpVersion)

	patchValueErrorCount :=
		objToUpdate.Spec.ErrorCount
	patchOpErrorCount := PatchOp{
		Op:    "replace",
		Path:  "/spec/errorCount",
		Value: patchValueErrorCount,
	}
	patch = append(patch, patchOpErrorCount)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		GlobalRegistrationServices().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGlobalRegistrationService{
		client:                    group.client,
		GlobalRegistrationService: result,
	}, nil
}

// ListGlobalRegistrationServices returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGlobalRegistrationServices(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGlobalRegistrationService, err error) {
	key := "globalregistrationservices.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGlobalRegistrationService, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.GlobalRegistrationService)
			result[k] = &GlobalGlobalRegistrationService{
				client:                    group.client,
				GlobalRegistrationService: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			GlobalRegistrationServices().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGlobalRegistrationService, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGlobalRegistrationService{
				client:                    group.client,
				GlobalRegistrationService: &item,
			}
		}
	}
	return
}

type GlobalGlobalRegistrationService struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.GlobalRegistrationService
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGlobalRegistrationService) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGlobalRegistrationServiceByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.GlobalRegistrationService = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGlobalRegistrationService) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGlobalRegistrationServiceByName(ctx, obj.GlobalRegistrationService)
	if err != nil {
		return err
	}
	obj.GlobalRegistrationService = result.GlobalRegistrationService
	return nil
}

func (obj *GlobalGlobalRegistrationService) GetParent(ctx context.Context) (result *GlobalAllSparkServices, err error) {
	hashedName := helper.GetHashedName("allsparkserviceses.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["allsparkserviceses.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetAllSparkServicesByName(ctx, hashedName)
}

// GetAllTenants returns all children of given type
func (obj *GlobalGlobalRegistrationService) GetAllTenants(ctx context.Context) (
	result []*GlobalTenant, err error) {
	result = make([]*GlobalTenant, 0, len(obj.Spec.TenantsGvk))
	for _, v := range obj.Spec.TenantsGvk {
		l, err := obj.client.Global().GetTenantByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetTenants returns child which has given displayName
func (obj *GlobalGlobalRegistrationService) GetTenants(ctx context.Context,
	displayName string) (result *GlobalTenant, err error) {
	l, ok := obj.Spec.TenantsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GlobalRegistrationService", "Tenants", displayName)
	}
	result, err = obj.client.Global().GetTenantByName(ctx, l.Name)
	return
}

// AddTenants calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGlobalRegistrationService) AddTenants(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Tenant) (result *GlobalTenant, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["globalregistrationservices.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["globalregistrationservices.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateTenantByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGlobalRegistrationServiceByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GlobalRegistrationService = updatedObj.GlobalRegistrationService
	}
	return
}

// DeleteTenants calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGlobalRegistrationService) DeleteTenants(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.TenantsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GlobalRegistrationService", "Tenants", displayName)
	}
	err = obj.client.Global().DeleteTenantByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGlobalRegistrationServiceByName(ctx, obj.GetName())
	if err == nil {
		obj.GlobalRegistrationService = updatedObj.GlobalRegistrationService
	}
	return
}

// GetAllTenantToken returns all children of given type
func (obj *GlobalGlobalRegistrationService) GetAllTenantToken(ctx context.Context) (
	result []*GlobalTenantToken, err error) {
	result = make([]*GlobalTenantToken, 0, len(obj.Spec.TenantTokenGvk))
	for _, v := range obj.Spec.TenantTokenGvk {
		l, err := obj.client.Global().GetTenantTokenByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetTenantToken returns child which has given displayName
func (obj *GlobalGlobalRegistrationService) GetTenantToken(ctx context.Context,
	displayName string) (result *GlobalTenantToken, err error) {
	l, ok := obj.Spec.TenantTokenGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GlobalRegistrationService", "TenantToken", displayName)
	}
	result, err = obj.client.Global().GetTenantTokenByName(ctx, l.Name)
	return
}

// AddTenantToken calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGlobalRegistrationService) AddTenantToken(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.TenantToken) (result *GlobalTenantToken, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["globalregistrationservices.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["globalregistrationservices.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateTenantTokenByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGlobalRegistrationServiceByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GlobalRegistrationService = updatedObj.GlobalRegistrationService
	}
	return
}

// DeleteTenantToken calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGlobalRegistrationService) DeleteTenantToken(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.TenantTokenGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GlobalRegistrationService", "TenantToken", displayName)
	}
	err = obj.client.Global().DeleteTenantTokenByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGlobalRegistrationServiceByName(ctx, obj.GetName())
	if err == nil {
		obj.GlobalRegistrationService = updatedObj.GlobalRegistrationService
	}
	return
}

type globalregistrationserviceGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *globalregistrationserviceGlobalTsmV1Chainer) Subscribe() {
	key := "globalregistrationservices.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGlobalRegistrationServiceInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *globalregistrationserviceGlobalTsmV1Chainer) Unsubscribe() {
	key := "globalregistrationservices.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *globalregistrationserviceGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "globalregistrationservices.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *globalregistrationserviceGlobalTsmV1Chainer) Tenants(name string) *tenantGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["tenants.global.tsm.tanzu.vmware.com"] = name
	return &tenantGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetTenants calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *globalregistrationserviceGlobalTsmV1Chainer) GetTenants(ctx context.Context, displayName string) (result *GlobalTenant, err error) {
	hashedName := helper.GetHashedName("tenants.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetTenantByName(ctx, hashedName)
}

// AddTenants calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *globalregistrationserviceGlobalTsmV1Chainer) AddTenants(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Tenant) (result *GlobalTenant, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("tenants.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateTenantByName(ctx, objToCreate)
}

// DeleteTenants calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *globalregistrationserviceGlobalTsmV1Chainer) DeleteTenants(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("tenants.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteTenantByName(ctx, hashedName)
}

func (c *globalregistrationserviceGlobalTsmV1Chainer) TenantToken(name string) *tenanttokenGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["tenanttokens.global.tsm.tanzu.vmware.com"] = name
	return &tenanttokenGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetTenantToken calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *globalregistrationserviceGlobalTsmV1Chainer) GetTenantToken(ctx context.Context, displayName string) (result *GlobalTenantToken, err error) {
	hashedName := helper.GetHashedName("tenanttokens.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetTenantTokenByName(ctx, hashedName)
}

// AddTenantToken calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *globalregistrationserviceGlobalTsmV1Chainer) AddTenantToken(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.TenantToken) (result *GlobalTenantToken, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("tenanttokens.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateTenantTokenByName(ctx, objToCreate)
}

// DeleteTenantToken calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *globalregistrationserviceGlobalTsmV1Chainer) DeleteTenantToken(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("tenanttokens.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteTenantTokenByName(ctx, hashedName)
}

// GetGlobalNamespaceByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGlobalNamespaceByName(ctx context.Context, hashedName string) (*GlobalGlobalNamespace, error) {
	key := "globalnamespaces.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.GlobalNamespace)
		return &GlobalGlobalNamespace{
			client:          group.client,
			GlobalNamespace: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			GlobalNamespaces().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGlobalNamespace{
			client:          group.client,
			GlobalNamespace: result,
		}, nil
	}
}

// DeleteGlobalNamespaceByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGlobalNamespaceByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GlobalNamespaces().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.GnsGvk {
		err := group.client.
			Global().DeleteGNSByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		GlobalNamespaces().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/globalNamespaceGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGlobalNamespaceByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGlobalNamespaceByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GlobalNamespace) (*GlobalGlobalNamespace, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.GnsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GlobalNamespaces().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/globalNamespaceGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "GlobalNamespace",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGlobalNamespace{
		client:          group.client,
		GlobalNamespace: result,
	}, nil
}

// UpdateGlobalNamespaceByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGlobalNamespaceByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.GlobalNamespace) (*GlobalGlobalNamespace, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			GlobalNamespaces().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		GlobalNamespaces().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGlobalNamespace{
		client:          group.client,
		GlobalNamespace: result,
	}, nil
}

// ListGlobalNamespaces returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGlobalNamespaces(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGlobalNamespace, err error) {
	key := "globalnamespaces.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGlobalNamespace, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.GlobalNamespace)
			result[k] = &GlobalGlobalNamespace{
				client:          group.client,
				GlobalNamespace: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			GlobalNamespaces().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGlobalNamespace, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGlobalNamespace{
				client:          group.client,
				GlobalNamespace: &item,
			}
		}
	}
	return
}

type GlobalGlobalNamespace struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.GlobalNamespace
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGlobalNamespace) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGlobalNamespaceByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.GlobalNamespace = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGlobalNamespace) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGlobalNamespaceByName(ctx, obj.GlobalNamespace)
	if err != nil {
		return err
	}
	obj.GlobalNamespace = result.GlobalNamespace
	return nil
}

func (obj *GlobalGlobalNamespace) GetParent(ctx context.Context) (result *GlobalConfig, err error) {
	hashedName := helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetConfigByName(ctx, hashedName)
}

// GetAllGns returns all children of given type
func (obj *GlobalGlobalNamespace) GetAllGns(ctx context.Context) (
	result []*GlobalGNS, err error) {
	result = make([]*GlobalGNS, 0, len(obj.Spec.GnsGvk))
	for _, v := range obj.Spec.GnsGvk {
		l, err := obj.client.Global().GetGNSByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGns returns child which has given displayName
func (obj *GlobalGlobalNamespace) GetGns(ctx context.Context,
	displayName string) (result *GlobalGNS, err error) {
	l, ok := obj.Spec.GnsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GlobalNamespace", "Gns", displayName)
	}
	result, err = obj.client.Global().GetGNSByName(ctx, l.Name)
	return
}

// AddGns calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGlobalNamespace) AddGns(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GNS) (result *GlobalGNS, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["globalnamespaces.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["globalnamespaces.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGNSByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGlobalNamespaceByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GlobalNamespace = updatedObj.GlobalNamespace
	}
	return
}

// DeleteGns calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGlobalNamespace) DeleteGns(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.GnsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GlobalNamespace", "Gns", displayName)
	}
	err = obj.client.Global().DeleteGNSByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGlobalNamespaceByName(ctx, obj.GetName())
	if err == nil {
		obj.GlobalNamespace = updatedObj.GlobalNamespace
	}
	return
}

type globalnamespaceGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *globalnamespaceGlobalTsmV1Chainer) Subscribe() {
	key := "globalnamespaces.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGlobalNamespaceInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *globalnamespaceGlobalTsmV1Chainer) Unsubscribe() {
	key := "globalnamespaces.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *globalnamespaceGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "globalnamespaces.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *globalnamespaceGlobalTsmV1Chainer) Gns(name string) *gnsGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gnss.global.tsm.tanzu.vmware.com"] = name
	return &gnsGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGns calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *globalnamespaceGlobalTsmV1Chainer) GetGns(ctx context.Context, displayName string) (result *GlobalGNS, err error) {
	hashedName := helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGNSByName(ctx, hashedName)
}

// AddGns calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *globalnamespaceGlobalTsmV1Chainer) AddGns(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GNS) (result *GlobalGNS, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGNSByName(ctx, objToCreate)
}

// DeleteGns calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *globalnamespaceGlobalTsmV1Chainer) DeleteGns(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGNSByName(ctx, hashedName)
}

// GetGnsAccessControlPolicyRTByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGnsAccessControlPolicyRTByName(ctx context.Context, hashedName string) (*GlobalGnsAccessControlPolicyRT, error) {
	key := "gnsaccesscontrolpolicyrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.GnsAccessControlPolicyRT)
		return &GlobalGnsAccessControlPolicyRT{
			client:                   group.client,
			GnsAccessControlPolicyRT: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			GnsAccessControlPolicyRTs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGnsAccessControlPolicyRT{
			client:                   group.client,
			GnsAccessControlPolicyRT: result,
		}, nil
	}
}

// DeleteGnsAccessControlPolicyRTByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGnsAccessControlPolicyRTByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsAccessControlPolicyRTs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		GnsAccessControlPolicyRTs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gnsAccessControlPolicyGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGnsAccessControlPolicyRTByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGnsAccessControlPolicyRTByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsAccessControlPolicyRT) (*GlobalGnsAccessControlPolicyRT, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsAccessControlPolicyRTs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"gnsAccessControlPolicyGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"GnsAccessControlPolicyRT\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGnsAccessControlPolicyRT{
		client:                   group.client,
		GnsAccessControlPolicyRT: result,
	}, nil
}

// UpdateGnsAccessControlPolicyRTByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGnsAccessControlPolicyRTByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.GnsAccessControlPolicyRT) (*GlobalGnsAccessControlPolicyRT, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			GnsAccessControlPolicyRTs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueGnsid :=
		objToUpdate.Spec.Gnsid
	patchOpGnsid := PatchOp{
		Op:    "replace",
		Path:  "/spec/gnsid",
		Value: patchValueGnsid,
	}
	patch = append(patch, patchOpGnsid)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsAccessControlPolicyRTs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGnsAccessControlPolicyRT{
		client:                   group.client,
		GnsAccessControlPolicyRT: result,
	}, nil
}

// ListGnsAccessControlPolicyRTs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGnsAccessControlPolicyRTs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGnsAccessControlPolicyRT, err error) {
	key := "gnsaccesscontrolpolicyrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGnsAccessControlPolicyRT, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.GnsAccessControlPolicyRT)
			result[k] = &GlobalGnsAccessControlPolicyRT{
				client:                   group.client,
				GnsAccessControlPolicyRT: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			GnsAccessControlPolicyRTs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGnsAccessControlPolicyRT, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGnsAccessControlPolicyRT{
				client:                   group.client,
				GnsAccessControlPolicyRT: &item,
			}
		}
	}
	return
}

type GlobalGnsAccessControlPolicyRT struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.GnsAccessControlPolicyRT
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGnsAccessControlPolicyRT) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGnsAccessControlPolicyRTByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.GnsAccessControlPolicyRT = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGnsAccessControlPolicyRT) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGnsAccessControlPolicyRTByName(ctx, obj.GnsAccessControlPolicyRT)
	if err != nil {
		return err
	}
	obj.GnsAccessControlPolicyRT = result.GnsAccessControlPolicyRT
	return nil
}

func (obj *GlobalGnsAccessControlPolicyRT) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

type gnsaccesscontrolpolicyrtGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *gnsaccesscontrolpolicyrtGlobalTsmV1Chainer) Subscribe() {
	key := "gnsaccesscontrolpolicyrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGnsAccessControlPolicyRTInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *gnsaccesscontrolpolicyrtGlobalTsmV1Chainer) Unsubscribe() {
	key := "gnsaccesscontrolpolicyrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *gnsaccesscontrolpolicyrtGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "gnsaccesscontrolpolicyrts.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetGnsAccessControlPolicyByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGnsAccessControlPolicyByName(ctx context.Context, hashedName string) (*GlobalGnsAccessControlPolicy, error) {
	key := "gnsaccesscontrolpolicies.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.GnsAccessControlPolicy)
		return &GlobalGnsAccessControlPolicy{
			client:                 group.client,
			GnsAccessControlPolicy: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			GnsAccessControlPolicies().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGnsAccessControlPolicy{
			client:                 group.client,
			GnsAccessControlPolicy: result,
		}, nil
	}
}

// DeleteGnsAccessControlPolicyByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGnsAccessControlPolicyByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsAccessControlPolicies().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		GnsAccessControlPolicies().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gnsAccessControlPolicyGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGnsAccessControlPolicyByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGnsAccessControlPolicyByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsAccessControlPolicy) (*GlobalGnsAccessControlPolicy, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsAccessControlPolicies().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"gnsAccessControlPolicyGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"GnsAccessControlPolicy\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGnsAccessControlPolicy{
		client:                 group.client,
		GnsAccessControlPolicy: result,
	}, nil
}

// UpdateGnsAccessControlPolicyByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGnsAccessControlPolicyByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.GnsAccessControlPolicy) (*GlobalGnsAccessControlPolicy, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			GnsAccessControlPolicies().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsAccessControlPolicies().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGnsAccessControlPolicy{
		client:                 group.client,
		GnsAccessControlPolicy: result,
	}, nil
}

// ListGnsAccessControlPolicies returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGnsAccessControlPolicies(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGnsAccessControlPolicy, err error) {
	key := "gnsaccesscontrolpolicies.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGnsAccessControlPolicy, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.GnsAccessControlPolicy)
			result[k] = &GlobalGnsAccessControlPolicy{
				client:                 group.client,
				GnsAccessControlPolicy: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			GnsAccessControlPolicies().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGnsAccessControlPolicy, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGnsAccessControlPolicy{
				client:                 group.client,
				GnsAccessControlPolicy: &item,
			}
		}
	}
	return
}

type GlobalGnsAccessControlPolicy struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.GnsAccessControlPolicy
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGnsAccessControlPolicy) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGnsAccessControlPolicyByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.GnsAccessControlPolicy = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGnsAccessControlPolicy) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGnsAccessControlPolicyByName(ctx, obj.GnsAccessControlPolicy)
	if err != nil {
		return err
	}
	obj.GnsAccessControlPolicy = result.GnsAccessControlPolicy
	return nil
}

func (obj *GlobalGnsAccessControlPolicy) GetParent(ctx context.Context) (result *GlobalGNS, err error) {
	hashedName := helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnss.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGNSByName(ctx, hashedName)
}

type gnsaccesscontrolpolicyGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *gnsaccesscontrolpolicyGlobalTsmV1Chainer) Subscribe() {
	key := "gnsaccesscontrolpolicies.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGnsAccessControlPolicyInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *gnsaccesscontrolpolicyGlobalTsmV1Chainer) Unsubscribe() {
	key := "gnsaccesscontrolpolicies.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *gnsaccesscontrolpolicyGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "gnsaccesscontrolpolicies.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetGnsBindingRTByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGnsBindingRTByName(ctx context.Context, hashedName string) (*GlobalGnsBindingRT, error) {
	key := "gnsbindingrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.GnsBindingRT)
		return &GlobalGnsBindingRT{
			client:       group.client,
			GnsBindingRT: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			GnsBindingRTs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGnsBindingRT{
			client:       group.client,
			GnsBindingRT: result,
		}, nil
	}
}

// DeleteGnsBindingRTByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGnsBindingRTByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsBindingRTs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.GnsSvcGroupRTGvk {
		err := group.client.
			Global().DeleteGnsSvcGroupRTByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.GnsRoutingRulesGvk {
		err := group.client.
			Global().DeleteGnsRoutingRuleConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.GnsServiceEntryConfigGvk {
		err := group.client.
			Global().DeleteGnsServiceEntryConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		GnsBindingRTs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gnsBindingGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["clusterconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGnsBindingRTByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGnsBindingRTByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsBindingRT) (*GlobalGnsBindingRT, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.GnsSvcGroupRTGvk = nil
	objToCreate.Spec.GnsRoutingRulesGvk = nil
	objToCreate.Spec.GnsServiceEntryConfigGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsBindingRTs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["clusterconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"gnsBindingGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"GnsBindingRT\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGnsBindingRT{
		client:       group.client,
		GnsBindingRT: result,
	}, nil
}

// UpdateGnsBindingRTByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGnsBindingRTByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.GnsBindingRT) (*GlobalGnsBindingRT, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			GnsBindingRTs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueDomain :=
		objToUpdate.Spec.Domain
	patchOpDomain := PatchOp{
		Op:    "replace",
		Path:  "/spec/domain",
		Value: patchValueDomain,
	}
	patch = append(patch, patchOpDomain)

	if objToUpdate.Spec.Namespaces != nil {
		patchValueNamespaces :=
			objToUpdate.Spec.Namespaces
		patchOpNamespaces := PatchOp{
			Op:    "replace",
			Path:  "/spec/namespaces",
			Value: patchValueNamespaces,
		}
		patch = append(patch, patchOpNamespaces)
	}

	patchValueApiDiscoveryEnabled :=
		objToUpdate.Spec.ApiDiscoveryEnabled
	patchOpApiDiscoveryEnabled := PatchOp{
		Op:    "replace",
		Path:  "/spec/apiDiscoveryEnabled",
		Value: patchValueApiDiscoveryEnabled,
	}
	patch = append(patch, patchOpApiDiscoveryEnabled)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsBindingRTs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGnsBindingRT{
		client:       group.client,
		GnsBindingRT: result,
	}, nil
}

// ListGnsBindingRTs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGnsBindingRTs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGnsBindingRT, err error) {
	key := "gnsbindingrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGnsBindingRT, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.GnsBindingRT)
			result[k] = &GlobalGnsBindingRT{
				client:       group.client,
				GnsBindingRT: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			GnsBindingRTs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGnsBindingRT, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGnsBindingRT{
				client:       group.client,
				GnsBindingRT: &item,
			}
		}
	}
	return
}

type GlobalGnsBindingRT struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.GnsBindingRT
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGnsBindingRT) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGnsBindingRTByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.GnsBindingRT = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGnsBindingRT) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGnsBindingRTByName(ctx, obj.GnsBindingRT)
	if err != nil {
		return err
	}
	obj.GnsBindingRT = result.GnsBindingRT
	return nil
}

func (obj *GlobalGnsBindingRT) GetParent(ctx context.Context) (result *GlobalClusterConfig, err error) {
	hashedName := helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["clusterconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetClusterConfigByName(ctx, hashedName)
}

// GetAllGnsSvcGroupRT returns all children of given type
func (obj *GlobalGnsBindingRT) GetAllGnsSvcGroupRT(ctx context.Context) (
	result []*GlobalGnsSvcGroupRT, err error) {
	result = make([]*GlobalGnsSvcGroupRT, 0, len(obj.Spec.GnsSvcGroupRTGvk))
	for _, v := range obj.Spec.GnsSvcGroupRTGvk {
		l, err := obj.client.Global().GetGnsSvcGroupRTByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGnsSvcGroupRT returns child which has given displayName
func (obj *GlobalGnsBindingRT) GetGnsSvcGroupRT(ctx context.Context,
	displayName string) (result *GlobalGnsSvcGroupRT, err error) {
	l, ok := obj.Spec.GnsSvcGroupRTGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GnsBindingRT", "GnsSvcGroupRT", displayName)
	}
	result, err = obj.client.Global().GetGnsSvcGroupRTByName(ctx, l.Name)
	return
}

// AddGnsSvcGroupRT calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGnsBindingRT) AddGnsSvcGroupRT(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsSvcGroupRT) (result *GlobalGnsSvcGroupRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnsbindingrts.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnsbindingrts.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGnsSvcGroupRTByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGnsBindingRTByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GnsBindingRT = updatedObj.GnsBindingRT
	}
	return
}

// DeleteGnsSvcGroupRT calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGnsBindingRT) DeleteGnsSvcGroupRT(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.GnsSvcGroupRTGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GnsBindingRT", "GnsSvcGroupRT", displayName)
	}
	err = obj.client.Global().DeleteGnsSvcGroupRTByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGnsBindingRTByName(ctx, obj.GetName())
	if err == nil {
		obj.GnsBindingRT = updatedObj.GnsBindingRT
	}
	return
}

// GetAllGnsRoutingRules returns all children of given type
func (obj *GlobalGnsBindingRT) GetAllGnsRoutingRules(ctx context.Context) (
	result []*GlobalGnsRoutingRuleConfig, err error) {
	result = make([]*GlobalGnsRoutingRuleConfig, 0, len(obj.Spec.GnsRoutingRulesGvk))
	for _, v := range obj.Spec.GnsRoutingRulesGvk {
		l, err := obj.client.Global().GetGnsRoutingRuleConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGnsRoutingRules returns child which has given displayName
func (obj *GlobalGnsBindingRT) GetGnsRoutingRules(ctx context.Context,
	displayName string) (result *GlobalGnsRoutingRuleConfig, err error) {
	l, ok := obj.Spec.GnsRoutingRulesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GnsBindingRT", "GnsRoutingRules", displayName)
	}
	result, err = obj.client.Global().GetGnsRoutingRuleConfigByName(ctx, l.Name)
	return
}

// AddGnsRoutingRules calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGnsBindingRT) AddGnsRoutingRules(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsRoutingRuleConfig) (result *GlobalGnsRoutingRuleConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnsbindingrts.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnsbindingrts.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGnsRoutingRuleConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGnsBindingRTByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GnsBindingRT = updatedObj.GnsBindingRT
	}
	return
}

// DeleteGnsRoutingRules calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGnsBindingRT) DeleteGnsRoutingRules(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.GnsRoutingRulesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GnsBindingRT", "GnsRoutingRules", displayName)
	}
	err = obj.client.Global().DeleteGnsRoutingRuleConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGnsBindingRTByName(ctx, obj.GetName())
	if err == nil {
		obj.GnsBindingRT = updatedObj.GnsBindingRT
	}
	return
}

// GetAllGnsServiceEntryConfig returns all children of given type
func (obj *GlobalGnsBindingRT) GetAllGnsServiceEntryConfig(ctx context.Context) (
	result []*GlobalGnsServiceEntryConfig, err error) {
	result = make([]*GlobalGnsServiceEntryConfig, 0, len(obj.Spec.GnsServiceEntryConfigGvk))
	for _, v := range obj.Spec.GnsServiceEntryConfigGvk {
		l, err := obj.client.Global().GetGnsServiceEntryConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGnsServiceEntryConfig returns child which has given displayName
func (obj *GlobalGnsBindingRT) GetGnsServiceEntryConfig(ctx context.Context,
	displayName string) (result *GlobalGnsServiceEntryConfig, err error) {
	l, ok := obj.Spec.GnsServiceEntryConfigGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GnsBindingRT", "GnsServiceEntryConfig", displayName)
	}
	result, err = obj.client.Global().GetGnsServiceEntryConfigByName(ctx, l.Name)
	return
}

// AddGnsServiceEntryConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGnsBindingRT) AddGnsServiceEntryConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsServiceEntryConfig) (result *GlobalGnsServiceEntryConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnsbindingrts.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnsbindingrts.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGnsServiceEntryConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGnsBindingRTByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GnsBindingRT = updatedObj.GnsBindingRT
	}
	return
}

// DeleteGnsServiceEntryConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGnsBindingRT) DeleteGnsServiceEntryConfig(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.GnsServiceEntryConfigGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GnsBindingRT", "GnsServiceEntryConfig", displayName)
	}
	err = obj.client.Global().DeleteGnsServiceEntryConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGnsBindingRTByName(ctx, obj.GetName())
	if err == nil {
		obj.GnsBindingRT = updatedObj.GnsBindingRT
	}
	return
}

type gnsbindingrtGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *gnsbindingrtGlobalTsmV1Chainer) Subscribe() {
	key := "gnsbindingrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGnsBindingRTInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *gnsbindingrtGlobalTsmV1Chainer) Unsubscribe() {
	key := "gnsbindingrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *gnsbindingrtGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "gnsbindingrts.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *gnsbindingrtGlobalTsmV1Chainer) GnsSvcGroupRT(name string) *gnssvcgrouprtGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gnssvcgrouprts.global.tsm.tanzu.vmware.com"] = name
	return &gnssvcgrouprtGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGnsSvcGroupRT calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsbindingrtGlobalTsmV1Chainer) GetGnsSvcGroupRT(ctx context.Context, displayName string) (result *GlobalGnsSvcGroupRT, err error) {
	hashedName := helper.GetHashedName("gnssvcgrouprts.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGnsSvcGroupRTByName(ctx, hashedName)
}

// AddGnsSvcGroupRT calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsbindingrtGlobalTsmV1Chainer) AddGnsSvcGroupRT(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsSvcGroupRT) (result *GlobalGnsSvcGroupRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gnssvcgrouprts.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGnsSvcGroupRTByName(ctx, objToCreate)
}

// DeleteGnsSvcGroupRT calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsbindingrtGlobalTsmV1Chainer) DeleteGnsSvcGroupRT(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gnssvcgrouprts.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGnsSvcGroupRTByName(ctx, hashedName)
}

func (c *gnsbindingrtGlobalTsmV1Chainer) GnsRoutingRules(name string) *gnsroutingruleconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gnsroutingruleconfigs.global.tsm.tanzu.vmware.com"] = name
	return &gnsroutingruleconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGnsRoutingRules calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsbindingrtGlobalTsmV1Chainer) GetGnsRoutingRules(ctx context.Context, displayName string) (result *GlobalGnsRoutingRuleConfig, err error) {
	hashedName := helper.GetHashedName("gnsroutingruleconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGnsRoutingRuleConfigByName(ctx, hashedName)
}

// AddGnsRoutingRules calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsbindingrtGlobalTsmV1Chainer) AddGnsRoutingRules(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsRoutingRuleConfig) (result *GlobalGnsRoutingRuleConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gnsroutingruleconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGnsRoutingRuleConfigByName(ctx, objToCreate)
}

// DeleteGnsRoutingRules calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsbindingrtGlobalTsmV1Chainer) DeleteGnsRoutingRules(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gnsroutingruleconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGnsRoutingRuleConfigByName(ctx, hashedName)
}

func (c *gnsbindingrtGlobalTsmV1Chainer) GnsServiceEntryConfig(name string) *gnsserviceentryconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gnsserviceentryconfigs.global.tsm.tanzu.vmware.com"] = name
	return &gnsserviceentryconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGnsServiceEntryConfig calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsbindingrtGlobalTsmV1Chainer) GetGnsServiceEntryConfig(ctx context.Context, displayName string) (result *GlobalGnsServiceEntryConfig, err error) {
	hashedName := helper.GetHashedName("gnsserviceentryconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGnsServiceEntryConfigByName(ctx, hashedName)
}

// AddGnsServiceEntryConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsbindingrtGlobalTsmV1Chainer) AddGnsServiceEntryConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsServiceEntryConfig) (result *GlobalGnsServiceEntryConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gnsserviceentryconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGnsServiceEntryConfigByName(ctx, objToCreate)
}

// DeleteGnsServiceEntryConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsbindingrtGlobalTsmV1Chainer) DeleteGnsServiceEntryConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gnsserviceentryconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGnsServiceEntryConfigByName(ctx, hashedName)
}

// GetGnsEndpointsConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGnsEndpointsConfigByName(ctx context.Context, hashedName string) (*GlobalGnsEndpointsConfig, error) {
	key := "gnsendpointsconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.GnsEndpointsConfig)
		return &GlobalGnsEndpointsConfig{
			client:             group.client,
			GnsEndpointsConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			GnsEndpointsConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGnsEndpointsConfig{
			client:             group.client,
			GnsEndpointsConfig: result,
		}, nil
	}
}

// DeleteGnsEndpointsConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGnsEndpointsConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsEndpointsConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		GnsEndpointsConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gnsEndpointsConfigGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGnsEndpointsConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGnsEndpointsConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsEndpointsConfig) (*GlobalGnsEndpointsConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsEndpointsConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"gnsEndpointsConfigGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"GnsEndpointsConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGnsEndpointsConfig{
		client:             group.client,
		GnsEndpointsConfig: result,
	}, nil
}

// UpdateGnsEndpointsConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGnsEndpointsConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.GnsEndpointsConfig) (*GlobalGnsEndpointsConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			GnsEndpointsConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueEndpoints :=
		objToUpdate.Spec.Endpoints
	patchOpEndpoints := PatchOp{
		Op:    "replace",
		Path:  "/spec/endpoints",
		Value: patchValueEndpoints,
	}
	patch = append(patch, patchOpEndpoints)

	patchValueGnsId :=
		objToUpdate.Spec.GnsId
	patchOpGnsId := PatchOp{
		Op:    "replace",
		Path:  "/spec/gnsId",
		Value: patchValueGnsId,
	}
	patch = append(patch, patchOpGnsId)

	if objToUpdate.Spec.EndpointServices != nil {
		patchValueEndpointServices :=
			objToUpdate.Spec.EndpointServices
		patchOpEndpointServices := PatchOp{
			Op:    "replace",
			Path:  "/spec/endpointServices",
			Value: patchValueEndpointServices,
		}
		patch = append(patch, patchOpEndpointServices)
	}

	patchValueServicePortList :=
		objToUpdate.Spec.ServicePortList
	patchOpServicePortList := PatchOp{
		Op:    "replace",
		Path:  "/spec/servicePortList",
		Value: patchValueServicePortList,
	}
	patch = append(patch, patchOpServicePortList)

	patchValueSelector :=
		objToUpdate.Spec.Selector
	patchOpSelector := PatchOp{
		Op:    "replace",
		Path:  "/spec/selector",
		Value: patchValueSelector,
	}
	patch = append(patch, patchOpSelector)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsEndpointsConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGnsEndpointsConfig{
		client:             group.client,
		GnsEndpointsConfig: result,
	}, nil
}

// ListGnsEndpointsConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGnsEndpointsConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGnsEndpointsConfig, err error) {
	key := "gnsendpointsconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGnsEndpointsConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.GnsEndpointsConfig)
			result[k] = &GlobalGnsEndpointsConfig{
				client:             group.client,
				GnsEndpointsConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			GnsEndpointsConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGnsEndpointsConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGnsEndpointsConfig{
				client:             group.client,
				GnsEndpointsConfig: &item,
			}
		}
	}
	return
}

type GlobalGnsEndpointsConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.GnsEndpointsConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGnsEndpointsConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGnsEndpointsConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.GnsEndpointsConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGnsEndpointsConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGnsEndpointsConfigByName(ctx, obj.GnsEndpointsConfig)
	if err != nil {
		return err
	}
	obj.GnsEndpointsConfig = result.GnsEndpointsConfig
	return nil
}

func (obj *GlobalGnsEndpointsConfig) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

type gnsendpointsconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *gnsendpointsconfigGlobalTsmV1Chainer) Subscribe() {
	key := "gnsendpointsconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGnsEndpointsConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *gnsendpointsconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "gnsendpointsconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *gnsendpointsconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "gnsendpointsconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetExternalServiceConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetExternalServiceConfigByName(ctx context.Context, hashedName string) (*GlobalExternalServiceConfig, error) {
	key := "externalserviceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ExternalServiceConfig)
		return &GlobalExternalServiceConfig{
			client:                group.client,
			ExternalServiceConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalServiceConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalExternalServiceConfig{
			client:                group.client,
			ExternalServiceConfig: result,
		}, nil
	}
}

// DeleteExternalServiceConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteExternalServiceConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalServiceConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ExternalServiceConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/externalServicesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateExternalServiceConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateExternalServiceConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalServiceConfig) (*GlobalExternalServiceConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalServiceConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"externalServicesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ExternalServiceConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalExternalServiceConfig{
		client:                group.client,
		ExternalServiceConfig: result,
	}, nil
}

// UpdateExternalServiceConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateExternalServiceConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ExternalServiceConfig) (*GlobalExternalServiceConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ExternalServiceConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	patchValueSystem :=
		objToUpdate.Spec.System
	patchOpSystem := PatchOp{
		Op:    "replace",
		Path:  "/spec/system",
		Value: patchValueSystem,
	}
	patch = append(patch, patchOpSystem)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ExternalServiceConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalExternalServiceConfig{
		client:                group.client,
		ExternalServiceConfig: result,
	}, nil
}

// ListExternalServiceConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListExternalServiceConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalExternalServiceConfig, err error) {
	key := "externalserviceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalExternalServiceConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ExternalServiceConfig)
			result[k] = &GlobalExternalServiceConfig{
				client:                group.client,
				ExternalServiceConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ExternalServiceConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalExternalServiceConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalExternalServiceConfig{
				client:                group.client,
				ExternalServiceConfig: &item,
			}
		}
	}
	return
}

type GlobalExternalServiceConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ExternalServiceConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalExternalServiceConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteExternalServiceConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ExternalServiceConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalExternalServiceConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateExternalServiceConfigByName(ctx, obj.ExternalServiceConfig)
	if err != nil {
		return err
	}
	obj.ExternalServiceConfig = result.ExternalServiceConfig
	return nil
}

func (obj *GlobalExternalServiceConfig) GetParent(ctx context.Context) (result *GlobalGNS, err error) {
	hashedName := helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnss.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGNSByName(ctx, hashedName)
}

type externalserviceconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *externalserviceconfigGlobalTsmV1Chainer) Subscribe() {
	key := "externalserviceconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewExternalServiceConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *externalserviceconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "externalserviceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *externalserviceconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "externalserviceconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetPublicServiceRouteConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetPublicServiceRouteConfigByName(ctx context.Context, hashedName string) (*GlobalPublicServiceRouteConfig, error) {
	key := "publicservicerouteconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.PublicServiceRouteConfig)
		return &GlobalPublicServiceRouteConfig{
			client:                   group.client,
			PublicServiceRouteConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			PublicServiceRouteConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalPublicServiceRouteConfig{
			client:                   group.client,
			PublicServiceRouteConfig: result,
		}, nil
	}
}

// DeletePublicServiceRouteConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeletePublicServiceRouteConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		PublicServiceRouteConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		PublicServiceRouteConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/routingConfigsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["publicserviceconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("publicserviceconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		PublicServiceConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreatePublicServiceRouteConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreatePublicServiceRouteConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PublicServiceRouteConfig) (*GlobalPublicServiceRouteConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		PublicServiceRouteConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["publicserviceconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("publicserviceconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"routingConfigsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"PublicServiceRouteConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		PublicServiceConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalPublicServiceRouteConfig{
		client:                   group.client,
		PublicServiceRouteConfig: result,
	}, nil
}

// UpdatePublicServiceRouteConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdatePublicServiceRouteConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.PublicServiceRouteConfig) (*GlobalPublicServiceRouteConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			PublicServiceRouteConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueType :=
		objToUpdate.Spec.Type
	patchOpType := PatchOp{
		Op:    "replace",
		Path:  "/spec/type",
		Value: patchValueType,
	}
	patch = append(patch, patchOpType)

	patchValueRoutes :=
		objToUpdate.Spec.Routes
	patchOpRoutes := PatchOp{
		Op:    "replace",
		Path:  "/spec/routes",
		Value: patchValueRoutes,
	}
	patch = append(patch, patchOpRoutes)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		PublicServiceRouteConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalPublicServiceRouteConfig{
		client:                   group.client,
		PublicServiceRouteConfig: result,
	}, nil
}

// ListPublicServiceRouteConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListPublicServiceRouteConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalPublicServiceRouteConfig, err error) {
	key := "publicservicerouteconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalPublicServiceRouteConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.PublicServiceRouteConfig)
			result[k] = &GlobalPublicServiceRouteConfig{
				client:                   group.client,
				PublicServiceRouteConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			PublicServiceRouteConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalPublicServiceRouteConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalPublicServiceRouteConfig{
				client:                   group.client,
				PublicServiceRouteConfig: &item,
			}
		}
	}
	return
}

type GlobalPublicServiceRouteConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.PublicServiceRouteConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalPublicServiceRouteConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeletePublicServiceRouteConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.PublicServiceRouteConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalPublicServiceRouteConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdatePublicServiceRouteConfigByName(ctx, obj.PublicServiceRouteConfig)
	if err != nil {
		return err
	}
	obj.PublicServiceRouteConfig = result.PublicServiceRouteConfig
	return nil
}

func (obj *GlobalPublicServiceRouteConfig) GetParent(ctx context.Context) (result *GlobalPublicServiceConfig, err error) {
	hashedName := helper.GetHashedName("publicserviceconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["publicserviceconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetPublicServiceConfigByName(ctx, hashedName)
}

type publicservicerouteconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *publicservicerouteconfigGlobalTsmV1Chainer) Subscribe() {
	key := "publicservicerouteconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewPublicServiceRouteConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *publicservicerouteconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "publicservicerouteconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *publicservicerouteconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "publicservicerouteconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetPublicServiceConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetPublicServiceConfigByName(ctx context.Context, hashedName string) (*GlobalPublicServiceConfig, error) {
	key := "publicserviceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.PublicServiceConfig)
		return &GlobalPublicServiceConfig{
			client:              group.client,
			PublicServiceConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			PublicServiceConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalPublicServiceConfig{
			client:              group.client,
			PublicServiceConfig: result,
		}, nil
	}
}

// DeletePublicServiceConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeletePublicServiceConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		PublicServiceConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.RoutingConfigsGvk {
		err := group.client.
			Global().DeletePublicServiceRouteConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		PublicServiceConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/publicServicesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreatePublicServiceConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreatePublicServiceConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PublicServiceConfig) (*GlobalPublicServiceConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.RoutingConfigsGvk = nil
	objToCreate.Spec.ExternalDNSGvk = nil
	objToCreate.Spec.CertificatesGvk = nil
	objToCreate.Spec.HealthChecksGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		PublicServiceConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"publicServicesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"PublicServiceConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalPublicServiceConfig{
		client:              group.client,
		PublicServiceConfig: result,
	}, nil
}

// UpdatePublicServiceConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdatePublicServiceConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.PublicServiceConfig) (*GlobalPublicServiceConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			PublicServiceConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueFqdn :=
		objToUpdate.Spec.Fqdn
	patchOpFqdn := PatchOp{
		Op:    "replace",
		Path:  "/spec/fqdn",
		Value: patchValueFqdn,
	}
	patch = append(patch, patchOpFqdn)

	patchValueConfig :=
		objToUpdate.Spec.Config
	patchOpConfig := PatchOp{
		Op:    "replace",
		Path:  "/spec/config",
		Value: patchValueConfig,
	}
	patch = append(patch, patchOpConfig)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		PublicServiceConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalPublicServiceConfig{
		client:              group.client,
		PublicServiceConfig: result,
	}, nil
}

// ListPublicServiceConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListPublicServiceConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalPublicServiceConfig, err error) {
	key := "publicserviceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalPublicServiceConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.PublicServiceConfig)
			result[k] = &GlobalPublicServiceConfig{
				client:              group.client,
				PublicServiceConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			PublicServiceConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalPublicServiceConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalPublicServiceConfig{
				client:              group.client,
				PublicServiceConfig: &item,
			}
		}
	}
	return
}

type GlobalPublicServiceConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.PublicServiceConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalPublicServiceConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeletePublicServiceConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.PublicServiceConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalPublicServiceConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdatePublicServiceConfigByName(ctx, obj.PublicServiceConfig)
	if err != nil {
		return err
	}
	obj.PublicServiceConfig = result.PublicServiceConfig
	return nil
}

func (obj *GlobalPublicServiceConfig) GetParent(ctx context.Context) (result *GlobalGNS, err error) {
	hashedName := helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnss.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGNSByName(ctx, hashedName)
}

// GetAllRoutingConfigs returns all children of given type
func (obj *GlobalPublicServiceConfig) GetAllRoutingConfigs(ctx context.Context) (
	result []*GlobalPublicServiceRouteConfig, err error) {
	result = make([]*GlobalPublicServiceRouteConfig, 0, len(obj.Spec.RoutingConfigsGvk))
	for _, v := range obj.Spec.RoutingConfigsGvk {
		l, err := obj.client.Global().GetPublicServiceRouteConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetRoutingConfigs returns child which has given displayName
func (obj *GlobalPublicServiceConfig) GetRoutingConfigs(ctx context.Context,
	displayName string) (result *GlobalPublicServiceRouteConfig, err error) {
	l, ok := obj.Spec.RoutingConfigsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.PublicServiceConfig", "RoutingConfigs", displayName)
	}
	result, err = obj.client.Global().GetPublicServiceRouteConfigByName(ctx, l.Name)
	return
}

// AddRoutingConfigs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalPublicServiceConfig) AddRoutingConfigs(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PublicServiceRouteConfig) (result *GlobalPublicServiceRouteConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["publicserviceconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["publicserviceconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreatePublicServiceRouteConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetPublicServiceConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.PublicServiceConfig = updatedObj.PublicServiceConfig
	}
	return
}

// DeleteRoutingConfigs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalPublicServiceConfig) DeleteRoutingConfigs(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.RoutingConfigsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.PublicServiceConfig", "RoutingConfigs", displayName)
	}
	err = obj.client.Global().DeletePublicServiceRouteConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetPublicServiceConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.PublicServiceConfig = updatedObj.PublicServiceConfig
	}
	return
}

// GetAllExternalDNS returns all links of given type
func (obj *GlobalPublicServiceConfig) GetAllExternalDNS(ctx context.Context) (
	result []*GlobalExternalDNSConfigN, err error) {
	result = make([]*GlobalExternalDNSConfigN, 0, len(obj.Spec.ExternalDNSGvk))
	for _, v := range obj.Spec.ExternalDNSGvk {
		l, err := obj.client.Global().GetExternalDNSConfigNByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetExternalDNS returns link which has given displayName
func (obj *GlobalPublicServiceConfig) GetExternalDNS(ctx context.Context,
	displayName string) (result *GlobalExternalDNSConfigN, err error) {
	l, ok := obj.Spec.ExternalDNSGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.PublicServiceConfig", "ExternalDNS", displayName)
	}
	result, err = obj.client.Global().GetExternalDNSConfigNByName(ctx, l.Name)
	return
}

// LinkExternalDNS links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalPublicServiceConfig) LinkExternalDNS(ctx context.Context,
	linkToAdd *GlobalExternalDNSConfigN) error {

	payload := "{\"spec\": {\"externalDNSGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ExternalDNSConfigN\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().PublicServiceConfigs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.PublicServiceConfig = result
	return nil
}

// UnlinkExternalDNS unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalPublicServiceConfig) UnlinkExternalDNS(ctx context.Context,
	linkToRemove *GlobalExternalDNSConfigN) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/externalDNSGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().PublicServiceConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.PublicServiceConfig = result
	return nil

}

// GetAllCertificates returns all links of given type
func (obj *GlobalPublicServiceConfig) GetAllCertificates(ctx context.Context) (
	result []*GlobalCertificateConfigN, err error) {
	result = make([]*GlobalCertificateConfigN, 0, len(obj.Spec.CertificatesGvk))
	for _, v := range obj.Spec.CertificatesGvk {
		l, err := obj.client.Global().GetCertificateConfigNByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetCertificates returns link which has given displayName
func (obj *GlobalPublicServiceConfig) GetCertificates(ctx context.Context,
	displayName string) (result *GlobalCertificateConfigN, err error) {
	l, ok := obj.Spec.CertificatesGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.PublicServiceConfig", "Certificates", displayName)
	}
	result, err = obj.client.Global().GetCertificateConfigNByName(ctx, l.Name)
	return
}

// LinkCertificates links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalPublicServiceConfig) LinkCertificates(ctx context.Context,
	linkToAdd *GlobalCertificateConfigN) error {

	payload := "{\"spec\": {\"certificatesGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"CertificateConfigN\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().PublicServiceConfigs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.PublicServiceConfig = result
	return nil
}

// UnlinkCertificates unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalPublicServiceConfig) UnlinkCertificates(ctx context.Context,
	linkToRemove *GlobalCertificateConfigN) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/certificatesGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().PublicServiceConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.PublicServiceConfig = result
	return nil

}

// GetAllHealthChecks returns all links of given type
func (obj *GlobalPublicServiceConfig) GetAllHealthChecks(ctx context.Context) (
	result []*GlobalHealthCheckConfigN, err error) {
	result = make([]*GlobalHealthCheckConfigN, 0, len(obj.Spec.HealthChecksGvk))
	for _, v := range obj.Spec.HealthChecksGvk {
		l, err := obj.client.Global().GetHealthCheckConfigNByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetHealthChecks returns link which has given displayName
func (obj *GlobalPublicServiceConfig) GetHealthChecks(ctx context.Context,
	displayName string) (result *GlobalHealthCheckConfigN, err error) {
	l, ok := obj.Spec.HealthChecksGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.PublicServiceConfig", "HealthChecks", displayName)
	}
	result, err = obj.client.Global().GetHealthCheckConfigNByName(ctx, l.Name)
	return
}

// LinkHealthChecks links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalPublicServiceConfig) LinkHealthChecks(ctx context.Context,
	linkToAdd *GlobalHealthCheckConfigN) error {

	payload := "{\"spec\": {\"healthChecksGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"HealthCheckConfigN\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().PublicServiceConfigs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.PublicServiceConfig = result
	return nil
}

// UnlinkHealthChecks unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalPublicServiceConfig) UnlinkHealthChecks(ctx context.Context,
	linkToRemove *GlobalHealthCheckConfigN) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/healthChecksGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().PublicServiceConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.PublicServiceConfig = result
	return nil

}

type publicserviceconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *publicserviceconfigGlobalTsmV1Chainer) Subscribe() {
	key := "publicserviceconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewPublicServiceConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *publicserviceconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "publicserviceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *publicserviceconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "publicserviceconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *publicserviceconfigGlobalTsmV1Chainer) RoutingConfigs(name string) *publicservicerouteconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["publicservicerouteconfigs.global.tsm.tanzu.vmware.com"] = name
	return &publicservicerouteconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetRoutingConfigs calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *publicserviceconfigGlobalTsmV1Chainer) GetRoutingConfigs(ctx context.Context, displayName string) (result *GlobalPublicServiceRouteConfig, err error) {
	hashedName := helper.GetHashedName("publicservicerouteconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetPublicServiceRouteConfigByName(ctx, hashedName)
}

// AddRoutingConfigs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *publicserviceconfigGlobalTsmV1Chainer) AddRoutingConfigs(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PublicServiceRouteConfig) (result *GlobalPublicServiceRouteConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("publicservicerouteconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreatePublicServiceRouteConfigByName(ctx, objToCreate)
}

// DeleteRoutingConfigs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *publicserviceconfigGlobalTsmV1Chainer) DeleteRoutingConfigs(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("publicservicerouteconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeletePublicServiceRouteConfigByName(ctx, hashedName)
}

// GetGNSRoutingConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGNSRoutingConfigByName(ctx context.Context, hashedName string) (*GlobalGNSRoutingConfig, error) {
	key := "gnsroutingconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.GNSRoutingConfig)
		return &GlobalGNSRoutingConfig{
			client:           group.client,
			GNSRoutingConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			GNSRoutingConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGNSRoutingConfig{
			client:           group.client,
			GNSRoutingConfig: result,
		}, nil
	}
}

// DeleteGNSRoutingConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGNSRoutingConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GNSRoutingConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		GNSRoutingConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/routingPoliciesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGNSRoutingConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGNSRoutingConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GNSRoutingConfig) (*GlobalGNSRoutingConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GNSRoutingConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"routingPoliciesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"GNSRoutingConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGNSRoutingConfig{
		client:           group.client,
		GNSRoutingConfig: result,
	}, nil
}

// UpdateGNSRoutingConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGNSRoutingConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.GNSRoutingConfig) (*GlobalGNSRoutingConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			GNSRoutingConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		GNSRoutingConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGNSRoutingConfig{
		client:           group.client,
		GNSRoutingConfig: result,
	}, nil
}

// ListGNSRoutingConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGNSRoutingConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGNSRoutingConfig, err error) {
	key := "gnsroutingconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGNSRoutingConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.GNSRoutingConfig)
			result[k] = &GlobalGNSRoutingConfig{
				client:           group.client,
				GNSRoutingConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			GNSRoutingConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGNSRoutingConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGNSRoutingConfig{
				client:           group.client,
				GNSRoutingConfig: &item,
			}
		}
	}
	return
}

type GlobalGNSRoutingConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.GNSRoutingConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGNSRoutingConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGNSRoutingConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.GNSRoutingConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGNSRoutingConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGNSRoutingConfigByName(ctx, obj.GNSRoutingConfig)
	if err != nil {
		return err
	}
	obj.GNSRoutingConfig = result.GNSRoutingConfig
	return nil
}

func (obj *GlobalGNSRoutingConfig) GetParent(ctx context.Context) (result *GlobalGNS, err error) {
	hashedName := helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnss.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGNSByName(ctx, hashedName)
}

type gnsroutingconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *gnsroutingconfigGlobalTsmV1Chainer) Subscribe() {
	key := "gnsroutingconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGNSRoutingConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *gnsroutingconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "gnsroutingconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *gnsroutingconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "gnsroutingconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetGnsRoutingRuleConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGnsRoutingRuleConfigByName(ctx context.Context, hashedName string) (*GlobalGnsRoutingRuleConfig, error) {
	key := "gnsroutingruleconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.GnsRoutingRuleConfig)
		return &GlobalGnsRoutingRuleConfig{
			client:               group.client,
			GnsRoutingRuleConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			GnsRoutingRuleConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGnsRoutingRuleConfig{
			client:               group.client,
			GnsRoutingRuleConfig: result,
		}, nil
	}
}

// DeleteGnsRoutingRuleConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGnsRoutingRuleConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsRoutingRuleConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		GnsRoutingRuleConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gnsRoutingRulesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnsbindingrts.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnsbindingrts.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GnsBindingRTs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGnsRoutingRuleConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGnsRoutingRuleConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsRoutingRuleConfig) (*GlobalGnsRoutingRuleConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsRoutingRuleConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnsbindingrts.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnsbindingrts.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"gnsRoutingRulesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"GnsRoutingRuleConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GnsBindingRTs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGnsRoutingRuleConfig{
		client:               group.client,
		GnsRoutingRuleConfig: result,
	}, nil
}

// UpdateGnsRoutingRuleConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGnsRoutingRuleConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.GnsRoutingRuleConfig) (*GlobalGnsRoutingRuleConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			GnsRoutingRuleConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueOwnedBy :=
		objToUpdate.Spec.OwnedBy
	patchOpOwnedBy := PatchOp{
		Op:    "replace",
		Path:  "/spec/ownedBy",
		Value: patchValueOwnedBy,
	}
	patch = append(patch, patchOpOwnedBy)

	patchValueServiceFQDN :=
		objToUpdate.Spec.ServiceFQDN
	patchOpServiceFQDN := PatchOp{
		Op:    "replace",
		Path:  "/spec/serviceFQDN",
		Value: patchValueServiceFQDN,
	}
	patch = append(patch, patchOpServiceFQDN)

	patchValuePortName :=
		objToUpdate.Spec.PortName
	patchOpPortName := PatchOp{
		Op:    "replace",
		Path:  "/spec/portName",
		Value: patchValuePortName,
	}
	patch = append(patch, patchOpPortName)

	patchValuePort :=
		objToUpdate.Spec.Port
	patchOpPort := PatchOp{
		Op:    "replace",
		Path:  "/spec/port",
		Value: patchValuePort,
	}
	patch = append(patch, patchOpPort)

	patchValueHttpRouteRules :=
		objToUpdate.Spec.HttpRouteRules
	patchOpHttpRouteRules := PatchOp{
		Op:    "replace",
		Path:  "/spec/httpRouteRules",
		Value: patchValueHttpRouteRules,
	}
	patch = append(patch, patchOpHttpRouteRules)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsRoutingRuleConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGnsRoutingRuleConfig{
		client:               group.client,
		GnsRoutingRuleConfig: result,
	}, nil
}

// ListGnsRoutingRuleConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGnsRoutingRuleConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGnsRoutingRuleConfig, err error) {
	key := "gnsroutingruleconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGnsRoutingRuleConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.GnsRoutingRuleConfig)
			result[k] = &GlobalGnsRoutingRuleConfig{
				client:               group.client,
				GnsRoutingRuleConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			GnsRoutingRuleConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGnsRoutingRuleConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGnsRoutingRuleConfig{
				client:               group.client,
				GnsRoutingRuleConfig: &item,
			}
		}
	}
	return
}

type GlobalGnsRoutingRuleConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.GnsRoutingRuleConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGnsRoutingRuleConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGnsRoutingRuleConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.GnsRoutingRuleConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGnsRoutingRuleConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGnsRoutingRuleConfigByName(ctx, obj.GnsRoutingRuleConfig)
	if err != nil {
		return err
	}
	obj.GnsRoutingRuleConfig = result.GnsRoutingRuleConfig
	return nil
}

func (obj *GlobalGnsRoutingRuleConfig) GetParent(ctx context.Context) (result *GlobalGnsBindingRT, err error) {
	hashedName := helper.GetHashedName("gnsbindingrts.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnsbindingrts.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGnsBindingRTByName(ctx, hashedName)
}

type gnsroutingruleconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *gnsroutingruleconfigGlobalTsmV1Chainer) Subscribe() {
	key := "gnsroutingruleconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGnsRoutingRuleConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *gnsroutingruleconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "gnsroutingruleconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *gnsroutingruleconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "gnsroutingruleconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetGnsSegmentationPolicyRTByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGnsSegmentationPolicyRTByName(ctx context.Context, hashedName string) (*GlobalGnsSegmentationPolicyRT, error) {
	key := "gnssegmentationpolicyrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.GnsSegmentationPolicyRT)
		return &GlobalGnsSegmentationPolicyRT{
			client:                  group.client,
			GnsSegmentationPolicyRT: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			GnsSegmentationPolicyRTs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGnsSegmentationPolicyRT{
			client:                  group.client,
			GnsSegmentationPolicyRT: result,
		}, nil
	}
}

// DeleteGnsSegmentationPolicyRTByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGnsSegmentationPolicyRTByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsSegmentationPolicyRTs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		GnsSegmentationPolicyRTs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gnsSegmentationPolicyGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGnsSegmentationPolicyRTByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGnsSegmentationPolicyRTByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsSegmentationPolicyRT) (*GlobalGnsSegmentationPolicyRT, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsSegmentationPolicyRTs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"gnsSegmentationPolicyGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"GnsSegmentationPolicyRT\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGnsSegmentationPolicyRT{
		client:                  group.client,
		GnsSegmentationPolicyRT: result,
	}, nil
}

// UpdateGnsSegmentationPolicyRTByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGnsSegmentationPolicyRTByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.GnsSegmentationPolicyRT) (*GlobalGnsSegmentationPolicyRT, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			GnsSegmentationPolicyRTs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueGnsid :=
		objToUpdate.Spec.Gnsid
	patchOpGnsid := PatchOp{
		Op:    "replace",
		Path:  "/spec/gnsid",
		Value: patchValueGnsid,
	}
	patch = append(patch, patchOpGnsid)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsSegmentationPolicyRTs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGnsSegmentationPolicyRT{
		client:                  group.client,
		GnsSegmentationPolicyRT: result,
	}, nil
}

// ListGnsSegmentationPolicyRTs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGnsSegmentationPolicyRTs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGnsSegmentationPolicyRT, err error) {
	key := "gnssegmentationpolicyrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGnsSegmentationPolicyRT, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.GnsSegmentationPolicyRT)
			result[k] = &GlobalGnsSegmentationPolicyRT{
				client:                  group.client,
				GnsSegmentationPolicyRT: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			GnsSegmentationPolicyRTs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGnsSegmentationPolicyRT, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGnsSegmentationPolicyRT{
				client:                  group.client,
				GnsSegmentationPolicyRT: &item,
			}
		}
	}
	return
}

type GlobalGnsSegmentationPolicyRT struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.GnsSegmentationPolicyRT
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGnsSegmentationPolicyRT) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGnsSegmentationPolicyRTByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.GnsSegmentationPolicyRT = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGnsSegmentationPolicyRT) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGnsSegmentationPolicyRTByName(ctx, obj.GnsSegmentationPolicyRT)
	if err != nil {
		return err
	}
	obj.GnsSegmentationPolicyRT = result.GnsSegmentationPolicyRT
	return nil
}

func (obj *GlobalGnsSegmentationPolicyRT) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

type gnssegmentationpolicyrtGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *gnssegmentationpolicyrtGlobalTsmV1Chainer) Subscribe() {
	key := "gnssegmentationpolicyrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGnsSegmentationPolicyRTInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *gnssegmentationpolicyrtGlobalTsmV1Chainer) Unsubscribe() {
	key := "gnssegmentationpolicyrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *gnssegmentationpolicyrtGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "gnssegmentationpolicyrts.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetGnsSegmentationPolicyByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGnsSegmentationPolicyByName(ctx context.Context, hashedName string) (*GlobalGnsSegmentationPolicy, error) {
	key := "gnssegmentationpolicies.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.GnsSegmentationPolicy)
		return &GlobalGnsSegmentationPolicy{
			client:                group.client,
			GnsSegmentationPolicy: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			GnsSegmentationPolicies().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGnsSegmentationPolicy{
			client:                group.client,
			GnsSegmentationPolicy: result,
		}, nil
	}
}

// DeleteGnsSegmentationPolicyByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGnsSegmentationPolicyByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsSegmentationPolicies().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		GnsSegmentationPolicies().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gnsSegmentationPolicyGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGnsSegmentationPolicyByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGnsSegmentationPolicyByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsSegmentationPolicy) (*GlobalGnsSegmentationPolicy, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsSegmentationPolicies().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"gnsSegmentationPolicyGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"GnsSegmentationPolicy\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGnsSegmentationPolicy{
		client:                group.client,
		GnsSegmentationPolicy: result,
	}, nil
}

// UpdateGnsSegmentationPolicyByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGnsSegmentationPolicyByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.GnsSegmentationPolicy) (*GlobalGnsSegmentationPolicy, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			GnsSegmentationPolicies().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsSegmentationPolicies().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGnsSegmentationPolicy{
		client:                group.client,
		GnsSegmentationPolicy: result,
	}, nil
}

// ListGnsSegmentationPolicies returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGnsSegmentationPolicies(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGnsSegmentationPolicy, err error) {
	key := "gnssegmentationpolicies.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGnsSegmentationPolicy, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.GnsSegmentationPolicy)
			result[k] = &GlobalGnsSegmentationPolicy{
				client:                group.client,
				GnsSegmentationPolicy: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			GnsSegmentationPolicies().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGnsSegmentationPolicy, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGnsSegmentationPolicy{
				client:                group.client,
				GnsSegmentationPolicy: &item,
			}
		}
	}
	return
}

type GlobalGnsSegmentationPolicy struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.GnsSegmentationPolicy
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGnsSegmentationPolicy) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGnsSegmentationPolicyByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.GnsSegmentationPolicy = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGnsSegmentationPolicy) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGnsSegmentationPolicyByName(ctx, obj.GnsSegmentationPolicy)
	if err != nil {
		return err
	}
	obj.GnsSegmentationPolicy = result.GnsSegmentationPolicy
	return nil
}

func (obj *GlobalGnsSegmentationPolicy) GetParent(ctx context.Context) (result *GlobalGNS, err error) {
	hashedName := helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnss.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGNSByName(ctx, hashedName)
}

type gnssegmentationpolicyGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *gnssegmentationpolicyGlobalTsmV1Chainer) Subscribe() {
	key := "gnssegmentationpolicies.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGnsSegmentationPolicyInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *gnssegmentationpolicyGlobalTsmV1Chainer) Unsubscribe() {
	key := "gnssegmentationpolicies.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *gnssegmentationpolicyGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "gnssegmentationpolicies.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetGnsServiceEntryConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGnsServiceEntryConfigByName(ctx context.Context, hashedName string) (*GlobalGnsServiceEntryConfig, error) {
	key := "gnsserviceentryconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.GnsServiceEntryConfig)
		return &GlobalGnsServiceEntryConfig{
			client:                group.client,
			GnsServiceEntryConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			GnsServiceEntryConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGnsServiceEntryConfig{
			client:                group.client,
			GnsServiceEntryConfig: result,
		}, nil
	}
}

// DeleteGnsServiceEntryConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGnsServiceEntryConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsServiceEntryConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		GnsServiceEntryConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gnsServiceEntryConfigGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnsbindingrts.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnsbindingrts.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GnsBindingRTs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGnsServiceEntryConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGnsServiceEntryConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsServiceEntryConfig) (*GlobalGnsServiceEntryConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsServiceEntryConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnsbindingrts.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnsbindingrts.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"gnsServiceEntryConfigGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"GnsServiceEntryConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GnsBindingRTs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGnsServiceEntryConfig{
		client:                group.client,
		GnsServiceEntryConfig: result,
	}, nil
}

// UpdateGnsServiceEntryConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGnsServiceEntryConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.GnsServiceEntryConfig) (*GlobalGnsServiceEntryConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			GnsServiceEntryConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueService :=
		objToUpdate.Spec.Service
	patchOpService := PatchOp{
		Op:    "replace",
		Path:  "/spec/service",
		Value: patchValueService,
	}
	patch = append(patch, patchOpService)

	patchValuePorts :=
		objToUpdate.Spec.Ports
	patchOpPorts := PatchOp{
		Op:    "replace",
		Path:  "/spec/ports",
		Value: patchValuePorts,
	}
	patch = append(patch, patchOpPorts)

	patchValueVersions :=
		objToUpdate.Spec.Versions
	patchOpVersions := PatchOp{
		Op:    "replace",
		Path:  "/spec/versions",
		Value: patchValueVersions,
	}
	patch = append(patch, patchOpVersions)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsServiceEntryConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGnsServiceEntryConfig{
		client:                group.client,
		GnsServiceEntryConfig: result,
	}, nil
}

// ListGnsServiceEntryConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGnsServiceEntryConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGnsServiceEntryConfig, err error) {
	key := "gnsserviceentryconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGnsServiceEntryConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.GnsServiceEntryConfig)
			result[k] = &GlobalGnsServiceEntryConfig{
				client:                group.client,
				GnsServiceEntryConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			GnsServiceEntryConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGnsServiceEntryConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGnsServiceEntryConfig{
				client:                group.client,
				GnsServiceEntryConfig: &item,
			}
		}
	}
	return
}

type GlobalGnsServiceEntryConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.GnsServiceEntryConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGnsServiceEntryConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGnsServiceEntryConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.GnsServiceEntryConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGnsServiceEntryConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGnsServiceEntryConfigByName(ctx, obj.GnsServiceEntryConfig)
	if err != nil {
		return err
	}
	obj.GnsServiceEntryConfig = result.GnsServiceEntryConfig
	return nil
}

func (obj *GlobalGnsServiceEntryConfig) GetParent(ctx context.Context) (result *GlobalGnsBindingRT, err error) {
	hashedName := helper.GetHashedName("gnsbindingrts.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnsbindingrts.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGnsBindingRTByName(ctx, hashedName)
}

type gnsserviceentryconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *gnsserviceentryconfigGlobalTsmV1Chainer) Subscribe() {
	key := "gnsserviceentryconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGnsServiceEntryConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *gnsserviceentryconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "gnsserviceentryconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *gnsserviceentryconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "gnsserviceentryconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetGnsSvcGroupRTByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGnsSvcGroupRTByName(ctx context.Context, hashedName string) (*GlobalGnsSvcGroupRT, error) {
	key := "gnssvcgrouprts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.GnsSvcGroupRT)
		return &GlobalGnsSvcGroupRT{
			client:        group.client,
			GnsSvcGroupRT: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			GnsSvcGroupRTs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGnsSvcGroupRT{
			client:        group.client,
			GnsSvcGroupRT: result,
		}, nil
	}
}

// DeleteGnsSvcGroupRTByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGnsSvcGroupRTByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsSvcGroupRTs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		GnsSvcGroupRTs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gnsSvcGroupRTGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnsbindingrts.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnsbindingrts.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GnsBindingRTs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGnsSvcGroupRTByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGnsSvcGroupRTByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsSvcGroupRT) (*GlobalGnsSvcGroupRT, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsSvcGroupRTs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnsbindingrts.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnsbindingrts.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"gnsSvcGroupRTGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"GnsSvcGroupRT\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GnsBindingRTs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGnsSvcGroupRT{
		client:        group.client,
		GnsSvcGroupRT: result,
	}, nil
}

// UpdateGnsSvcGroupRTByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGnsSvcGroupRTByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.GnsSvcGroupRT) (*GlobalGnsSvcGroupRT, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			GnsSvcGroupRTs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueDisplayName :=
		objToUpdate.Spec.DisplayName
	patchOpDisplayName := PatchOp{
		Op:    "replace",
		Path:  "/spec/displayName",
		Value: patchValueDisplayName,
	}
	patch = append(patch, patchOpDisplayName)

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueServices :=
		objToUpdate.Spec.Services
	patchOpServices := PatchOp{
		Op:    "replace",
		Path:  "/spec/services",
		Value: patchValueServices,
	}
	patch = append(patch, patchOpServices)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsSvcGroupRTs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGnsSvcGroupRT{
		client:        group.client,
		GnsSvcGroupRT: result,
	}, nil
}

// ListGnsSvcGroupRTs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGnsSvcGroupRTs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGnsSvcGroupRT, err error) {
	key := "gnssvcgrouprts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGnsSvcGroupRT, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.GnsSvcGroupRT)
			result[k] = &GlobalGnsSvcGroupRT{
				client:        group.client,
				GnsSvcGroupRT: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			GnsSvcGroupRTs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGnsSvcGroupRT, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGnsSvcGroupRT{
				client:        group.client,
				GnsSvcGroupRT: &item,
			}
		}
	}
	return
}

type GlobalGnsSvcGroupRT struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.GnsSvcGroupRT
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGnsSvcGroupRT) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGnsSvcGroupRTByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.GnsSvcGroupRT = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGnsSvcGroupRT) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGnsSvcGroupRTByName(ctx, obj.GnsSvcGroupRT)
	if err != nil {
		return err
	}
	obj.GnsSvcGroupRT = result.GnsSvcGroupRT
	return nil
}

func (obj *GlobalGnsSvcGroupRT) GetParent(ctx context.Context) (result *GlobalGnsBindingRT, err error) {
	hashedName := helper.GetHashedName("gnsbindingrts.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnsbindingrts.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGnsBindingRTByName(ctx, hashedName)
}

type gnssvcgrouprtGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *gnssvcgrouprtGlobalTsmV1Chainer) Subscribe() {
	key := "gnssvcgrouprts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGnsSvcGroupRTInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *gnssvcgrouprtGlobalTsmV1Chainer) Unsubscribe() {
	key := "gnssvcgrouprts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *gnssvcgrouprtGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "gnssvcgrouprts.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetGNSSvcGroupByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGNSSvcGroupByName(ctx context.Context, hashedName string) (*GlobalGNSSvcGroup, error) {
	key := "gnssvcgroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.GNSSvcGroup)
		return &GlobalGNSSvcGroup{
			client:      group.client,
			GNSSvcGroup: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			GNSSvcGroups().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGNSSvcGroup{
			client:      group.client,
			GNSSvcGroup: result,
		}, nil
	}
}

// DeleteGNSSvcGroupByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGNSSvcGroupByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GNSSvcGroups().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		GNSSvcGroups().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gnsServiceGroupsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGNSSvcGroupByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGNSSvcGroupByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GNSSvcGroup) (*GlobalGNSSvcGroup, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ServicesGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GNSSvcGroups().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"gnsServiceGroupsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"GNSSvcGroup\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGNSSvcGroup{
		client:      group.client,
		GNSSvcGroup: result,
	}, nil
}

// UpdateGNSSvcGroupByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGNSSvcGroupByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.GNSSvcGroup) (*GlobalGNSSvcGroup, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			GNSSvcGroups().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDisplayName :=
		objToUpdate.Spec.DisplayName
	patchOpDisplayName := PatchOp{
		Op:    "replace",
		Path:  "/spec/displayName",
		Value: patchValueDisplayName,
	}
	patch = append(patch, patchOpDisplayName)

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueColor :=
		objToUpdate.Spec.Color
	patchOpColor := PatchOp{
		Op:    "replace",
		Path:  "/spec/color",
		Value: patchValueColor,
	}
	patch = append(patch, patchOpColor)

	patchValueRules :=
		objToUpdate.Spec.Rules
	patchOpRules := PatchOp{
		Op:    "replace",
		Path:  "/spec/rules",
		Value: patchValueRules,
	}
	patch = append(patch, patchOpRules)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		GNSSvcGroups().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGNSSvcGroup{
		client:      group.client,
		GNSSvcGroup: result,
	}, nil
}

// ListGNSSvcGroups returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGNSSvcGroups(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGNSSvcGroup, err error) {
	key := "gnssvcgroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGNSSvcGroup, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.GNSSvcGroup)
			result[k] = &GlobalGNSSvcGroup{
				client:      group.client,
				GNSSvcGroup: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			GNSSvcGroups().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGNSSvcGroup, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGNSSvcGroup{
				client:      group.client,
				GNSSvcGroup: &item,
			}
		}
	}
	return
}

type GlobalGNSSvcGroup struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.GNSSvcGroup
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGNSSvcGroup) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGNSSvcGroupByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.GNSSvcGroup = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGNSSvcGroup) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGNSSvcGroupByName(ctx, obj.GNSSvcGroup)
	if err != nil {
		return err
	}
	obj.GNSSvcGroup = result.GNSSvcGroup
	return nil
}

func (obj *GlobalGNSSvcGroup) GetParent(ctx context.Context) (result *GlobalGNS, err error) {
	hashedName := helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnss.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGNSByName(ctx, hashedName)
}

// GetAllServices returns all links of given type
func (obj *GlobalGNSSvcGroup) GetAllServices(ctx context.Context) (
	result []*GlobalService, err error) {
	result = make([]*GlobalService, 0, len(obj.Spec.ServicesGvk))
	for _, v := range obj.Spec.ServicesGvk {
		l, err := obj.client.Global().GetServiceByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServices returns link which has given displayName
func (obj *GlobalGNSSvcGroup) GetServices(ctx context.Context,
	displayName string) (result *GlobalService, err error) {
	l, ok := obj.Spec.ServicesGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.GNSSvcGroup", "Services", displayName)
	}
	result, err = obj.client.Global().GetServiceByName(ctx, l.Name)
	return
}

// LinkServices links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalGNSSvcGroup) LinkServices(ctx context.Context,
	linkToAdd *GlobalService) error {

	payload := "{\"spec\": {\"servicesGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"Service\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().GNSSvcGroups().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.GNSSvcGroup = result
	return nil
}

// UnlinkServices unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalGNSSvcGroup) UnlinkServices(ctx context.Context,
	linkToRemove *GlobalService) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/servicesGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().GNSSvcGroups().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.GNSSvcGroup = result
	return nil

}

type gnssvcgroupGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *gnssvcgroupGlobalTsmV1Chainer) Subscribe() {
	key := "gnssvcgroups.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGNSSvcGroupInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *gnssvcgroupGlobalTsmV1Chainer) Unsubscribe() {
	key := "gnssvcgroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *gnssvcgroupGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "gnssvcgroups.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetSharedServiceConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetSharedServiceConfigByName(ctx context.Context, hashedName string) (*GlobalSharedServiceConfig, error) {
	key := "sharedserviceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.SharedServiceConfig)
		return &GlobalSharedServiceConfig{
			client:              group.client,
			SharedServiceConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			SharedServiceConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalSharedServiceConfig{
			client:              group.client,
			SharedServiceConfig: result,
		}, nil
	}
}

// DeleteSharedServiceConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteSharedServiceConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SharedServiceConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		SharedServiceConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/sharedServicesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateSharedServiceConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateSharedServiceConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SharedServiceConfig) (*GlobalSharedServiceConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SharedServiceConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"sharedServicesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"SharedServiceConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalSharedServiceConfig{
		client:              group.client,
		SharedServiceConfig: result,
	}, nil
}

// UpdateSharedServiceConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateSharedServiceConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.SharedServiceConfig) (*GlobalSharedServiceConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			SharedServiceConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		SharedServiceConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalSharedServiceConfig{
		client:              group.client,
		SharedServiceConfig: result,
	}, nil
}

// ListSharedServiceConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListSharedServiceConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalSharedServiceConfig, err error) {
	key := "sharedserviceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalSharedServiceConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.SharedServiceConfig)
			result[k] = &GlobalSharedServiceConfig{
				client:              group.client,
				SharedServiceConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			SharedServiceConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalSharedServiceConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalSharedServiceConfig{
				client:              group.client,
				SharedServiceConfig: &item,
			}
		}
	}
	return
}

type GlobalSharedServiceConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.SharedServiceConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalSharedServiceConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteSharedServiceConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.SharedServiceConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalSharedServiceConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateSharedServiceConfigByName(ctx, obj.SharedServiceConfig)
	if err != nil {
		return err
	}
	obj.SharedServiceConfig = result.SharedServiceConfig
	return nil
}

func (obj *GlobalSharedServiceConfig) GetParent(ctx context.Context) (result *GlobalGNS, err error) {
	hashedName := helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnss.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGNSByName(ctx, hashedName)
}

type sharedserviceconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *sharedserviceconfigGlobalTsmV1Chainer) Subscribe() {
	key := "sharedserviceconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSharedServiceConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *sharedserviceconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "sharedserviceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *sharedserviceconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "sharedserviceconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetGNSByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGNSByName(ctx context.Context, hashedName string) (*GlobalGNS, error) {
	key := "gnss.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.GNS)
		return &GlobalGNS{
			client: group.client,
			GNS:    result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			GNSs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGNS{
			client: group.client,
			GNS:    result,
		}, nil
	}
}

// DeleteGNSByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGNSByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GNSs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.RoutingConfigGvk != nil {
		err := group.client.
			Global().
			DeleteGNSRoutingConfigByName(ctx, result.Spec.RoutingConfigGvk.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.GnsServiceGroupsGvk {
		err := group.client.
			Global().DeleteGNSSvcGroupByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.PublicServicesGvk {
		err := group.client.
			Global().DeletePublicServiceConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.SharedServicesGvk {
		err := group.client.
			Global().DeleteSharedServiceConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.SloPoliciesGvk {
		err := group.client.
			Global().DeleteSLOPolicyByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ExternalServicesGvk {
		err := group.client.
			Global().DeleteExternalServiceConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.AutoscalingPoliciesGvk {
		err := group.client.
			Global().DeleteAutoscalingPolicyByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.RoutingPoliciesGvk {
		err := group.client.
			Global().DeleteGNSRoutingConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ApiDiscoveryGvk {
		err := group.client.
			Global().DeleteApiDiscoveryByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.GeoDiscoveryGvk {
		err := group.client.
			Global().DeleteGeoDiscoveryByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.PiiDiscoveryGvk {
		err := group.client.
			Global().DeletePiiDiscoveryByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.AttackDiscoveryGvk {
		err := group.client.
			Global().DeleteAttackDiscoveryByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.UserDiscoveryGvk {
		err := group.client.
			Global().DeleteUserDiscoveryByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.GnsAccessControlPolicyGvk {
		err := group.client.
			Global().DeleteGnsAccessControlPolicyByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.GnsSchemaViolationDiscoveryGvk {
		err := group.client.
			Global().DeleteGnsSchemaViolationDiscoveryByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.GnsSegmentationPolicyGvk {
		err := group.client.
			Global().DeleteGnsSegmentationPolicyByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gnsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["globalnamespaces.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("globalnamespaces.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GlobalNamespaces().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGNSByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGNSByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GNS) (*GlobalGNS, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.RoutingConfigGvk = nil
	objToCreate.Spec.GnsServiceGroupsGvk = nil
	objToCreate.Spec.PublicServicesGvk = nil
	objToCreate.Spec.SharedServicesGvk = nil
	objToCreate.Spec.SloPoliciesGvk = nil
	objToCreate.Spec.ExternalServicesGvk = nil
	objToCreate.Spec.AutoscalingPoliciesGvk = nil
	objToCreate.Spec.RoutingPoliciesGvk = nil
	objToCreate.Spec.ApiDiscoveryGvk = nil
	objToCreate.Spec.GeoDiscoveryGvk = nil
	objToCreate.Spec.PiiDiscoveryGvk = nil
	objToCreate.Spec.AttackDiscoveryGvk = nil
	objToCreate.Spec.UserDiscoveryGvk = nil
	objToCreate.Spec.GnsAccessControlPolicyGvk = nil
	objToCreate.Spec.GnsSchemaViolationDiscoveryGvk = nil
	objToCreate.Spec.GnsSegmentationPolicyGvk = nil
	objToCreate.Spec.MemberGroupsGvk = nil
	objToCreate.Spec.MembersGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GNSs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["globalnamespaces.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("globalnamespaces.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"gnsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"GNS\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GlobalNamespaces().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGNS{
		client: group.client,
		GNS:    result,
	}, nil
}

// UpdateGNSByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGNSByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.GNS) (*GlobalGNS, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			GNSs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDomain :=
		objToUpdate.Spec.Domain
	patchOpDomain := PatchOp{
		Op:    "replace",
		Path:  "/spec/domain",
		Value: patchValueDomain,
	}
	patch = append(patch, patchOpDomain)

	patchValueUseSharedGateway :=
		objToUpdate.Spec.UseSharedGateway
	patchOpUseSharedGateway := PatchOp{
		Op:    "replace",
		Path:  "/spec/useSharedGateway",
		Value: patchValueUseSharedGateway,
	}
	patch = append(patch, patchOpUseSharedGateway)

	patchValueMTLSEnforced :=
		objToUpdate.Spec.MTLSEnforced
	patchOpMTLSEnforced := PatchOp{
		Op:    "replace",
		Path:  "/spec/mTLSEnforced",
		Value: patchValueMTLSEnforced,
	}
	patch = append(patch, patchOpMTLSEnforced)

	patchValueMTLSPermissive :=
		objToUpdate.Spec.MTLSPermissive
	patchOpMTLSPermissive := PatchOp{
		Op:    "replace",
		Path:  "/spec/mTLSPermissive",
		Value: patchValueMTLSPermissive,
	}
	patch = append(patch, patchOpMTLSPermissive)

	patchValueApiDiscoveryEnabled :=
		objToUpdate.Spec.ApiDiscoveryEnabled
	patchOpApiDiscoveryEnabled := PatchOp{
		Op:    "replace",
		Path:  "/spec/apiDiscoveryEnabled",
		Value: patchValueApiDiscoveryEnabled,
	}
	patch = append(patch, patchOpApiDiscoveryEnabled)

	patchValueMTLSExceptions :=
		objToUpdate.Spec.MTLSExceptions
	patchOpMTLSExceptions := PatchOp{
		Op:    "replace",
		Path:  "/spec/mTLSExceptions",
		Value: patchValueMTLSExceptions,
	}
	patch = append(patch, patchOpMTLSExceptions)

	patchValueCaType :=
		objToUpdate.Spec.CaType
	patchOpCaType := PatchOp{
		Op:    "replace",
		Path:  "/spec/caType",
		Value: patchValueCaType,
	}
	patch = append(patch, patchOpCaType)

	patchValueCa :=
		objToUpdate.Spec.Ca
	patchOpCa := PatchOp{
		Op:    "replace",
		Path:  "/spec/ca",
		Value: patchValueCa,
	}
	patch = append(patch, patchOpCa)

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueColor :=
		objToUpdate.Spec.Color
	patchOpColor := PatchOp{
		Op:    "replace",
		Path:  "/spec/color",
		Value: patchValueColor,
	}
	patch = append(patch, patchOpColor)

	patchValueVersion :=
		objToUpdate.Spec.Version
	patchOpVersion := PatchOp{
		Op:    "replace",
		Path:  "/spec/version",
		Value: patchValueVersion,
	}
	patch = append(patch, patchOpVersion)

	patchValueProjectId :=
		objToUpdate.Spec.ProjectId
	patchOpProjectId := PatchOp{
		Op:    "replace",
		Path:  "/spec/projectId",
		Value: patchValueProjectId,
	}
	patch = append(patch, patchOpProjectId)

	patchValueMemberDomains :=
		objToUpdate.Spec.MemberDomains
	patchOpMemberDomains := PatchOp{
		Op:    "replace",
		Path:  "/spec/memberDomains",
		Value: patchValueMemberDomains,
	}
	patch = append(patch, patchOpMemberDomains)

	patchValueMatchingConditions :=
		objToUpdate.Spec.MatchingConditions
	patchOpMatchingConditions := PatchOp{
		Op:    "replace",
		Path:  "/spec/matchingConditions",
		Value: patchValueMatchingConditions,
	}
	patch = append(patch, patchOpMatchingConditions)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGNS{
		client: group.client,
		GNS:    result,
	}, nil
}

// ListGNSs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGNSs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGNS, err error) {
	key := "gnss.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGNS, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.GNS)
			result[k] = &GlobalGNS{
				client: group.client,
				GNS:    item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			GNSs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGNS, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGNS{
				client: group.client,
				GNS:    &item,
			}
		}
	}
	return
}

type GlobalGNS struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.GNS
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGNS) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGNSByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.GNS = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGNS) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGNSByName(ctx, obj.GNS)
	if err != nil {
		return err
	}
	obj.GNS = result.GNS
	return nil
}

func (obj *GlobalGNS) GetParent(ctx context.Context) (result *GlobalGlobalNamespace, err error) {
	hashedName := helper.GetHashedName("globalnamespaces.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["globalnamespaces.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGlobalNamespaceByName(ctx, hashedName)
}

// GetRoutingConfig returns child of given type
func (obj *GlobalGNS) GetRoutingConfig(ctx context.Context) (
	result *GlobalGNSRoutingConfig, err error) {
	if obj.Spec.RoutingConfigGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GNS", "RoutingConfig")
	}
	return obj.client.Global().GetGNSRoutingConfigByName(ctx, obj.Spec.RoutingConfigGvk.Name)
}

// AddRoutingConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGNS) AddRoutingConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GNSRoutingConfig) (result *GlobalGNSRoutingConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnss.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnss.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGNSRoutingConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// DeleteRoutingConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGNS) DeleteRoutingConfig(ctx context.Context) (err error) {
	if obj.Spec.RoutingConfigGvk != nil {
		err = obj.client.
			Global().DeleteGNSRoutingConfigByName(ctx, obj.Spec.RoutingConfigGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetGNSByName(ctx, obj.GetName())
	if err == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// GetAllGnsServiceGroups returns all children of given type
func (obj *GlobalGNS) GetAllGnsServiceGroups(ctx context.Context) (
	result []*GlobalGNSSvcGroup, err error) {
	result = make([]*GlobalGNSSvcGroup, 0, len(obj.Spec.GnsServiceGroupsGvk))
	for _, v := range obj.Spec.GnsServiceGroupsGvk {
		l, err := obj.client.Global().GetGNSSvcGroupByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGnsServiceGroups returns child which has given displayName
func (obj *GlobalGNS) GetGnsServiceGroups(ctx context.Context,
	displayName string) (result *GlobalGNSSvcGroup, err error) {
	l, ok := obj.Spec.GnsServiceGroupsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GNS", "GnsServiceGroups", displayName)
	}
	result, err = obj.client.Global().GetGNSSvcGroupByName(ctx, l.Name)
	return
}

// AddGnsServiceGroups calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGNS) AddGnsServiceGroups(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GNSSvcGroup) (result *GlobalGNSSvcGroup, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnss.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnss.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGNSSvcGroupByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// DeleteGnsServiceGroups calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGNS) DeleteGnsServiceGroups(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.GnsServiceGroupsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GNS", "GnsServiceGroups", displayName)
	}
	err = obj.client.Global().DeleteGNSSvcGroupByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if err == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// GetAllPublicServices returns all children of given type
func (obj *GlobalGNS) GetAllPublicServices(ctx context.Context) (
	result []*GlobalPublicServiceConfig, err error) {
	result = make([]*GlobalPublicServiceConfig, 0, len(obj.Spec.PublicServicesGvk))
	for _, v := range obj.Spec.PublicServicesGvk {
		l, err := obj.client.Global().GetPublicServiceConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetPublicServices returns child which has given displayName
func (obj *GlobalGNS) GetPublicServices(ctx context.Context,
	displayName string) (result *GlobalPublicServiceConfig, err error) {
	l, ok := obj.Spec.PublicServicesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GNS", "PublicServices", displayName)
	}
	result, err = obj.client.Global().GetPublicServiceConfigByName(ctx, l.Name)
	return
}

// AddPublicServices calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGNS) AddPublicServices(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PublicServiceConfig) (result *GlobalPublicServiceConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnss.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnss.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreatePublicServiceConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// DeletePublicServices calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGNS) DeletePublicServices(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.PublicServicesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GNS", "PublicServices", displayName)
	}
	err = obj.client.Global().DeletePublicServiceConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if err == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// GetAllSharedServices returns all children of given type
func (obj *GlobalGNS) GetAllSharedServices(ctx context.Context) (
	result []*GlobalSharedServiceConfig, err error) {
	result = make([]*GlobalSharedServiceConfig, 0, len(obj.Spec.SharedServicesGvk))
	for _, v := range obj.Spec.SharedServicesGvk {
		l, err := obj.client.Global().GetSharedServiceConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetSharedServices returns child which has given displayName
func (obj *GlobalGNS) GetSharedServices(ctx context.Context,
	displayName string) (result *GlobalSharedServiceConfig, err error) {
	l, ok := obj.Spec.SharedServicesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GNS", "SharedServices", displayName)
	}
	result, err = obj.client.Global().GetSharedServiceConfigByName(ctx, l.Name)
	return
}

// AddSharedServices calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGNS) AddSharedServices(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SharedServiceConfig) (result *GlobalSharedServiceConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnss.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnss.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateSharedServiceConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// DeleteSharedServices calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGNS) DeleteSharedServices(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.SharedServicesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GNS", "SharedServices", displayName)
	}
	err = obj.client.Global().DeleteSharedServiceConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if err == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// GetAllSloPolicies returns all children of given type
func (obj *GlobalGNS) GetAllSloPolicies(ctx context.Context) (
	result []*GlobalSLOPolicy, err error) {
	result = make([]*GlobalSLOPolicy, 0, len(obj.Spec.SloPoliciesGvk))
	for _, v := range obj.Spec.SloPoliciesGvk {
		l, err := obj.client.Global().GetSLOPolicyByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetSloPolicies returns child which has given displayName
func (obj *GlobalGNS) GetSloPolicies(ctx context.Context,
	displayName string) (result *GlobalSLOPolicy, err error) {
	l, ok := obj.Spec.SloPoliciesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GNS", "SloPolicies", displayName)
	}
	result, err = obj.client.Global().GetSLOPolicyByName(ctx, l.Name)
	return
}

// AddSloPolicies calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGNS) AddSloPolicies(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SLOPolicy) (result *GlobalSLOPolicy, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnss.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnss.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateSLOPolicyByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// DeleteSloPolicies calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGNS) DeleteSloPolicies(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.SloPoliciesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GNS", "SloPolicies", displayName)
	}
	err = obj.client.Global().DeleteSLOPolicyByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if err == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// GetAllExternalServices returns all children of given type
func (obj *GlobalGNS) GetAllExternalServices(ctx context.Context) (
	result []*GlobalExternalServiceConfig, err error) {
	result = make([]*GlobalExternalServiceConfig, 0, len(obj.Spec.ExternalServicesGvk))
	for _, v := range obj.Spec.ExternalServicesGvk {
		l, err := obj.client.Global().GetExternalServiceConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetExternalServices returns child which has given displayName
func (obj *GlobalGNS) GetExternalServices(ctx context.Context,
	displayName string) (result *GlobalExternalServiceConfig, err error) {
	l, ok := obj.Spec.ExternalServicesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GNS", "ExternalServices", displayName)
	}
	result, err = obj.client.Global().GetExternalServiceConfigByName(ctx, l.Name)
	return
}

// AddExternalServices calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGNS) AddExternalServices(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalServiceConfig) (result *GlobalExternalServiceConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnss.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnss.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateExternalServiceConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// DeleteExternalServices calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGNS) DeleteExternalServices(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ExternalServicesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GNS", "ExternalServices", displayName)
	}
	err = obj.client.Global().DeleteExternalServiceConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if err == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// GetAllAutoscalingPolicies returns all children of given type
func (obj *GlobalGNS) GetAllAutoscalingPolicies(ctx context.Context) (
	result []*GlobalAutoscalingPolicy, err error) {
	result = make([]*GlobalAutoscalingPolicy, 0, len(obj.Spec.AutoscalingPoliciesGvk))
	for _, v := range obj.Spec.AutoscalingPoliciesGvk {
		l, err := obj.client.Global().GetAutoscalingPolicyByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetAutoscalingPolicies returns child which has given displayName
func (obj *GlobalGNS) GetAutoscalingPolicies(ctx context.Context,
	displayName string) (result *GlobalAutoscalingPolicy, err error) {
	l, ok := obj.Spec.AutoscalingPoliciesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GNS", "AutoscalingPolicies", displayName)
	}
	result, err = obj.client.Global().GetAutoscalingPolicyByName(ctx, l.Name)
	return
}

// AddAutoscalingPolicies calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGNS) AddAutoscalingPolicies(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AutoscalingPolicy) (result *GlobalAutoscalingPolicy, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnss.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnss.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateAutoscalingPolicyByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// DeleteAutoscalingPolicies calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGNS) DeleteAutoscalingPolicies(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.AutoscalingPoliciesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GNS", "AutoscalingPolicies", displayName)
	}
	err = obj.client.Global().DeleteAutoscalingPolicyByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if err == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// GetAllRoutingPolicies returns all children of given type
func (obj *GlobalGNS) GetAllRoutingPolicies(ctx context.Context) (
	result []*GlobalGNSRoutingConfig, err error) {
	result = make([]*GlobalGNSRoutingConfig, 0, len(obj.Spec.RoutingPoliciesGvk))
	for _, v := range obj.Spec.RoutingPoliciesGvk {
		l, err := obj.client.Global().GetGNSRoutingConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetRoutingPolicies returns child which has given displayName
func (obj *GlobalGNS) GetRoutingPolicies(ctx context.Context,
	displayName string) (result *GlobalGNSRoutingConfig, err error) {
	l, ok := obj.Spec.RoutingPoliciesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GNS", "RoutingPolicies", displayName)
	}
	result, err = obj.client.Global().GetGNSRoutingConfigByName(ctx, l.Name)
	return
}

// AddRoutingPolicies calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGNS) AddRoutingPolicies(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GNSRoutingConfig) (result *GlobalGNSRoutingConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnss.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnss.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGNSRoutingConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// DeleteRoutingPolicies calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGNS) DeleteRoutingPolicies(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.RoutingPoliciesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GNS", "RoutingPolicies", displayName)
	}
	err = obj.client.Global().DeleteGNSRoutingConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if err == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// GetAllApiDiscovery returns all children of given type
func (obj *GlobalGNS) GetAllApiDiscovery(ctx context.Context) (
	result []*GlobalApiDiscovery, err error) {
	result = make([]*GlobalApiDiscovery, 0, len(obj.Spec.ApiDiscoveryGvk))
	for _, v := range obj.Spec.ApiDiscoveryGvk {
		l, err := obj.client.Global().GetApiDiscoveryByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetApiDiscovery returns child which has given displayName
func (obj *GlobalGNS) GetApiDiscovery(ctx context.Context,
	displayName string) (result *GlobalApiDiscovery, err error) {
	l, ok := obj.Spec.ApiDiscoveryGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GNS", "ApiDiscovery", displayName)
	}
	result, err = obj.client.Global().GetApiDiscoveryByName(ctx, l.Name)
	return
}

// AddApiDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGNS) AddApiDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ApiDiscovery) (result *GlobalApiDiscovery, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnss.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnss.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateApiDiscoveryByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// DeleteApiDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGNS) DeleteApiDiscovery(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ApiDiscoveryGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GNS", "ApiDiscovery", displayName)
	}
	err = obj.client.Global().DeleteApiDiscoveryByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if err == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// GetAllGeoDiscovery returns all children of given type
func (obj *GlobalGNS) GetAllGeoDiscovery(ctx context.Context) (
	result []*GlobalGeoDiscovery, err error) {
	result = make([]*GlobalGeoDiscovery, 0, len(obj.Spec.GeoDiscoveryGvk))
	for _, v := range obj.Spec.GeoDiscoveryGvk {
		l, err := obj.client.Global().GetGeoDiscoveryByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGeoDiscovery returns child which has given displayName
func (obj *GlobalGNS) GetGeoDiscovery(ctx context.Context,
	displayName string) (result *GlobalGeoDiscovery, err error) {
	l, ok := obj.Spec.GeoDiscoveryGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GNS", "GeoDiscovery", displayName)
	}
	result, err = obj.client.Global().GetGeoDiscoveryByName(ctx, l.Name)
	return
}

// AddGeoDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGNS) AddGeoDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GeoDiscovery) (result *GlobalGeoDiscovery, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnss.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnss.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGeoDiscoveryByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// DeleteGeoDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGNS) DeleteGeoDiscovery(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.GeoDiscoveryGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GNS", "GeoDiscovery", displayName)
	}
	err = obj.client.Global().DeleteGeoDiscoveryByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if err == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// GetAllPiiDiscovery returns all children of given type
func (obj *GlobalGNS) GetAllPiiDiscovery(ctx context.Context) (
	result []*GlobalPiiDiscovery, err error) {
	result = make([]*GlobalPiiDiscovery, 0, len(obj.Spec.PiiDiscoveryGvk))
	for _, v := range obj.Spec.PiiDiscoveryGvk {
		l, err := obj.client.Global().GetPiiDiscoveryByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetPiiDiscovery returns child which has given displayName
func (obj *GlobalGNS) GetPiiDiscovery(ctx context.Context,
	displayName string) (result *GlobalPiiDiscovery, err error) {
	l, ok := obj.Spec.PiiDiscoveryGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GNS", "PiiDiscovery", displayName)
	}
	result, err = obj.client.Global().GetPiiDiscoveryByName(ctx, l.Name)
	return
}

// AddPiiDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGNS) AddPiiDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PiiDiscovery) (result *GlobalPiiDiscovery, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnss.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnss.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreatePiiDiscoveryByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// DeletePiiDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGNS) DeletePiiDiscovery(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.PiiDiscoveryGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GNS", "PiiDiscovery", displayName)
	}
	err = obj.client.Global().DeletePiiDiscoveryByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if err == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// GetAllAttackDiscovery returns all children of given type
func (obj *GlobalGNS) GetAllAttackDiscovery(ctx context.Context) (
	result []*GlobalAttackDiscovery, err error) {
	result = make([]*GlobalAttackDiscovery, 0, len(obj.Spec.AttackDiscoveryGvk))
	for _, v := range obj.Spec.AttackDiscoveryGvk {
		l, err := obj.client.Global().GetAttackDiscoveryByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetAttackDiscovery returns child which has given displayName
func (obj *GlobalGNS) GetAttackDiscovery(ctx context.Context,
	displayName string) (result *GlobalAttackDiscovery, err error) {
	l, ok := obj.Spec.AttackDiscoveryGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GNS", "AttackDiscovery", displayName)
	}
	result, err = obj.client.Global().GetAttackDiscoveryByName(ctx, l.Name)
	return
}

// AddAttackDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGNS) AddAttackDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AttackDiscovery) (result *GlobalAttackDiscovery, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnss.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnss.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateAttackDiscoveryByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// DeleteAttackDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGNS) DeleteAttackDiscovery(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.AttackDiscoveryGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GNS", "AttackDiscovery", displayName)
	}
	err = obj.client.Global().DeleteAttackDiscoveryByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if err == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// GetAllUserDiscovery returns all children of given type
func (obj *GlobalGNS) GetAllUserDiscovery(ctx context.Context) (
	result []*GlobalUserDiscovery, err error) {
	result = make([]*GlobalUserDiscovery, 0, len(obj.Spec.UserDiscoveryGvk))
	for _, v := range obj.Spec.UserDiscoveryGvk {
		l, err := obj.client.Global().GetUserDiscoveryByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetUserDiscovery returns child which has given displayName
func (obj *GlobalGNS) GetUserDiscovery(ctx context.Context,
	displayName string) (result *GlobalUserDiscovery, err error) {
	l, ok := obj.Spec.UserDiscoveryGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GNS", "UserDiscovery", displayName)
	}
	result, err = obj.client.Global().GetUserDiscoveryByName(ctx, l.Name)
	return
}

// AddUserDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGNS) AddUserDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.UserDiscovery) (result *GlobalUserDiscovery, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnss.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnss.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateUserDiscoveryByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// DeleteUserDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGNS) DeleteUserDiscovery(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.UserDiscoveryGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GNS", "UserDiscovery", displayName)
	}
	err = obj.client.Global().DeleteUserDiscoveryByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if err == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// GetAllGnsAccessControlPolicy returns all children of given type
func (obj *GlobalGNS) GetAllGnsAccessControlPolicy(ctx context.Context) (
	result []*GlobalGnsAccessControlPolicy, err error) {
	result = make([]*GlobalGnsAccessControlPolicy, 0, len(obj.Spec.GnsAccessControlPolicyGvk))
	for _, v := range obj.Spec.GnsAccessControlPolicyGvk {
		l, err := obj.client.Global().GetGnsAccessControlPolicyByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGnsAccessControlPolicy returns child which has given displayName
func (obj *GlobalGNS) GetGnsAccessControlPolicy(ctx context.Context,
	displayName string) (result *GlobalGnsAccessControlPolicy, err error) {
	l, ok := obj.Spec.GnsAccessControlPolicyGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GNS", "GnsAccessControlPolicy", displayName)
	}
	result, err = obj.client.Global().GetGnsAccessControlPolicyByName(ctx, l.Name)
	return
}

// AddGnsAccessControlPolicy calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGNS) AddGnsAccessControlPolicy(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsAccessControlPolicy) (result *GlobalGnsAccessControlPolicy, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnss.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnss.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGnsAccessControlPolicyByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// DeleteGnsAccessControlPolicy calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGNS) DeleteGnsAccessControlPolicy(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.GnsAccessControlPolicyGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GNS", "GnsAccessControlPolicy", displayName)
	}
	err = obj.client.Global().DeleteGnsAccessControlPolicyByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if err == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// GetAllGnsSchemaViolationDiscovery returns all children of given type
func (obj *GlobalGNS) GetAllGnsSchemaViolationDiscovery(ctx context.Context) (
	result []*GlobalGnsSchemaViolationDiscovery, err error) {
	result = make([]*GlobalGnsSchemaViolationDiscovery, 0, len(obj.Spec.GnsSchemaViolationDiscoveryGvk))
	for _, v := range obj.Spec.GnsSchemaViolationDiscoveryGvk {
		l, err := obj.client.Global().GetGnsSchemaViolationDiscoveryByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGnsSchemaViolationDiscovery returns child which has given displayName
func (obj *GlobalGNS) GetGnsSchemaViolationDiscovery(ctx context.Context,
	displayName string) (result *GlobalGnsSchemaViolationDiscovery, err error) {
	l, ok := obj.Spec.GnsSchemaViolationDiscoveryGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GNS", "GnsSchemaViolationDiscovery", displayName)
	}
	result, err = obj.client.Global().GetGnsSchemaViolationDiscoveryByName(ctx, l.Name)
	return
}

// AddGnsSchemaViolationDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGNS) AddGnsSchemaViolationDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsSchemaViolationDiscovery) (result *GlobalGnsSchemaViolationDiscovery, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnss.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnss.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGnsSchemaViolationDiscoveryByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// DeleteGnsSchemaViolationDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGNS) DeleteGnsSchemaViolationDiscovery(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.GnsSchemaViolationDiscoveryGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GNS", "GnsSchemaViolationDiscovery", displayName)
	}
	err = obj.client.Global().DeleteGnsSchemaViolationDiscoveryByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if err == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// GetAllGnsSegmentationPolicy returns all children of given type
func (obj *GlobalGNS) GetAllGnsSegmentationPolicy(ctx context.Context) (
	result []*GlobalGnsSegmentationPolicy, err error) {
	result = make([]*GlobalGnsSegmentationPolicy, 0, len(obj.Spec.GnsSegmentationPolicyGvk))
	for _, v := range obj.Spec.GnsSegmentationPolicyGvk {
		l, err := obj.client.Global().GetGnsSegmentationPolicyByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGnsSegmentationPolicy returns child which has given displayName
func (obj *GlobalGNS) GetGnsSegmentationPolicy(ctx context.Context,
	displayName string) (result *GlobalGnsSegmentationPolicy, err error) {
	l, ok := obj.Spec.GnsSegmentationPolicyGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.GNS", "GnsSegmentationPolicy", displayName)
	}
	result, err = obj.client.Global().GetGnsSegmentationPolicyByName(ctx, l.Name)
	return
}

// AddGnsSegmentationPolicy calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalGNS) AddGnsSegmentationPolicy(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsSegmentationPolicy) (result *GlobalGnsSegmentationPolicy, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnss.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnss.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateGnsSegmentationPolicyByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if getErr == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// DeleteGnsSegmentationPolicy calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalGNS) DeleteGnsSegmentationPolicy(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.GnsSegmentationPolicyGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.GNS", "GnsSegmentationPolicy", displayName)
	}
	err = obj.client.Global().DeleteGnsSegmentationPolicyByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetGNSByName(ctx, obj.GetName())
	if err == nil {
		obj.GNS = updatedObj.GNS
	}
	return
}

// GetAllMemberGroups returns all links of given type
func (obj *GlobalGNS) GetAllMemberGroups(ctx context.Context) (
	result []*GlobalSvcGroup, err error) {
	result = make([]*GlobalSvcGroup, 0, len(obj.Spec.MemberGroupsGvk))
	for _, v := range obj.Spec.MemberGroupsGvk {
		l, err := obj.client.Global().GetSvcGroupByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetMemberGroups returns link which has given displayName
func (obj *GlobalGNS) GetMemberGroups(ctx context.Context,
	displayName string) (result *GlobalSvcGroup, err error) {
	l, ok := obj.Spec.MemberGroupsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.GNS", "MemberGroups", displayName)
	}
	result, err = obj.client.Global().GetSvcGroupByName(ctx, l.Name)
	return
}

// LinkMemberGroups links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalGNS) LinkMemberGroups(ctx context.Context,
	linkToAdd *GlobalSvcGroup) error {

	payload := "{\"spec\": {\"memberGroupsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"SvcGroup\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().GNSs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.GNS = result
	return nil
}

// UnlinkMemberGroups unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalGNS) UnlinkMemberGroups(ctx context.Context,
	linkToRemove *GlobalSvcGroup) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/memberGroupsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().GNSs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.GNS = result
	return nil

}

// GetAllMembers returns all links of given type
func (obj *GlobalGNS) GetAllMembers(ctx context.Context) (
	result []*GlobalDomain, err error) {
	result = make([]*GlobalDomain, 0, len(obj.Spec.MembersGvk))
	for _, v := range obj.Spec.MembersGvk {
		l, err := obj.client.Global().GetDomainByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetMembers returns link which has given displayName
func (obj *GlobalGNS) GetMembers(ctx context.Context,
	displayName string) (result *GlobalDomain, err error) {
	l, ok := obj.Spec.MembersGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.GNS", "Members", displayName)
	}
	result, err = obj.client.Global().GetDomainByName(ctx, l.Name)
	return
}

// LinkMembers links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalGNS) LinkMembers(ctx context.Context,
	linkToAdd *GlobalDomain) error {

	payload := "{\"spec\": {\"membersGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"Domain\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().GNSs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.GNS = result
	return nil
}

// UnlinkMembers unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalGNS) UnlinkMembers(ctx context.Context,
	linkToRemove *GlobalDomain) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/membersGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().GNSs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.GNS = result
	return nil

}

type gnsGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *gnsGlobalTsmV1Chainer) Subscribe() {
	key := "gnss.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGNSInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *gnsGlobalTsmV1Chainer) Unsubscribe() {
	key := "gnss.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *gnsGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "gnss.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *gnsGlobalTsmV1Chainer) RoutingConfig(name string) *gnsroutingconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gnsroutingconfigs.global.tsm.tanzu.vmware.com"] = name
	return &gnsroutingconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetRoutingConfig calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGlobalTsmV1Chainer) GetRoutingConfig(ctx context.Context, displayName string) (result *GlobalGNSRoutingConfig, err error) {
	hashedName := helper.GetHashedName("gnsroutingconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGNSRoutingConfigByName(ctx, hashedName)
}

// AddRoutingConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGlobalTsmV1Chainer) AddRoutingConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GNSRoutingConfig) (result *GlobalGNSRoutingConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gnsroutingconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGNSRoutingConfigByName(ctx, objToCreate)
}

// DeleteRoutingConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGlobalTsmV1Chainer) DeleteRoutingConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gnsroutingconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGNSRoutingConfigByName(ctx, hashedName)
}

func (c *gnsGlobalTsmV1Chainer) GnsServiceGroups(name string) *gnssvcgroupGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gnssvcgroups.global.tsm.tanzu.vmware.com"] = name
	return &gnssvcgroupGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGnsServiceGroups calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGlobalTsmV1Chainer) GetGnsServiceGroups(ctx context.Context, displayName string) (result *GlobalGNSSvcGroup, err error) {
	hashedName := helper.GetHashedName("gnssvcgroups.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGNSSvcGroupByName(ctx, hashedName)
}

// AddGnsServiceGroups calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGlobalTsmV1Chainer) AddGnsServiceGroups(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GNSSvcGroup) (result *GlobalGNSSvcGroup, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gnssvcgroups.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGNSSvcGroupByName(ctx, objToCreate)
}

// DeleteGnsServiceGroups calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGlobalTsmV1Chainer) DeleteGnsServiceGroups(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gnssvcgroups.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGNSSvcGroupByName(ctx, hashedName)
}

func (c *gnsGlobalTsmV1Chainer) PublicServices(name string) *publicserviceconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["publicserviceconfigs.global.tsm.tanzu.vmware.com"] = name
	return &publicserviceconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetPublicServices calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGlobalTsmV1Chainer) GetPublicServices(ctx context.Context, displayName string) (result *GlobalPublicServiceConfig, err error) {
	hashedName := helper.GetHashedName("publicserviceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetPublicServiceConfigByName(ctx, hashedName)
}

// AddPublicServices calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGlobalTsmV1Chainer) AddPublicServices(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PublicServiceConfig) (result *GlobalPublicServiceConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("publicserviceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreatePublicServiceConfigByName(ctx, objToCreate)
}

// DeletePublicServices calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGlobalTsmV1Chainer) DeletePublicServices(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("publicserviceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeletePublicServiceConfigByName(ctx, hashedName)
}

func (c *gnsGlobalTsmV1Chainer) SharedServices(name string) *sharedserviceconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["sharedserviceconfigs.global.tsm.tanzu.vmware.com"] = name
	return &sharedserviceconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetSharedServices calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGlobalTsmV1Chainer) GetSharedServices(ctx context.Context, displayName string) (result *GlobalSharedServiceConfig, err error) {
	hashedName := helper.GetHashedName("sharedserviceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetSharedServiceConfigByName(ctx, hashedName)
}

// AddSharedServices calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGlobalTsmV1Chainer) AddSharedServices(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SharedServiceConfig) (result *GlobalSharedServiceConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("sharedserviceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateSharedServiceConfigByName(ctx, objToCreate)
}

// DeleteSharedServices calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGlobalTsmV1Chainer) DeleteSharedServices(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("sharedserviceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteSharedServiceConfigByName(ctx, hashedName)
}

func (c *gnsGlobalTsmV1Chainer) SloPolicies(name string) *slopolicyGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["slopolicies.global.tsm.tanzu.vmware.com"] = name
	return &slopolicyGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetSloPolicies calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGlobalTsmV1Chainer) GetSloPolicies(ctx context.Context, displayName string) (result *GlobalSLOPolicy, err error) {
	hashedName := helper.GetHashedName("slopolicies.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetSLOPolicyByName(ctx, hashedName)
}

// AddSloPolicies calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGlobalTsmV1Chainer) AddSloPolicies(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SLOPolicy) (result *GlobalSLOPolicy, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("slopolicies.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateSLOPolicyByName(ctx, objToCreate)
}

// DeleteSloPolicies calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGlobalTsmV1Chainer) DeleteSloPolicies(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("slopolicies.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteSLOPolicyByName(ctx, hashedName)
}

func (c *gnsGlobalTsmV1Chainer) ExternalServices(name string) *externalserviceconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["externalserviceconfigs.global.tsm.tanzu.vmware.com"] = name
	return &externalserviceconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetExternalServices calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGlobalTsmV1Chainer) GetExternalServices(ctx context.Context, displayName string) (result *GlobalExternalServiceConfig, err error) {
	hashedName := helper.GetHashedName("externalserviceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetExternalServiceConfigByName(ctx, hashedName)
}

// AddExternalServices calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGlobalTsmV1Chainer) AddExternalServices(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalServiceConfig) (result *GlobalExternalServiceConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("externalserviceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateExternalServiceConfigByName(ctx, objToCreate)
}

// DeleteExternalServices calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGlobalTsmV1Chainer) DeleteExternalServices(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("externalserviceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteExternalServiceConfigByName(ctx, hashedName)
}

func (c *gnsGlobalTsmV1Chainer) AutoscalingPolicies(name string) *autoscalingpolicyGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["autoscalingpolicies.global.tsm.tanzu.vmware.com"] = name
	return &autoscalingpolicyGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetAutoscalingPolicies calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGlobalTsmV1Chainer) GetAutoscalingPolicies(ctx context.Context, displayName string) (result *GlobalAutoscalingPolicy, err error) {
	hashedName := helper.GetHashedName("autoscalingpolicies.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetAutoscalingPolicyByName(ctx, hashedName)
}

// AddAutoscalingPolicies calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGlobalTsmV1Chainer) AddAutoscalingPolicies(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AutoscalingPolicy) (result *GlobalAutoscalingPolicy, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("autoscalingpolicies.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateAutoscalingPolicyByName(ctx, objToCreate)
}

// DeleteAutoscalingPolicies calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGlobalTsmV1Chainer) DeleteAutoscalingPolicies(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("autoscalingpolicies.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteAutoscalingPolicyByName(ctx, hashedName)
}

func (c *gnsGlobalTsmV1Chainer) RoutingPolicies(name string) *gnsroutingconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gnsroutingconfigs.global.tsm.tanzu.vmware.com"] = name
	return &gnsroutingconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetRoutingPolicies calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGlobalTsmV1Chainer) GetRoutingPolicies(ctx context.Context, displayName string) (result *GlobalGNSRoutingConfig, err error) {
	hashedName := helper.GetHashedName("gnsroutingconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGNSRoutingConfigByName(ctx, hashedName)
}

// AddRoutingPolicies calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGlobalTsmV1Chainer) AddRoutingPolicies(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GNSRoutingConfig) (result *GlobalGNSRoutingConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gnsroutingconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGNSRoutingConfigByName(ctx, objToCreate)
}

// DeleteRoutingPolicies calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGlobalTsmV1Chainer) DeleteRoutingPolicies(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gnsroutingconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGNSRoutingConfigByName(ctx, hashedName)
}

func (c *gnsGlobalTsmV1Chainer) ApiDiscovery(name string) *apidiscoveryGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["apidiscoveries.global.tsm.tanzu.vmware.com"] = name
	return &apidiscoveryGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetApiDiscovery calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGlobalTsmV1Chainer) GetApiDiscovery(ctx context.Context, displayName string) (result *GlobalApiDiscovery, err error) {
	hashedName := helper.GetHashedName("apidiscoveries.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetApiDiscoveryByName(ctx, hashedName)
}

// AddApiDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGlobalTsmV1Chainer) AddApiDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ApiDiscovery) (result *GlobalApiDiscovery, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("apidiscoveries.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateApiDiscoveryByName(ctx, objToCreate)
}

// DeleteApiDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGlobalTsmV1Chainer) DeleteApiDiscovery(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("apidiscoveries.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteApiDiscoveryByName(ctx, hashedName)
}

func (c *gnsGlobalTsmV1Chainer) GeoDiscovery(name string) *geodiscoveryGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["geodiscoveries.global.tsm.tanzu.vmware.com"] = name
	return &geodiscoveryGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGeoDiscovery calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGlobalTsmV1Chainer) GetGeoDiscovery(ctx context.Context, displayName string) (result *GlobalGeoDiscovery, err error) {
	hashedName := helper.GetHashedName("geodiscoveries.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGeoDiscoveryByName(ctx, hashedName)
}

// AddGeoDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGlobalTsmV1Chainer) AddGeoDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GeoDiscovery) (result *GlobalGeoDiscovery, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("geodiscoveries.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGeoDiscoveryByName(ctx, objToCreate)
}

// DeleteGeoDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGlobalTsmV1Chainer) DeleteGeoDiscovery(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("geodiscoveries.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGeoDiscoveryByName(ctx, hashedName)
}

func (c *gnsGlobalTsmV1Chainer) PiiDiscovery(name string) *piidiscoveryGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["piidiscoveries.global.tsm.tanzu.vmware.com"] = name
	return &piidiscoveryGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetPiiDiscovery calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGlobalTsmV1Chainer) GetPiiDiscovery(ctx context.Context, displayName string) (result *GlobalPiiDiscovery, err error) {
	hashedName := helper.GetHashedName("piidiscoveries.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetPiiDiscoveryByName(ctx, hashedName)
}

// AddPiiDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGlobalTsmV1Chainer) AddPiiDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PiiDiscovery) (result *GlobalPiiDiscovery, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("piidiscoveries.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreatePiiDiscoveryByName(ctx, objToCreate)
}

// DeletePiiDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGlobalTsmV1Chainer) DeletePiiDiscovery(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("piidiscoveries.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeletePiiDiscoveryByName(ctx, hashedName)
}

func (c *gnsGlobalTsmV1Chainer) AttackDiscovery(name string) *attackdiscoveryGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["attackdiscoveries.global.tsm.tanzu.vmware.com"] = name
	return &attackdiscoveryGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetAttackDiscovery calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGlobalTsmV1Chainer) GetAttackDiscovery(ctx context.Context, displayName string) (result *GlobalAttackDiscovery, err error) {
	hashedName := helper.GetHashedName("attackdiscoveries.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetAttackDiscoveryByName(ctx, hashedName)
}

// AddAttackDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGlobalTsmV1Chainer) AddAttackDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AttackDiscovery) (result *GlobalAttackDiscovery, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("attackdiscoveries.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateAttackDiscoveryByName(ctx, objToCreate)
}

// DeleteAttackDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGlobalTsmV1Chainer) DeleteAttackDiscovery(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("attackdiscoveries.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteAttackDiscoveryByName(ctx, hashedName)
}

func (c *gnsGlobalTsmV1Chainer) UserDiscovery(name string) *userdiscoveryGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["userdiscoveries.global.tsm.tanzu.vmware.com"] = name
	return &userdiscoveryGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetUserDiscovery calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGlobalTsmV1Chainer) GetUserDiscovery(ctx context.Context, displayName string) (result *GlobalUserDiscovery, err error) {
	hashedName := helper.GetHashedName("userdiscoveries.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetUserDiscoveryByName(ctx, hashedName)
}

// AddUserDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGlobalTsmV1Chainer) AddUserDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.UserDiscovery) (result *GlobalUserDiscovery, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("userdiscoveries.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateUserDiscoveryByName(ctx, objToCreate)
}

// DeleteUserDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGlobalTsmV1Chainer) DeleteUserDiscovery(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("userdiscoveries.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteUserDiscoveryByName(ctx, hashedName)
}

func (c *gnsGlobalTsmV1Chainer) GnsAccessControlPolicy(name string) *gnsaccesscontrolpolicyGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gnsaccesscontrolpolicies.global.tsm.tanzu.vmware.com"] = name
	return &gnsaccesscontrolpolicyGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGnsAccessControlPolicy calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGlobalTsmV1Chainer) GetGnsAccessControlPolicy(ctx context.Context, displayName string) (result *GlobalGnsAccessControlPolicy, err error) {
	hashedName := helper.GetHashedName("gnsaccesscontrolpolicies.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGnsAccessControlPolicyByName(ctx, hashedName)
}

// AddGnsAccessControlPolicy calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGlobalTsmV1Chainer) AddGnsAccessControlPolicy(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsAccessControlPolicy) (result *GlobalGnsAccessControlPolicy, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gnsaccesscontrolpolicies.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGnsAccessControlPolicyByName(ctx, objToCreate)
}

// DeleteGnsAccessControlPolicy calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGlobalTsmV1Chainer) DeleteGnsAccessControlPolicy(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gnsaccesscontrolpolicies.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGnsAccessControlPolicyByName(ctx, hashedName)
}

func (c *gnsGlobalTsmV1Chainer) GnsSchemaViolationDiscovery(name string) *gnsschemaviolationdiscoveryGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gnsschemaviolationdiscoveries.global.tsm.tanzu.vmware.com"] = name
	return &gnsschemaviolationdiscoveryGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGnsSchemaViolationDiscovery calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGlobalTsmV1Chainer) GetGnsSchemaViolationDiscovery(ctx context.Context, displayName string) (result *GlobalGnsSchemaViolationDiscovery, err error) {
	hashedName := helper.GetHashedName("gnsschemaviolationdiscoveries.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGnsSchemaViolationDiscoveryByName(ctx, hashedName)
}

// AddGnsSchemaViolationDiscovery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGlobalTsmV1Chainer) AddGnsSchemaViolationDiscovery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsSchemaViolationDiscovery) (result *GlobalGnsSchemaViolationDiscovery, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gnsschemaviolationdiscoveries.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGnsSchemaViolationDiscoveryByName(ctx, objToCreate)
}

// DeleteGnsSchemaViolationDiscovery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGlobalTsmV1Chainer) DeleteGnsSchemaViolationDiscovery(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gnsschemaviolationdiscoveries.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGnsSchemaViolationDiscoveryByName(ctx, hashedName)
}

func (c *gnsGlobalTsmV1Chainer) GnsSegmentationPolicy(name string) *gnssegmentationpolicyGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gnssegmentationpolicies.global.tsm.tanzu.vmware.com"] = name
	return &gnssegmentationpolicyGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGnsSegmentationPolicy calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGlobalTsmV1Chainer) GetGnsSegmentationPolicy(ctx context.Context, displayName string) (result *GlobalGnsSegmentationPolicy, err error) {
	hashedName := helper.GetHashedName("gnssegmentationpolicies.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetGnsSegmentationPolicyByName(ctx, hashedName)
}

// AddGnsSegmentationPolicy calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGlobalTsmV1Chainer) AddGnsSegmentationPolicy(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsSegmentationPolicy) (result *GlobalGnsSegmentationPolicy, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gnssegmentationpolicies.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateGnsSegmentationPolicyByName(ctx, objToCreate)
}

// DeleteGnsSegmentationPolicy calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGlobalTsmV1Chainer) DeleteGnsSegmentationPolicy(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gnssegmentationpolicies.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteGnsSegmentationPolicyByName(ctx, hashedName)
}

// GetHaConfigV2ByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetHaConfigV2ByName(ctx context.Context, hashedName string) (*GlobalHaConfigV2, error) {
	key := "haconfigv2s.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.HaConfigV2)
		return &GlobalHaConfigV2{
			client:     group.client,
			HaConfigV2: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			HaConfigV2s().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalHaConfigV2{
			client:     group.client,
			HaConfigV2: result,
		}, nil
	}
}

// DeleteHaConfigV2ByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteHaConfigV2ByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		HaConfigV2s().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		HaConfigV2s().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/haConfigV2Gvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["hostconfigv2s.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("hostconfigv2s.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		HostConfigV2s().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateHaConfigV2ByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateHaConfigV2ByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.HaConfigV2) (*GlobalHaConfigV2, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		HaConfigV2s().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["hostconfigv2s.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("hostconfigv2s.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/haConfigV2Gvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "HaConfigV2",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		HostConfigV2s().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalHaConfigV2{
		client:     group.client,
		HaConfigV2: result,
	}, nil
}

// UpdateHaConfigV2ByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateHaConfigV2ByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.HaConfigV2) (*GlobalHaConfigV2, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			HaConfigV2s().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueConfigType :=
		objToUpdate.Spec.ConfigType
	patchOpConfigType := PatchOp{
		Op:    "replace",
		Path:  "/spec/configType",
		Value: patchValueConfigType,
	}
	patch = append(patch, patchOpConfigType)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		HaConfigV2s().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalHaConfigV2{
		client:     group.client,
		HaConfigV2: result,
	}, nil
}

// ListHaConfigV2s returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListHaConfigV2s(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalHaConfigV2, err error) {
	key := "haconfigv2s.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalHaConfigV2, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.HaConfigV2)
			result[k] = &GlobalHaConfigV2{
				client:     group.client,
				HaConfigV2: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			HaConfigV2s().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalHaConfigV2, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalHaConfigV2{
				client:     group.client,
				HaConfigV2: &item,
			}
		}
	}
	return
}

type GlobalHaConfigV2 struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.HaConfigV2
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalHaConfigV2) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteHaConfigV2ByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.HaConfigV2 = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalHaConfigV2) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateHaConfigV2ByName(ctx, obj.HaConfigV2)
	if err != nil {
		return err
	}
	obj.HaConfigV2 = result.HaConfigV2
	return nil
}

func (obj *GlobalHaConfigV2) GetParent(ctx context.Context) (result *GlobalHostConfigV2, err error) {
	hashedName := helper.GetHashedName("hostconfigv2s.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["hostconfigv2s.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetHostConfigV2ByName(ctx, hashedName)
}

type haconfigv2GlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *haconfigv2GlobalTsmV1Chainer) Subscribe() {
	key := "haconfigv2s.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewHaConfigV2Informer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *haconfigv2GlobalTsmV1Chainer) Unsubscribe() {
	key := "haconfigv2s.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *haconfigv2GlobalTsmV1Chainer) IsSubscribed() bool {
	key := "haconfigv2s.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetHaConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetHaConfigByName(ctx context.Context, hashedName string) (*GlobalHaConfig, error) {
	key := "haconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.HaConfig)
		return &GlobalHaConfig{
			client:   group.client,
			HaConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			HaConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalHaConfig{
			client:   group.client,
			HaConfig: result,
		}, nil
	}
}

// DeleteHaConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteHaConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		HaConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		HaConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/haConfigGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["hostconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("hostconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		HostConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateHaConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateHaConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.HaConfig) (*GlobalHaConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		HaConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["hostconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("hostconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/haConfigGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "HaConfig",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		HostConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalHaConfig{
		client:   group.client,
		HaConfig: result,
	}, nil
}

// UpdateHaConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateHaConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.HaConfig) (*GlobalHaConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			HaConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueConfigType :=
		objToUpdate.Spec.ConfigType
	patchOpConfigType := PatchOp{
		Op:    "replace",
		Path:  "/spec/configType",
		Value: patchValueConfigType,
	}
	patch = append(patch, patchOpConfigType)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		HaConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalHaConfig{
		client:   group.client,
		HaConfig: result,
	}, nil
}

// ListHaConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListHaConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalHaConfig, err error) {
	key := "haconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalHaConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.HaConfig)
			result[k] = &GlobalHaConfig{
				client:   group.client,
				HaConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			HaConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalHaConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalHaConfig{
				client:   group.client,
				HaConfig: &item,
			}
		}
	}
	return
}

type GlobalHaConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.HaConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalHaConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteHaConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.HaConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalHaConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateHaConfigByName(ctx, obj.HaConfig)
	if err != nil {
		return err
	}
	obj.HaConfig = result.HaConfig
	return nil
}

func (obj *GlobalHaConfig) GetParent(ctx context.Context) (result *GlobalHostConfig, err error) {
	hashedName := helper.GetHashedName("hostconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["hostconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetHostConfigByName(ctx, hashedName)
}

type haconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *haconfigGlobalTsmV1Chainer) Subscribe() {
	key := "haconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewHaConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *haconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "haconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *haconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "haconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetHealthCheckConfigNByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetHealthCheckConfigNByName(ctx context.Context, hashedName string) (*GlobalHealthCheckConfigN, error) {
	key := "healthcheckconfigns.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.HealthCheckConfigN)
		return &GlobalHealthCheckConfigN{
			client:             group.client,
			HealthCheckConfigN: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			HealthCheckConfigNs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalHealthCheckConfigN{
			client:             group.client,
			HealthCheckConfigN: result,
		}, nil
	}
}

// DeleteHealthCheckConfigNByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteHealthCheckConfigNByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		HealthCheckConfigNs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		HealthCheckConfigNs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/healthChecksGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["templates.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("templates.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Templates().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateHealthCheckConfigNByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateHealthCheckConfigNByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.HealthCheckConfigN) (*GlobalHealthCheckConfigN, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		HealthCheckConfigNs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["templates.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("templates.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"healthChecksGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"HealthCheckConfigN\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Templates().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalHealthCheckConfigN{
		client:             group.client,
		HealthCheckConfigN: result,
	}, nil
}

// UpdateHealthCheckConfigNByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateHealthCheckConfigNByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.HealthCheckConfigN) (*GlobalHealthCheckConfigN, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			HealthCheckConfigNs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueProjectId :=
		objToUpdate.Spec.ProjectId
	patchOpProjectId := PatchOp{
		Op:    "replace",
		Path:  "/spec/projectId",
		Value: patchValueProjectId,
	}
	patch = append(patch, patchOpProjectId)

	patchValueConfig :=
		objToUpdate.Spec.Config
	patchOpConfig := PatchOp{
		Op:    "replace",
		Path:  "/spec/config",
		Value: patchValueConfig,
	}
	patch = append(patch, patchOpConfig)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		HealthCheckConfigNs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalHealthCheckConfigN{
		client:             group.client,
		HealthCheckConfigN: result,
	}, nil
}

// ListHealthCheckConfigNs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListHealthCheckConfigNs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalHealthCheckConfigN, err error) {
	key := "healthcheckconfigns.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalHealthCheckConfigN, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.HealthCheckConfigN)
			result[k] = &GlobalHealthCheckConfigN{
				client:             group.client,
				HealthCheckConfigN: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			HealthCheckConfigNs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalHealthCheckConfigN, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalHealthCheckConfigN{
				client:             group.client,
				HealthCheckConfigN: &item,
			}
		}
	}
	return
}

type GlobalHealthCheckConfigN struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.HealthCheckConfigN
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalHealthCheckConfigN) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteHealthCheckConfigNByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.HealthCheckConfigN = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalHealthCheckConfigN) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateHealthCheckConfigNByName(ctx, obj.HealthCheckConfigN)
	if err != nil {
		return err
	}
	obj.HealthCheckConfigN = result.HealthCheckConfigN
	return nil
}

func (obj *GlobalHealthCheckConfigN) GetParent(ctx context.Context) (result *GlobalTemplate, err error) {
	hashedName := helper.GetHashedName("templates.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["templates.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetTemplateByName(ctx, hashedName)
}

type healthcheckconfignGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *healthcheckconfignGlobalTsmV1Chainer) Subscribe() {
	key := "healthcheckconfigns.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewHealthCheckConfigNInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *healthcheckconfignGlobalTsmV1Chainer) Unsubscribe() {
	key := "healthcheckconfigns.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *healthcheckconfignGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "healthcheckconfigns.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetHostConfigV2ByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetHostConfigV2ByName(ctx context.Context, hashedName string) (*GlobalHostConfigV2, error) {
	key := "hostconfigv2s.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.HostConfigV2)
		return &GlobalHostConfigV2{
			client:       group.client,
			HostConfigV2: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			HostConfigV2s().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalHostConfigV2{
			client:       group.client,
			HostConfigV2: result,
		}, nil
	}
}

// DeleteHostConfigV2ByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteHostConfigV2ByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		HostConfigV2s().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.HaConfigV2Gvk != nil {
		err := group.client.
			Global().
			DeleteHaConfigV2ByName(ctx, result.Spec.HaConfigV2Gvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.OutboundAuthenticationModeGvk != nil {
		err := group.client.
			Global().
			DeleteOutboundAuthenticationModeByName(ctx, result.Spec.OutboundAuthenticationModeGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		HostConfigV2s().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/hostConfigV2Gvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateHostConfigV2ByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateHostConfigV2ByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.HostConfigV2) (*GlobalHostConfigV2, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.HaConfigV2Gvk = nil
	objToCreate.Spec.OutboundAuthenticationModeGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		HostConfigV2s().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"hostConfigV2Gvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"HostConfigV2\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalHostConfigV2{
		client:       group.client,
		HostConfigV2: result,
	}, nil
}

// UpdateHostConfigV2ByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateHostConfigV2ByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.HostConfigV2) (*GlobalHostConfigV2, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			HostConfigV2s().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueHost :=
		objToUpdate.Spec.Host
	patchOpHost := PatchOp{
		Op:    "replace",
		Path:  "/spec/host",
		Value: patchValueHost,
	}
	patch = append(patch, patchOpHost)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		HostConfigV2s().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalHostConfigV2{
		client:       group.client,
		HostConfigV2: result,
	}, nil
}

// ListHostConfigV2s returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListHostConfigV2s(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalHostConfigV2, err error) {
	key := "hostconfigv2s.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalHostConfigV2, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.HostConfigV2)
			result[k] = &GlobalHostConfigV2{
				client:       group.client,
				HostConfigV2: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			HostConfigV2s().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalHostConfigV2, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalHostConfigV2{
				client:       group.client,
				HostConfigV2: &item,
			}
		}
	}
	return
}

type GlobalHostConfigV2 struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.HostConfigV2
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalHostConfigV2) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteHostConfigV2ByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.HostConfigV2 = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalHostConfigV2) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateHostConfigV2ByName(ctx, obj.HostConfigV2)
	if err != nil {
		return err
	}
	obj.HostConfigV2 = result.HostConfigV2
	return nil
}

func (obj *GlobalHostConfigV2) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

// GetHaConfigV2 returns child of given type
func (obj *GlobalHostConfigV2) GetHaConfigV2(ctx context.Context) (
	result *GlobalHaConfigV2, err error) {
	if obj.Spec.HaConfigV2Gvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.HostConfigV2", "HaConfigV2")
	}
	return obj.client.Global().GetHaConfigV2ByName(ctx, obj.Spec.HaConfigV2Gvk.Name)
}

// AddHaConfigV2 calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalHostConfigV2) AddHaConfigV2(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.HaConfigV2) (result *GlobalHaConfigV2, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["hostconfigv2s.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["hostconfigv2s.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateHaConfigV2ByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetHostConfigV2ByName(ctx, obj.GetName())
	if getErr == nil {
		obj.HostConfigV2 = updatedObj.HostConfigV2
	}
	return
}

// DeleteHaConfigV2 calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalHostConfigV2) DeleteHaConfigV2(ctx context.Context) (err error) {
	if obj.Spec.HaConfigV2Gvk != nil {
		err = obj.client.
			Global().DeleteHaConfigV2ByName(ctx, obj.Spec.HaConfigV2Gvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetHostConfigV2ByName(ctx, obj.GetName())
	if err == nil {
		obj.HostConfigV2 = updatedObj.HostConfigV2
	}
	return
}

// GetOutboundAuthenticationMode returns child of given type
func (obj *GlobalHostConfigV2) GetOutboundAuthenticationMode(ctx context.Context) (
	result *GlobalOutboundAuthenticationMode, err error) {
	if obj.Spec.OutboundAuthenticationModeGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.HostConfigV2", "OutboundAuthenticationMode")
	}
	return obj.client.Global().GetOutboundAuthenticationModeByName(ctx, obj.Spec.OutboundAuthenticationModeGvk.Name)
}

// AddOutboundAuthenticationMode calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalHostConfigV2) AddOutboundAuthenticationMode(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.OutboundAuthenticationMode) (result *GlobalOutboundAuthenticationMode, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["hostconfigv2s.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["hostconfigv2s.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateOutboundAuthenticationModeByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetHostConfigV2ByName(ctx, obj.GetName())
	if getErr == nil {
		obj.HostConfigV2 = updatedObj.HostConfigV2
	}
	return
}

// DeleteOutboundAuthenticationMode calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalHostConfigV2) DeleteOutboundAuthenticationMode(ctx context.Context) (err error) {
	if obj.Spec.OutboundAuthenticationModeGvk != nil {
		err = obj.client.
			Global().DeleteOutboundAuthenticationModeByName(ctx, obj.Spec.OutboundAuthenticationModeGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetHostConfigV2ByName(ctx, obj.GetName())
	if err == nil {
		obj.HostConfigV2 = updatedObj.HostConfigV2
	}
	return
}

type hostconfigv2GlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *hostconfigv2GlobalTsmV1Chainer) Subscribe() {
	key := "hostconfigv2s.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewHostConfigV2Informer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *hostconfigv2GlobalTsmV1Chainer) Unsubscribe() {
	key := "hostconfigv2s.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *hostconfigv2GlobalTsmV1Chainer) IsSubscribed() bool {
	key := "hostconfigv2s.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *hostconfigv2GlobalTsmV1Chainer) HaConfigV2(name string) *haconfigv2GlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["haconfigv2s.global.tsm.tanzu.vmware.com"] = name
	return &haconfigv2GlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetHaConfigV2 calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *hostconfigv2GlobalTsmV1Chainer) GetHaConfigV2(ctx context.Context, displayName string) (result *GlobalHaConfigV2, err error) {
	hashedName := helper.GetHashedName("haconfigv2s.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetHaConfigV2ByName(ctx, hashedName)
}

// AddHaConfigV2 calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *hostconfigv2GlobalTsmV1Chainer) AddHaConfigV2(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.HaConfigV2) (result *GlobalHaConfigV2, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("haconfigv2s.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateHaConfigV2ByName(ctx, objToCreate)
}

// DeleteHaConfigV2 calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *hostconfigv2GlobalTsmV1Chainer) DeleteHaConfigV2(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("haconfigv2s.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteHaConfigV2ByName(ctx, hashedName)
}

func (c *hostconfigv2GlobalTsmV1Chainer) OutboundAuthenticationMode(name string) *outboundauthenticationmodeGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["outboundauthenticationmodes.global.tsm.tanzu.vmware.com"] = name
	return &outboundauthenticationmodeGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetOutboundAuthenticationMode calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *hostconfigv2GlobalTsmV1Chainer) GetOutboundAuthenticationMode(ctx context.Context, displayName string) (result *GlobalOutboundAuthenticationMode, err error) {
	hashedName := helper.GetHashedName("outboundauthenticationmodes.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetOutboundAuthenticationModeByName(ctx, hashedName)
}

// AddOutboundAuthenticationMode calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *hostconfigv2GlobalTsmV1Chainer) AddOutboundAuthenticationMode(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.OutboundAuthenticationMode) (result *GlobalOutboundAuthenticationMode, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("outboundauthenticationmodes.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateOutboundAuthenticationModeByName(ctx, objToCreate)
}

// DeleteOutboundAuthenticationMode calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *hostconfigv2GlobalTsmV1Chainer) DeleteOutboundAuthenticationMode(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("outboundauthenticationmodes.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteOutboundAuthenticationModeByName(ctx, hashedName)
}

// GetHostConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetHostConfigByName(ctx context.Context, hashedName string) (*GlobalHostConfig, error) {
	key := "hostconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.HostConfig)
		return &GlobalHostConfig{
			client:     group.client,
			HostConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			HostConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalHostConfig{
			client:     group.client,
			HostConfig: result,
		}, nil
	}
}

// DeleteHostConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteHostConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		HostConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.HaConfigGvk != nil {
		err := group.client.
			Global().
			DeleteHaConfigByName(ctx, result.Spec.HaConfigGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		HostConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/hostConfigGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["clusterconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateHostConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateHostConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.HostConfig) (*GlobalHostConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.HaConfigGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		HostConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["clusterconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"hostConfigGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"HostConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalHostConfig{
		client:     group.client,
		HostConfig: result,
	}, nil
}

// UpdateHostConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateHostConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.HostConfig) (*GlobalHostConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			HostConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueHost :=
		objToUpdate.Spec.Host
	patchOpHost := PatchOp{
		Op:    "replace",
		Path:  "/spec/host",
		Value: patchValueHost,
	}
	patch = append(patch, patchOpHost)

	patchValueOwnedBy :=
		objToUpdate.Spec.OwnedBy
	patchOpOwnedBy := PatchOp{
		Op:    "replace",
		Path:  "/spec/ownedBy",
		Value: patchValueOwnedBy,
	}
	patch = append(patch, patchOpOwnedBy)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		HostConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalHostConfig{
		client:     group.client,
		HostConfig: result,
	}, nil
}

// ListHostConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListHostConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalHostConfig, err error) {
	key := "hostconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalHostConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.HostConfig)
			result[k] = &GlobalHostConfig{
				client:     group.client,
				HostConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			HostConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalHostConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalHostConfig{
				client:     group.client,
				HostConfig: &item,
			}
		}
	}
	return
}

type GlobalHostConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.HostConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalHostConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteHostConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.HostConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalHostConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateHostConfigByName(ctx, obj.HostConfig)
	if err != nil {
		return err
	}
	obj.HostConfig = result.HostConfig
	return nil
}

func (obj *GlobalHostConfig) GetParent(ctx context.Context) (result *GlobalClusterConfig, err error) {
	hashedName := helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["clusterconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetClusterConfigByName(ctx, hashedName)
}

// GetHaConfig returns child of given type
func (obj *GlobalHostConfig) GetHaConfig(ctx context.Context) (
	result *GlobalHaConfig, err error) {
	if obj.Spec.HaConfigGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.HostConfig", "HaConfig")
	}
	return obj.client.Global().GetHaConfigByName(ctx, obj.Spec.HaConfigGvk.Name)
}

// AddHaConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalHostConfig) AddHaConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.HaConfig) (result *GlobalHaConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["hostconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["hostconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateHaConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetHostConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.HostConfig = updatedObj.HostConfig
	}
	return
}

// DeleteHaConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalHostConfig) DeleteHaConfig(ctx context.Context) (err error) {
	if obj.Spec.HaConfigGvk != nil {
		err = obj.client.
			Global().DeleteHaConfigByName(ctx, obj.Spec.HaConfigGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetHostConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.HostConfig = updatedObj.HostConfig
	}
	return
}

type hostconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *hostconfigGlobalTsmV1Chainer) Subscribe() {
	key := "hostconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewHostConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *hostconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "hostconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *hostconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "hostconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *hostconfigGlobalTsmV1Chainer) HaConfig(name string) *haconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["haconfigs.global.tsm.tanzu.vmware.com"] = name
	return &haconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetHaConfig calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *hostconfigGlobalTsmV1Chainer) GetHaConfig(ctx context.Context, displayName string) (result *GlobalHaConfig, err error) {
	hashedName := helper.GetHashedName("haconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetHaConfigByName(ctx, hashedName)
}

// AddHaConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *hostconfigGlobalTsmV1Chainer) AddHaConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.HaConfig) (result *GlobalHaConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("haconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateHaConfigByName(ctx, objToCreate)
}

// DeleteHaConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *hostconfigGlobalTsmV1Chainer) DeleteHaConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("haconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteHaConfigByName(ctx, hashedName)
}

// GetInboundAuthenticationConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetInboundAuthenticationConfigByName(ctx context.Context, hashedName string) (*GlobalInboundAuthenticationConfig, error) {
	key := "inboundauthenticationconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.InboundAuthenticationConfig)
		return &GlobalInboundAuthenticationConfig{
			client:                      group.client,
			InboundAuthenticationConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			InboundAuthenticationConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalInboundAuthenticationConfig{
			client:                      group.client,
			InboundAuthenticationConfig: result,
		}, nil
	}
}

// DeleteInboundAuthenticationConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteInboundAuthenticationConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		InboundAuthenticationConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		InboundAuthenticationConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/inboundAuthenticationConfigGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateInboundAuthenticationConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateInboundAuthenticationConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.InboundAuthenticationConfig) (*GlobalInboundAuthenticationConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		InboundAuthenticationConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"inboundAuthenticationConfigGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"InboundAuthenticationConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalInboundAuthenticationConfig{
		client:                      group.client,
		InboundAuthenticationConfig: result,
	}, nil
}

// UpdateInboundAuthenticationConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateInboundAuthenticationConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.InboundAuthenticationConfig) (*GlobalInboundAuthenticationConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			InboundAuthenticationConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueOwnedBy :=
		objToUpdate.Spec.OwnedBy
	patchOpOwnedBy := PatchOp{
		Op:    "replace",
		Path:  "/spec/ownedBy",
		Value: patchValueOwnedBy,
	}
	patch = append(patch, patchOpOwnedBy)

	patchValueMode :=
		objToUpdate.Spec.Mode
	patchOpMode := PatchOp{
		Op:    "replace",
		Path:  "/spec/mode",
		Value: patchValueMode,
	}
	patch = append(patch, patchOpMode)

	patchValuePorts :=
		objToUpdate.Spec.Ports
	patchOpPorts := PatchOp{
		Op:    "replace",
		Path:  "/spec/ports",
		Value: patchValuePorts,
	}
	patch = append(patch, patchOpPorts)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		InboundAuthenticationConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalInboundAuthenticationConfig{
		client:                      group.client,
		InboundAuthenticationConfig: result,
	}, nil
}

// ListInboundAuthenticationConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListInboundAuthenticationConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalInboundAuthenticationConfig, err error) {
	key := "inboundauthenticationconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalInboundAuthenticationConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.InboundAuthenticationConfig)
			result[k] = &GlobalInboundAuthenticationConfig{
				client:                      group.client,
				InboundAuthenticationConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			InboundAuthenticationConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalInboundAuthenticationConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalInboundAuthenticationConfig{
				client:                      group.client,
				InboundAuthenticationConfig: &item,
			}
		}
	}
	return
}

type GlobalInboundAuthenticationConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.InboundAuthenticationConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalInboundAuthenticationConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteInboundAuthenticationConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.InboundAuthenticationConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalInboundAuthenticationConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateInboundAuthenticationConfigByName(ctx, obj.InboundAuthenticationConfig)
	if err != nil {
		return err
	}
	obj.InboundAuthenticationConfig = result.InboundAuthenticationConfig
	return nil
}

func (obj *GlobalInboundAuthenticationConfig) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

type inboundauthenticationconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *inboundauthenticationconfigGlobalTsmV1Chainer) Subscribe() {
	key := "inboundauthenticationconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewInboundAuthenticationConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *inboundauthenticationconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "inboundauthenticationconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *inboundauthenticationconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "inboundauthenticationconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetInventoryByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetInventoryByName(ctx context.Context, hashedName string) (*GlobalInventory, error) {
	key := "inventories.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Inventory)
		return &GlobalInventory{
			client:    group.client,
			Inventory: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Inventories().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalInventory{
			client:    group.client,
			Inventory: result,
		}, nil
	}
}

// DeleteInventoryByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteInventoryByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Inventories().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.RegionsGvk {
		err := group.client.
			Global().DeleteDCRegionByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ClustersGvk {
		err := group.client.
			Global().DeleteClusterByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.JobFolderGvk != nil {
		err := group.client.
			Global().
			DeleteJobFolderByName(ctx, result.Spec.JobFolderGvk.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ExternalDNSGvk {
		err := group.client.
			Global().DeleteExternalDNSInventoryByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Inventories().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/inventoryGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["roots.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("roots.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Roots().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateInventoryByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateInventoryByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Inventory) (*GlobalInventory, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.RegionsGvk = nil
	objToCreate.Spec.ClustersGvk = nil
	objToCreate.Spec.JobFolderGvk = nil
	objToCreate.Spec.ExternalDNSGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Inventories().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["roots.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("roots.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/inventoryGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "Inventory",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Roots().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalInventory{
		client:    group.client,
		Inventory: result,
	}, nil
}

// UpdateInventoryByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateInventoryByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Inventory) (*GlobalInventory, error) {
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Inventories().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Inventories().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalInventory{
		client:    group.client,
		Inventory: result,
	}, nil
}

// ListInventories returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListInventories(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalInventory, err error) {
	key := "inventories.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalInventory, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Inventory)
			result[k] = &GlobalInventory{
				client:    group.client,
				Inventory: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Inventories().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalInventory, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalInventory{
				client:    group.client,
				Inventory: &item,
			}
		}
	}
	return
}

type GlobalInventory struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Inventory
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalInventory) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteInventoryByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Inventory = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalInventory) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateInventoryByName(ctx, obj.Inventory)
	if err != nil {
		return err
	}
	obj.Inventory = result.Inventory
	return nil
}

func (obj *GlobalInventory) GetParent(ctx context.Context) (result *GlobalRoot, err error) {
	hashedName := helper.GetHashedName("roots.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["roots.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetRootByName(ctx, hashedName)
}

// GetAllRegions returns all children of given type
func (obj *GlobalInventory) GetAllRegions(ctx context.Context) (
	result []*GlobalDCRegion, err error) {
	result = make([]*GlobalDCRegion, 0, len(obj.Spec.RegionsGvk))
	for _, v := range obj.Spec.RegionsGvk {
		l, err := obj.client.Global().GetDCRegionByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetRegions returns child which has given displayName
func (obj *GlobalInventory) GetRegions(ctx context.Context,
	displayName string) (result *GlobalDCRegion, err error) {
	l, ok := obj.Spec.RegionsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Inventory", "Regions", displayName)
	}
	result, err = obj.client.Global().GetDCRegionByName(ctx, l.Name)
	return
}

// AddRegions calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalInventory) AddRegions(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DCRegion) (result *GlobalDCRegion, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["inventories.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["inventories.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateDCRegionByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetInventoryByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Inventory = updatedObj.Inventory
	}
	return
}

// DeleteRegions calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalInventory) DeleteRegions(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.RegionsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Inventory", "Regions", displayName)
	}
	err = obj.client.Global().DeleteDCRegionByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetInventoryByName(ctx, obj.GetName())
	if err == nil {
		obj.Inventory = updatedObj.Inventory
	}
	return
}

// GetAllClusters returns all children of given type
func (obj *GlobalInventory) GetAllClusters(ctx context.Context) (
	result []*GlobalCluster, err error) {
	result = make([]*GlobalCluster, 0, len(obj.Spec.ClustersGvk))
	for _, v := range obj.Spec.ClustersGvk {
		l, err := obj.client.Global().GetClusterByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetClusters returns child which has given displayName
func (obj *GlobalInventory) GetClusters(ctx context.Context,
	displayName string) (result *GlobalCluster, err error) {
	l, ok := obj.Spec.ClustersGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Inventory", "Clusters", displayName)
	}
	result, err = obj.client.Global().GetClusterByName(ctx, l.Name)
	return
}

// AddClusters calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalInventory) AddClusters(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Cluster) (result *GlobalCluster, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["inventories.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["inventories.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateClusterByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetInventoryByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Inventory = updatedObj.Inventory
	}
	return
}

// DeleteClusters calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalInventory) DeleteClusters(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ClustersGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Inventory", "Clusters", displayName)
	}
	err = obj.client.Global().DeleteClusterByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetInventoryByName(ctx, obj.GetName())
	if err == nil {
		obj.Inventory = updatedObj.Inventory
	}
	return
}

// GetJobFolder returns child of given type
func (obj *GlobalInventory) GetJobFolder(ctx context.Context) (
	result *GlobalJobFolder, err error) {
	if obj.Spec.JobFolderGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Inventory", "JobFolder")
	}
	return obj.client.Global().GetJobFolderByName(ctx, obj.Spec.JobFolderGvk.Name)
}

// AddJobFolder calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalInventory) AddJobFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.JobFolder) (result *GlobalJobFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["inventories.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["inventories.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateJobFolderByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetInventoryByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Inventory = updatedObj.Inventory
	}
	return
}

// DeleteJobFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalInventory) DeleteJobFolder(ctx context.Context) (err error) {
	if obj.Spec.JobFolderGvk != nil {
		err = obj.client.
			Global().DeleteJobFolderByName(ctx, obj.Spec.JobFolderGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetInventoryByName(ctx, obj.GetName())
	if err == nil {
		obj.Inventory = updatedObj.Inventory
	}
	return
}

// GetAllExternalDNS returns all children of given type
func (obj *GlobalInventory) GetAllExternalDNS(ctx context.Context) (
	result []*GlobalExternalDNSInventory, err error) {
	result = make([]*GlobalExternalDNSInventory, 0, len(obj.Spec.ExternalDNSGvk))
	for _, v := range obj.Spec.ExternalDNSGvk {
		l, err := obj.client.Global().GetExternalDNSInventoryByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetExternalDNS returns child which has given displayName
func (obj *GlobalInventory) GetExternalDNS(ctx context.Context,
	displayName string) (result *GlobalExternalDNSInventory, err error) {
	l, ok := obj.Spec.ExternalDNSGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Inventory", "ExternalDNS", displayName)
	}
	result, err = obj.client.Global().GetExternalDNSInventoryByName(ctx, l.Name)
	return
}

// AddExternalDNS calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalInventory) AddExternalDNS(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventory) (result *GlobalExternalDNSInventory, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["inventories.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["inventories.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateExternalDNSInventoryByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetInventoryByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Inventory = updatedObj.Inventory
	}
	return
}

// DeleteExternalDNS calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalInventory) DeleteExternalDNS(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ExternalDNSGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Inventory", "ExternalDNS", displayName)
	}
	err = obj.client.Global().DeleteExternalDNSInventoryByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetInventoryByName(ctx, obj.GetName())
	if err == nil {
		obj.Inventory = updatedObj.Inventory
	}
	return
}

type inventoryGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *inventoryGlobalTsmV1Chainer) Subscribe() {
	key := "inventories.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewInventoryInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *inventoryGlobalTsmV1Chainer) Unsubscribe() {
	key := "inventories.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *inventoryGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "inventories.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *inventoryGlobalTsmV1Chainer) Regions(name string) *dcregionGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["dcregions.global.tsm.tanzu.vmware.com"] = name
	return &dcregionGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetRegions calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *inventoryGlobalTsmV1Chainer) GetRegions(ctx context.Context, displayName string) (result *GlobalDCRegion, err error) {
	hashedName := helper.GetHashedName("dcregions.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetDCRegionByName(ctx, hashedName)
}

// AddRegions calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *inventoryGlobalTsmV1Chainer) AddRegions(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DCRegion) (result *GlobalDCRegion, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("dcregions.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateDCRegionByName(ctx, objToCreate)
}

// DeleteRegions calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *inventoryGlobalTsmV1Chainer) DeleteRegions(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("dcregions.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteDCRegionByName(ctx, hashedName)
}

func (c *inventoryGlobalTsmV1Chainer) Clusters(name string) *clusterGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["clusters.global.tsm.tanzu.vmware.com"] = name
	return &clusterGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetClusters calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *inventoryGlobalTsmV1Chainer) GetClusters(ctx context.Context, displayName string) (result *GlobalCluster, err error) {
	hashedName := helper.GetHashedName("clusters.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetClusterByName(ctx, hashedName)
}

// AddClusters calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *inventoryGlobalTsmV1Chainer) AddClusters(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Cluster) (result *GlobalCluster, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("clusters.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateClusterByName(ctx, objToCreate)
}

// DeleteClusters calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *inventoryGlobalTsmV1Chainer) DeleteClusters(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("clusters.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteClusterByName(ctx, hashedName)
}

func (c *inventoryGlobalTsmV1Chainer) JobFolder(name string) *jobfolderGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["jobfolders.global.tsm.tanzu.vmware.com"] = name
	return &jobfolderGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetJobFolder calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *inventoryGlobalTsmV1Chainer) GetJobFolder(ctx context.Context, displayName string) (result *GlobalJobFolder, err error) {
	hashedName := helper.GetHashedName("jobfolders.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetJobFolderByName(ctx, hashedName)
}

// AddJobFolder calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *inventoryGlobalTsmV1Chainer) AddJobFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.JobFolder) (result *GlobalJobFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("jobfolders.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateJobFolderByName(ctx, objToCreate)
}

// DeleteJobFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *inventoryGlobalTsmV1Chainer) DeleteJobFolder(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("jobfolders.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteJobFolderByName(ctx, hashedName)
}

func (c *inventoryGlobalTsmV1Chainer) ExternalDNS(name string) *externaldnsinventoryGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["externaldnsinventories.global.tsm.tanzu.vmware.com"] = name
	return &externaldnsinventoryGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetExternalDNS calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *inventoryGlobalTsmV1Chainer) GetExternalDNS(ctx context.Context, displayName string) (result *GlobalExternalDNSInventory, err error) {
	hashedName := helper.GetHashedName("externaldnsinventories.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetExternalDNSInventoryByName(ctx, hashedName)
}

// AddExternalDNS calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *inventoryGlobalTsmV1Chainer) AddExternalDNS(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSInventory) (result *GlobalExternalDNSInventory, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("externaldnsinventories.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateExternalDNSInventoryByName(ctx, objToCreate)
}

// DeleteExternalDNS calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *inventoryGlobalTsmV1Chainer) DeleteExternalDNS(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("externaldnsinventories.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteExternalDNSInventoryByName(ctx, hashedName)
}

// GetIssuerByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetIssuerByName(ctx context.Context, hashedName string) (*GlobalIssuer, error) {
	key := "issuers.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Issuer)
		return &GlobalIssuer{
			client: group.client,
			Issuer: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Issuers().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalIssuer{
			client: group.client,
			Issuer: result,
		}, nil
	}
}

// DeleteIssuerByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteIssuerByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Issuers().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Issuers().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/issuersGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateIssuerByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateIssuerByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Issuer) (*GlobalIssuer, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Issuers().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"issuersGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"Issuer\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalIssuer{
		client: group.client,
		Issuer: result,
	}, nil
}

// UpdateIssuerByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateIssuerByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Issuer) (*GlobalIssuer, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Issuers().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueMetadata :=
		objToUpdate.Spec.Metadata
	patchOpMetadata := PatchOp{
		Op:    "replace",
		Path:  "/spec/metadata",
		Value: patchValueMetadata,
	}
	patch = append(patch, patchOpMetadata)

	patchValueVenafi :=
		objToUpdate.Spec.Venafi
	patchOpVenafi := PatchOp{
		Op:    "replace",
		Path:  "/spec/venafi",
		Value: patchValueVenafi,
	}
	patch = append(patch, patchOpVenafi)

	patchValueStatus :=
		objToUpdate.Spec.Status
	patchOpStatus := PatchOp{
		Op:    "replace",
		Path:  "/spec/status",
		Value: patchValueStatus,
	}
	patch = append(patch, patchOpStatus)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Issuers().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalIssuer{
		client: group.client,
		Issuer: result,
	}, nil
}

// ListIssuers returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListIssuers(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalIssuer, err error) {
	key := "issuers.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalIssuer, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Issuer)
			result[k] = &GlobalIssuer{
				client: group.client,
				Issuer: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Issuers().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalIssuer, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalIssuer{
				client: group.client,
				Issuer: &item,
			}
		}
	}
	return
}

type GlobalIssuer struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Issuer
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalIssuer) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteIssuerByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Issuer = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalIssuer) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateIssuerByName(ctx, obj.Issuer)
	if err != nil {
		return err
	}
	obj.Issuer = result.Issuer
	return nil
}

func (obj *GlobalIssuer) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

type issuerGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *issuerGlobalTsmV1Chainer) Subscribe() {
	key := "issuers.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewIssuerInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *issuerGlobalTsmV1Chainer) Unsubscribe() {
	key := "issuers.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *issuerGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "issuers.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetJobConfigFolderByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetJobConfigFolderByName(ctx context.Context, hashedName string) (*GlobalJobConfigFolder, error) {
	key := "jobconfigfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.JobConfigFolder)
		return &GlobalJobConfigFolder{
			client:          group.client,
			JobConfigFolder: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			JobConfigFolders().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalJobConfigFolder{
			client:          group.client,
			JobConfigFolder: result,
		}, nil
	}
}

// DeleteJobConfigFolderByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteJobConfigFolderByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		JobConfigFolders().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.JobConfigGvk {
		err := group.client.
			Global().DeleteJobConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		JobConfigFolders().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/jobConfigFolderGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["runtimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateJobConfigFolderByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateJobConfigFolderByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.JobConfigFolder) (*GlobalJobConfigFolder, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.JobConfigGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		JobConfigFolders().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["runtimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/jobConfigFolderGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "JobConfigFolder",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalJobConfigFolder{
		client:          group.client,
		JobConfigFolder: result,
	}, nil
}

// UpdateJobConfigFolderByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateJobConfigFolderByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.JobConfigFolder) (*GlobalJobConfigFolder, error) {
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			JobConfigFolders().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		JobConfigFolders().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalJobConfigFolder{
		client:          group.client,
		JobConfigFolder: result,
	}, nil
}

// ListJobConfigFolders returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListJobConfigFolders(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalJobConfigFolder, err error) {
	key := "jobconfigfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalJobConfigFolder, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.JobConfigFolder)
			result[k] = &GlobalJobConfigFolder{
				client:          group.client,
				JobConfigFolder: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			JobConfigFolders().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalJobConfigFolder, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalJobConfigFolder{
				client:          group.client,
				JobConfigFolder: &item,
			}
		}
	}
	return
}

type GlobalJobConfigFolder struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.JobConfigFolder
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalJobConfigFolder) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteJobConfigFolderByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.JobConfigFolder = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalJobConfigFolder) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateJobConfigFolderByName(ctx, obj.JobConfigFolder)
	if err != nil {
		return err
	}
	obj.JobConfigFolder = result.JobConfigFolder
	return nil
}

func (obj *GlobalJobConfigFolder) GetParent(ctx context.Context) (result *GlobalRuntime, err error) {
	hashedName := helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["runtimes.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetRuntimeByName(ctx, hashedName)
}

// GetAllJobConfig returns all children of given type
func (obj *GlobalJobConfigFolder) GetAllJobConfig(ctx context.Context) (
	result []*GlobalJobConfig, err error) {
	result = make([]*GlobalJobConfig, 0, len(obj.Spec.JobConfigGvk))
	for _, v := range obj.Spec.JobConfigGvk {
		l, err := obj.client.Global().GetJobConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetJobConfig returns child which has given displayName
func (obj *GlobalJobConfigFolder) GetJobConfig(ctx context.Context,
	displayName string) (result *GlobalJobConfig, err error) {
	l, ok := obj.Spec.JobConfigGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.JobConfigFolder", "JobConfig", displayName)
	}
	result, err = obj.client.Global().GetJobConfigByName(ctx, l.Name)
	return
}

// AddJobConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalJobConfigFolder) AddJobConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.JobConfig) (result *GlobalJobConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["jobconfigfolders.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["jobconfigfolders.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateJobConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetJobConfigFolderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.JobConfigFolder = updatedObj.JobConfigFolder
	}
	return
}

// DeleteJobConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalJobConfigFolder) DeleteJobConfig(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.JobConfigGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.JobConfigFolder", "JobConfig", displayName)
	}
	err = obj.client.Global().DeleteJobConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetJobConfigFolderByName(ctx, obj.GetName())
	if err == nil {
		obj.JobConfigFolder = updatedObj.JobConfigFolder
	}
	return
}

type jobconfigfolderGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *jobconfigfolderGlobalTsmV1Chainer) Subscribe() {
	key := "jobconfigfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewJobConfigFolderInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *jobconfigfolderGlobalTsmV1Chainer) Unsubscribe() {
	key := "jobconfigfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *jobconfigfolderGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "jobconfigfolders.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *jobconfigfolderGlobalTsmV1Chainer) JobConfig(name string) *jobconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["jobconfigs.global.tsm.tanzu.vmware.com"] = name
	return &jobconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetJobConfig calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *jobconfigfolderGlobalTsmV1Chainer) GetJobConfig(ctx context.Context, displayName string) (result *GlobalJobConfig, err error) {
	hashedName := helper.GetHashedName("jobconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetJobConfigByName(ctx, hashedName)
}

// AddJobConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *jobconfigfolderGlobalTsmV1Chainer) AddJobConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.JobConfig) (result *GlobalJobConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("jobconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateJobConfigByName(ctx, objToCreate)
}

// DeleteJobConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *jobconfigfolderGlobalTsmV1Chainer) DeleteJobConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("jobconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteJobConfigByName(ctx, hashedName)
}

// GetJobConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetJobConfigByName(ctx context.Context, hashedName string) (*GlobalJobConfig, error) {
	key := "jobconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.JobConfig)
		return &GlobalJobConfig{
			client:    group.client,
			JobConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			JobConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalJobConfig{
			client:    group.client,
			JobConfig: result,
		}, nil
	}
}

// DeleteJobConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteJobConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		JobConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		JobConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/jobConfigGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["jobconfigfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("jobconfigfolders.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		JobConfigFolders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateJobConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateJobConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.JobConfig) (*GlobalJobConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		JobConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["jobconfigfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("jobconfigfolders.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"jobConfigGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"JobConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		JobConfigFolders().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalJobConfig{
		client:    group.client,
		JobConfig: result,
	}, nil
}

// UpdateJobConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateJobConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.JobConfig) (*GlobalJobConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			JobConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueConfig :=
		objToUpdate.Spec.Config
	patchOpConfig := PatchOp{
		Op:    "replace",
		Path:  "/spec/config",
		Value: patchValueConfig,
	}
	patch = append(patch, patchOpConfig)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		JobConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalJobConfig{
		client:    group.client,
		JobConfig: result,
	}, nil
}

// ListJobConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListJobConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalJobConfig, err error) {
	key := "jobconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalJobConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.JobConfig)
			result[k] = &GlobalJobConfig{
				client:    group.client,
				JobConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			JobConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalJobConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalJobConfig{
				client:    group.client,
				JobConfig: &item,
			}
		}
	}
	return
}

type GlobalJobConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.JobConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalJobConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteJobConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.JobConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalJobConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateJobConfigByName(ctx, obj.JobConfig)
	if err != nil {
		return err
	}
	obj.JobConfig = result.JobConfig
	return nil
}

func (obj *GlobalJobConfig) GetParent(ctx context.Context) (result *GlobalJobConfigFolder, err error) {
	hashedName := helper.GetHashedName("jobconfigfolders.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["jobconfigfolders.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetJobConfigFolderByName(ctx, hashedName)
}

type jobconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *jobconfigGlobalTsmV1Chainer) Subscribe() {
	key := "jobconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewJobConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *jobconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "jobconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *jobconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "jobconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetJobFolderByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetJobFolderByName(ctx context.Context, hashedName string) (*GlobalJobFolder, error) {
	key := "jobfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.JobFolder)
		return &GlobalJobFolder{
			client:    group.client,
			JobFolder: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			JobFolders().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalJobFolder{
			client:    group.client,
			JobFolder: result,
		}, nil
	}
}

// DeleteJobFolderByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteJobFolderByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		JobFolders().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.JobsGvk {
		err := group.client.
			Global().DeleteJobByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		JobFolders().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/jobFolderGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["inventories.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("inventories.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Inventories().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateJobFolderByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateJobFolderByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.JobFolder) (*GlobalJobFolder, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.JobsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		JobFolders().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["inventories.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("inventories.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/jobFolderGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "JobFolder",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Inventories().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalJobFolder{
		client:    group.client,
		JobFolder: result,
	}, nil
}

// UpdateJobFolderByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateJobFolderByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.JobFolder) (*GlobalJobFolder, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			JobFolders().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		JobFolders().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalJobFolder{
		client:    group.client,
		JobFolder: result,
	}, nil
}

// ListJobFolders returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListJobFolders(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalJobFolder, err error) {
	key := "jobfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalJobFolder, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.JobFolder)
			result[k] = &GlobalJobFolder{
				client:    group.client,
				JobFolder: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			JobFolders().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalJobFolder, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalJobFolder{
				client:    group.client,
				JobFolder: &item,
			}
		}
	}
	return
}

type GlobalJobFolder struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.JobFolder
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalJobFolder) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteJobFolderByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.JobFolder = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalJobFolder) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateJobFolderByName(ctx, obj.JobFolder)
	if err != nil {
		return err
	}
	obj.JobFolder = result.JobFolder
	return nil
}

func (obj *GlobalJobFolder) GetParent(ctx context.Context) (result *GlobalInventory, err error) {
	hashedName := helper.GetHashedName("inventories.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["inventories.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetInventoryByName(ctx, hashedName)
}

// GetAllJobs returns all children of given type
func (obj *GlobalJobFolder) GetAllJobs(ctx context.Context) (
	result []*GlobalJob, err error) {
	result = make([]*GlobalJob, 0, len(obj.Spec.JobsGvk))
	for _, v := range obj.Spec.JobsGvk {
		l, err := obj.client.Global().GetJobByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetJobs returns child which has given displayName
func (obj *GlobalJobFolder) GetJobs(ctx context.Context,
	displayName string) (result *GlobalJob, err error) {
	l, ok := obj.Spec.JobsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.JobFolder", "Jobs", displayName)
	}
	result, err = obj.client.Global().GetJobByName(ctx, l.Name)
	return
}

// AddJobs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalJobFolder) AddJobs(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Job) (result *GlobalJob, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["jobfolders.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["jobfolders.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateJobByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetJobFolderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.JobFolder = updatedObj.JobFolder
	}
	return
}

// DeleteJobs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalJobFolder) DeleteJobs(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.JobsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.JobFolder", "Jobs", displayName)
	}
	err = obj.client.Global().DeleteJobByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetJobFolderByName(ctx, obj.GetName())
	if err == nil {
		obj.JobFolder = updatedObj.JobFolder
	}
	return
}

type jobfolderGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *jobfolderGlobalTsmV1Chainer) Subscribe() {
	key := "jobfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewJobFolderInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *jobfolderGlobalTsmV1Chainer) Unsubscribe() {
	key := "jobfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *jobfolderGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "jobfolders.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *jobfolderGlobalTsmV1Chainer) Jobs(name string) *jobGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["jobs.global.tsm.tanzu.vmware.com"] = name
	return &jobGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetJobs calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *jobfolderGlobalTsmV1Chainer) GetJobs(ctx context.Context, displayName string) (result *GlobalJob, err error) {
	hashedName := helper.GetHashedName("jobs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetJobByName(ctx, hashedName)
}

// AddJobs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *jobfolderGlobalTsmV1Chainer) AddJobs(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Job) (result *GlobalJob, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("jobs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateJobByName(ctx, objToCreate)
}

// DeleteJobs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *jobfolderGlobalTsmV1Chainer) DeleteJobs(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("jobs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteJobByName(ctx, hashedName)
}

// GetJobByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetJobByName(ctx context.Context, hashedName string) (*GlobalJob, error) {
	key := "jobs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Job)
		return &GlobalJob{
			client: group.client,
			Job:    result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Jobs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalJob{
			client: group.client,
			Job:    result,
		}, nil
	}
}

// DeleteJobByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteJobByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Jobs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Jobs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/jobsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["jobfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("jobfolders.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		JobFolders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateJobByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateJobByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Job) (*GlobalJob, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Jobs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["jobfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("jobfolders.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"jobsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"Job\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		JobFolders().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalJob{
		client: group.client,
		Job:    result,
	}, nil
}

// UpdateJobByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateJobByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Job) (*GlobalJob, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Jobs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueStatus :=
		objToUpdate.Spec.Status
	patchOpStatus := PatchOp{
		Op:    "replace",
		Path:  "/spec/status",
		Value: patchValueStatus,
	}
	patch = append(patch, patchOpStatus)

	patchValueProjectId :=
		objToUpdate.Spec.ProjectId
	patchOpProjectId := PatchOp{
		Op:    "replace",
		Path:  "/spec/projectId",
		Value: patchValueProjectId,
	}
	patch = append(patch, patchOpProjectId)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Jobs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalJob{
		client: group.client,
		Job:    result,
	}, nil
}

// ListJobs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListJobs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalJob, err error) {
	key := "jobs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalJob, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Job)
			result[k] = &GlobalJob{
				client: group.client,
				Job:    item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Jobs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalJob, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalJob{
				client: group.client,
				Job:    &item,
			}
		}
	}
	return
}

type GlobalJob struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Job
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalJob) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteJobByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Job = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalJob) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateJobByName(ctx, obj.Job)
	if err != nil {
		return err
	}
	obj.Job = result.Job
	return nil
}

func (obj *GlobalJob) GetParent(ctx context.Context) (result *GlobalJobFolder, err error) {
	hashedName := helper.GetHashedName("jobfolders.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["jobfolders.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetJobFolderByName(ctx, hashedName)
}

type jobGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *jobGlobalTsmV1Chainer) Subscribe() {
	key := "jobs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewJobInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *jobGlobalTsmV1Chainer) Unsubscribe() {
	key := "jobs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *jobGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "jobs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetKnativeIngressByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetKnativeIngressByName(ctx context.Context, hashedName string) (*GlobalKnativeIngress, error) {
	key := "knativeingresses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.KnativeIngress)
		return &GlobalKnativeIngress{
			client:         group.client,
			KnativeIngress: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			KnativeIngresses().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalKnativeIngress{
			client:         group.client,
			KnativeIngress: result,
		}, nil
	}
}

// DeleteKnativeIngressByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteKnativeIngressByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		KnativeIngresses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		KnativeIngresses().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/knativeIngressesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateKnativeIngressByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateKnativeIngressByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.KnativeIngress) (*GlobalKnativeIngress, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		KnativeIngresses().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"knativeIngressesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"KnativeIngress\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalKnativeIngress{
		client:         group.client,
		KnativeIngress: result,
	}, nil
}

// UpdateKnativeIngressByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateKnativeIngressByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.KnativeIngress) (*GlobalKnativeIngress, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			KnativeIngresses().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueCreationTimestamp :=
		objToUpdate.Spec.CreationTimestamp
	patchOpCreationTimestamp := PatchOp{
		Op:    "replace",
		Path:  "/spec/creationTimestamp",
		Value: patchValueCreationTimestamp,
	}
	patch = append(patch, patchOpCreationTimestamp)

	patchValueApiLink :=
		objToUpdate.Spec.ApiLink
	patchOpApiLink := PatchOp{
		Op:    "replace",
		Path:  "/spec/apiLink",
		Value: patchValueApiLink,
	}
	patch = append(patch, patchOpApiLink)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueAnnotations :=
		objToUpdate.Spec.Annotations
	patchOpAnnotations := PatchOp{
		Op:    "replace",
		Path:  "/spec/annotations",
		Value: patchValueAnnotations,
	}
	patch = append(patch, patchOpAnnotations)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		KnativeIngresses().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalKnativeIngress{
		client:         group.client,
		KnativeIngress: result,
	}, nil
}

// ListKnativeIngresses returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListKnativeIngresses(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalKnativeIngress, err error) {
	key := "knativeingresses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalKnativeIngress, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.KnativeIngress)
			result[k] = &GlobalKnativeIngress{
				client:         group.client,
				KnativeIngress: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			KnativeIngresses().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalKnativeIngress, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalKnativeIngress{
				client:         group.client,
				KnativeIngress: &item,
			}
		}
	}
	return
}

type GlobalKnativeIngress struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.KnativeIngress
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalKnativeIngress) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteKnativeIngressByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.KnativeIngress = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalKnativeIngress) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateKnativeIngressByName(ctx, obj.KnativeIngress)
	if err != nil {
		return err
	}
	obj.KnativeIngress = result.KnativeIngress
	return nil
}

func (obj *GlobalKnativeIngress) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

type knativeingressGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *knativeingressGlobalTsmV1Chainer) Subscribe() {
	key := "knativeingresses.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewKnativeIngressInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *knativeingressGlobalTsmV1Chainer) Unsubscribe() {
	key := "knativeingresses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *knativeingressGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "knativeingresses.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetLabelConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetLabelConfigByName(ctx context.Context, hashedName string) (*GlobalLabelConfig, error) {
	key := "labelconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.LabelConfig)
		return &GlobalLabelConfig{
			client:      group.client,
			LabelConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			LabelConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalLabelConfig{
			client:      group.client,
			LabelConfig: result,
		}, nil
	}
}

// DeleteLabelConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteLabelConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		LabelConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		LabelConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/labelConfigGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateLabelConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateLabelConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.LabelConfig) (*GlobalLabelConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		LabelConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/labelConfigGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "LabelConfig",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalLabelConfig{
		client:      group.client,
		LabelConfig: result,
	}, nil
}

// UpdateLabelConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateLabelConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.LabelConfig) (*GlobalLabelConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			LabelConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		LabelConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalLabelConfig{
		client:      group.client,
		LabelConfig: result,
	}, nil
}

// ListLabelConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListLabelConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalLabelConfig, err error) {
	key := "labelconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalLabelConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.LabelConfig)
			result[k] = &GlobalLabelConfig{
				client:      group.client,
				LabelConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			LabelConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalLabelConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalLabelConfig{
				client:      group.client,
				LabelConfig: &item,
			}
		}
	}
	return
}

type GlobalLabelConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.LabelConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalLabelConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteLabelConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.LabelConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalLabelConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateLabelConfigByName(ctx, obj.LabelConfig)
	if err != nil {
		return err
	}
	obj.LabelConfig = result.LabelConfig
	return nil
}

func (obj *GlobalLabelConfig) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

type labelconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *labelconfigGlobalTsmV1Chainer) Subscribe() {
	key := "labelconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewLabelConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *labelconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "labelconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *labelconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "labelconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetLocalRegistrationServiceClusterByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetLocalRegistrationServiceClusterByName(ctx context.Context, hashedName string) (*GlobalLocalRegistrationServiceCluster, error) {
	key := "localregistrationserviceclusters.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.LocalRegistrationServiceCluster)
		return &GlobalLocalRegistrationServiceCluster{
			client:                          group.client,
			LocalRegistrationServiceCluster: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			LocalRegistrationServiceClusters().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalLocalRegistrationServiceCluster{
			client:                          group.client,
			LocalRegistrationServiceCluster: result,
		}, nil
	}
}

// DeleteLocalRegistrationServiceClusterByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteLocalRegistrationServiceClusterByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		LocalRegistrationServiceClusters().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.ResourcesGvk {
		err := group.client.
			Global().DeleteLocalRegistrationServiceResourceByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		LocalRegistrationServiceClusters().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/clustersGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["localregistrationservices.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("localregistrationservices.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		LocalRegistrationServices().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateLocalRegistrationServiceClusterByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateLocalRegistrationServiceClusterByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.LocalRegistrationServiceCluster) (*GlobalLocalRegistrationServiceCluster, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ResourcesGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		LocalRegistrationServiceClusters().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["localregistrationservices.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("localregistrationservices.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"clustersGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"LocalRegistrationServiceCluster\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		LocalRegistrationServices().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalLocalRegistrationServiceCluster{
		client:                          group.client,
		LocalRegistrationServiceCluster: result,
	}, nil
}

// UpdateLocalRegistrationServiceClusterByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateLocalRegistrationServiceClusterByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.LocalRegistrationServiceCluster) (*GlobalLocalRegistrationServiceCluster, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			LocalRegistrationServiceClusters().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueTenant :=
		objToUpdate.Spec.Tenant
	patchOpTenant := PatchOp{
		Op:    "replace",
		Path:  "/spec/tenant",
		Value: patchValueTenant,
	}
	patch = append(patch, patchOpTenant)

	patchValueType :=
		objToUpdate.Spec.Type
	patchOpType := PatchOp{
		Op:    "replace",
		Path:  "/spec/type",
		Value: patchValueType,
	}
	patch = append(patch, patchOpType)

	patchValueVersion :=
		objToUpdate.Spec.Version
	patchOpVersion := PatchOp{
		Op:    "replace",
		Path:  "/spec/version",
		Value: patchValueVersion,
	}
	patch = append(patch, patchOpVersion)

	patchValueErrorCount :=
		objToUpdate.Spec.ErrorCount
	patchOpErrorCount := PatchOp{
		Op:    "replace",
		Path:  "/spec/errorCount",
		Value: patchValueErrorCount,
	}
	patch = append(patch, patchOpErrorCount)

	patchValueRestartCount :=
		objToUpdate.Spec.RestartCount
	patchOpRestartCount := PatchOp{
		Op:    "replace",
		Path:  "/spec/restartCount",
		Value: patchValueRestartCount,
	}
	patch = append(patch, patchOpRestartCount)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		LocalRegistrationServiceClusters().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalLocalRegistrationServiceCluster{
		client:                          group.client,
		LocalRegistrationServiceCluster: result,
	}, nil
}

// ListLocalRegistrationServiceClusters returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListLocalRegistrationServiceClusters(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalLocalRegistrationServiceCluster, err error) {
	key := "localregistrationserviceclusters.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalLocalRegistrationServiceCluster, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.LocalRegistrationServiceCluster)
			result[k] = &GlobalLocalRegistrationServiceCluster{
				client:                          group.client,
				LocalRegistrationServiceCluster: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			LocalRegistrationServiceClusters().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalLocalRegistrationServiceCluster, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalLocalRegistrationServiceCluster{
				client:                          group.client,
				LocalRegistrationServiceCluster: &item,
			}
		}
	}
	return
}

type GlobalLocalRegistrationServiceCluster struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.LocalRegistrationServiceCluster
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalLocalRegistrationServiceCluster) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteLocalRegistrationServiceClusterByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.LocalRegistrationServiceCluster = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalLocalRegistrationServiceCluster) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateLocalRegistrationServiceClusterByName(ctx, obj.LocalRegistrationServiceCluster)
	if err != nil {
		return err
	}
	obj.LocalRegistrationServiceCluster = result.LocalRegistrationServiceCluster
	return nil
}

func (obj *GlobalLocalRegistrationServiceCluster) GetParent(ctx context.Context) (result *GlobalLocalRegistrationService, err error) {
	hashedName := helper.GetHashedName("localregistrationservices.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["localregistrationservices.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetLocalRegistrationServiceByName(ctx, hashedName)
}

// GetAllResources returns all children of given type
func (obj *GlobalLocalRegistrationServiceCluster) GetAllResources(ctx context.Context) (
	result []*GlobalLocalRegistrationServiceResource, err error) {
	result = make([]*GlobalLocalRegistrationServiceResource, 0, len(obj.Spec.ResourcesGvk))
	for _, v := range obj.Spec.ResourcesGvk {
		l, err := obj.client.Global().GetLocalRegistrationServiceResourceByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetResources returns child which has given displayName
func (obj *GlobalLocalRegistrationServiceCluster) GetResources(ctx context.Context,
	displayName string) (result *GlobalLocalRegistrationServiceResource, err error) {
	l, ok := obj.Spec.ResourcesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.LocalRegistrationServiceCluster", "Resources", displayName)
	}
	result, err = obj.client.Global().GetLocalRegistrationServiceResourceByName(ctx, l.Name)
	return
}

// AddResources calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalLocalRegistrationServiceCluster) AddResources(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.LocalRegistrationServiceResource) (result *GlobalLocalRegistrationServiceResource, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["localregistrationserviceclusters.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["localregistrationserviceclusters.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateLocalRegistrationServiceResourceByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetLocalRegistrationServiceClusterByName(ctx, obj.GetName())
	if getErr == nil {
		obj.LocalRegistrationServiceCluster = updatedObj.LocalRegistrationServiceCluster
	}
	return
}

// DeleteResources calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalLocalRegistrationServiceCluster) DeleteResources(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ResourcesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.LocalRegistrationServiceCluster", "Resources", displayName)
	}
	err = obj.client.Global().DeleteLocalRegistrationServiceResourceByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetLocalRegistrationServiceClusterByName(ctx, obj.GetName())
	if err == nil {
		obj.LocalRegistrationServiceCluster = updatedObj.LocalRegistrationServiceCluster
	}
	return
}

type localregistrationserviceclusterGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *localregistrationserviceclusterGlobalTsmV1Chainer) Subscribe() {
	key := "localregistrationserviceclusters.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewLocalRegistrationServiceClusterInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *localregistrationserviceclusterGlobalTsmV1Chainer) Unsubscribe() {
	key := "localregistrationserviceclusters.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *localregistrationserviceclusterGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "localregistrationserviceclusters.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *localregistrationserviceclusterGlobalTsmV1Chainer) Resources(name string) *localregistrationserviceresourceGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["localregistrationserviceresources.global.tsm.tanzu.vmware.com"] = name
	return &localregistrationserviceresourceGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetResources calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *localregistrationserviceclusterGlobalTsmV1Chainer) GetResources(ctx context.Context, displayName string) (result *GlobalLocalRegistrationServiceResource, err error) {
	hashedName := helper.GetHashedName("localregistrationserviceresources.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetLocalRegistrationServiceResourceByName(ctx, hashedName)
}

// AddResources calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *localregistrationserviceclusterGlobalTsmV1Chainer) AddResources(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.LocalRegistrationServiceResource) (result *GlobalLocalRegistrationServiceResource, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("localregistrationserviceresources.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateLocalRegistrationServiceResourceByName(ctx, objToCreate)
}

// DeleteResources calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *localregistrationserviceclusterGlobalTsmV1Chainer) DeleteResources(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("localregistrationserviceresources.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteLocalRegistrationServiceResourceByName(ctx, hashedName)
}

// GetLocalRegistrationServiceResourceByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetLocalRegistrationServiceResourceByName(ctx context.Context, hashedName string) (*GlobalLocalRegistrationServiceResource, error) {
	key := "localregistrationserviceresources.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.LocalRegistrationServiceResource)
		return &GlobalLocalRegistrationServiceResource{
			client:                           group.client,
			LocalRegistrationServiceResource: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			LocalRegistrationServiceResources().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalLocalRegistrationServiceResource{
			client:                           group.client,
			LocalRegistrationServiceResource: result,
		}, nil
	}
}

// DeleteLocalRegistrationServiceResourceByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteLocalRegistrationServiceResourceByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		LocalRegistrationServiceResources().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		LocalRegistrationServiceResources().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/resourcesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["localregistrationserviceclusters.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("localregistrationserviceclusters.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		LocalRegistrationServiceClusters().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateLocalRegistrationServiceResourceByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateLocalRegistrationServiceResourceByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.LocalRegistrationServiceResource) (*GlobalLocalRegistrationServiceResource, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		LocalRegistrationServiceResources().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["localregistrationserviceclusters.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("localregistrationserviceclusters.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"resourcesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"LocalRegistrationServiceResource\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		LocalRegistrationServiceClusters().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalLocalRegistrationServiceResource{
		client:                           group.client,
		LocalRegistrationServiceResource: result,
	}, nil
}

// UpdateLocalRegistrationServiceResourceByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateLocalRegistrationServiceResourceByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.LocalRegistrationServiceResource) (*GlobalLocalRegistrationServiceResource, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			LocalRegistrationServiceResources().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueType :=
		objToUpdate.Spec.Type
	patchOpType := PatchOp{
		Op:    "replace",
		Path:  "/spec/type",
		Value: patchValueType,
	}
	patch = append(patch, patchOpType)

	patchValueLocation :=
		objToUpdate.Spec.Location
	patchOpLocation := PatchOp{
		Op:    "replace",
		Path:  "/spec/location",
		Value: patchValueLocation,
	}
	patch = append(patch, patchOpLocation)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		LocalRegistrationServiceResources().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalLocalRegistrationServiceResource{
		client:                           group.client,
		LocalRegistrationServiceResource: result,
	}, nil
}

// ListLocalRegistrationServiceResources returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListLocalRegistrationServiceResources(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalLocalRegistrationServiceResource, err error) {
	key := "localregistrationserviceresources.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalLocalRegistrationServiceResource, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.LocalRegistrationServiceResource)
			result[k] = &GlobalLocalRegistrationServiceResource{
				client:                           group.client,
				LocalRegistrationServiceResource: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			LocalRegistrationServiceResources().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalLocalRegistrationServiceResource, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalLocalRegistrationServiceResource{
				client:                           group.client,
				LocalRegistrationServiceResource: &item,
			}
		}
	}
	return
}

type GlobalLocalRegistrationServiceResource struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.LocalRegistrationServiceResource
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalLocalRegistrationServiceResource) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteLocalRegistrationServiceResourceByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.LocalRegistrationServiceResource = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalLocalRegistrationServiceResource) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateLocalRegistrationServiceResourceByName(ctx, obj.LocalRegistrationServiceResource)
	if err != nil {
		return err
	}
	obj.LocalRegistrationServiceResource = result.LocalRegistrationServiceResource
	return nil
}

func (obj *GlobalLocalRegistrationServiceResource) GetParent(ctx context.Context) (result *GlobalLocalRegistrationServiceCluster, err error) {
	hashedName := helper.GetHashedName("localregistrationserviceclusters.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["localregistrationserviceclusters.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetLocalRegistrationServiceClusterByName(ctx, hashedName)
}

type localregistrationserviceresourceGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *localregistrationserviceresourceGlobalTsmV1Chainer) Subscribe() {
	key := "localregistrationserviceresources.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewLocalRegistrationServiceResourceInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *localregistrationserviceresourceGlobalTsmV1Chainer) Unsubscribe() {
	key := "localregistrationserviceresources.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *localregistrationserviceresourceGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "localregistrationserviceresources.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetLocalRegistrationServiceByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetLocalRegistrationServiceByName(ctx context.Context, hashedName string) (*GlobalLocalRegistrationService, error) {
	key := "localregistrationservices.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.LocalRegistrationService)
		return &GlobalLocalRegistrationService{
			client:                   group.client,
			LocalRegistrationService: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			LocalRegistrationServices().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalLocalRegistrationService{
			client:                   group.client,
			LocalRegistrationService: result,
		}, nil
	}
}

// DeleteLocalRegistrationServiceByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteLocalRegistrationServiceByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		LocalRegistrationServices().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.ClustersGvk {
		err := group.client.
			Global().DeleteLocalRegistrationServiceClusterByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		LocalRegistrationServices().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/localRegistrationServiceGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["allsparkserviceses.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("allsparkserviceses.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		AllSparkServiceses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateLocalRegistrationServiceByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateLocalRegistrationServiceByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.LocalRegistrationService) (*GlobalLocalRegistrationService, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ClustersGvk = nil
	objToCreate.Spec.TemplateGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		LocalRegistrationServices().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["allsparkserviceses.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("allsparkserviceses.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/localRegistrationServiceGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "LocalRegistrationService",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		AllSparkServiceses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalLocalRegistrationService{
		client:                   group.client,
		LocalRegistrationService: result,
	}, nil
}

// UpdateLocalRegistrationServiceByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateLocalRegistrationServiceByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.LocalRegistrationService) (*GlobalLocalRegistrationService, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			LocalRegistrationServices().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueBuildID :=
		objToUpdate.Spec.BuildID
	patchOpBuildID := PatchOp{
		Op:    "replace",
		Path:  "/spec/buildID",
		Value: patchValueBuildID,
	}
	patch = append(patch, patchOpBuildID)

	patchValueVersion :=
		objToUpdate.Spec.Version
	patchOpVersion := PatchOp{
		Op:    "replace",
		Path:  "/spec/version",
		Value: patchValueVersion,
	}
	patch = append(patch, patchOpVersion)

	patchValueErrorCount :=
		objToUpdate.Spec.ErrorCount
	patchOpErrorCount := PatchOp{
		Op:    "replace",
		Path:  "/spec/errorCount",
		Value: patchValueErrorCount,
	}
	patch = append(patch, patchOpErrorCount)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		LocalRegistrationServices().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalLocalRegistrationService{
		client:                   group.client,
		LocalRegistrationService: result,
	}, nil
}

// ListLocalRegistrationServices returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListLocalRegistrationServices(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalLocalRegistrationService, err error) {
	key := "localregistrationservices.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalLocalRegistrationService, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.LocalRegistrationService)
			result[k] = &GlobalLocalRegistrationService{
				client:                   group.client,
				LocalRegistrationService: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			LocalRegistrationServices().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalLocalRegistrationService, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalLocalRegistrationService{
				client:                   group.client,
				LocalRegistrationService: &item,
			}
		}
	}
	return
}

type GlobalLocalRegistrationService struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.LocalRegistrationService
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalLocalRegistrationService) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteLocalRegistrationServiceByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.LocalRegistrationService = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalLocalRegistrationService) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateLocalRegistrationServiceByName(ctx, obj.LocalRegistrationService)
	if err != nil {
		return err
	}
	obj.LocalRegistrationService = result.LocalRegistrationService
	return nil
}

func (obj *GlobalLocalRegistrationService) GetParent(ctx context.Context) (result *GlobalAllSparkServices, err error) {
	hashedName := helper.GetHashedName("allsparkserviceses.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["allsparkserviceses.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetAllSparkServicesByName(ctx, hashedName)
}

// GetAllClusters returns all children of given type
func (obj *GlobalLocalRegistrationService) GetAllClusters(ctx context.Context) (
	result []*GlobalLocalRegistrationServiceCluster, err error) {
	result = make([]*GlobalLocalRegistrationServiceCluster, 0, len(obj.Spec.ClustersGvk))
	for _, v := range obj.Spec.ClustersGvk {
		l, err := obj.client.Global().GetLocalRegistrationServiceClusterByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetClusters returns child which has given displayName
func (obj *GlobalLocalRegistrationService) GetClusters(ctx context.Context,
	displayName string) (result *GlobalLocalRegistrationServiceCluster, err error) {
	l, ok := obj.Spec.ClustersGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.LocalRegistrationService", "Clusters", displayName)
	}
	result, err = obj.client.Global().GetLocalRegistrationServiceClusterByName(ctx, l.Name)
	return
}

// AddClusters calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalLocalRegistrationService) AddClusters(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.LocalRegistrationServiceCluster) (result *GlobalLocalRegistrationServiceCluster, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["localregistrationservices.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["localregistrationservices.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateLocalRegistrationServiceClusterByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetLocalRegistrationServiceByName(ctx, obj.GetName())
	if getErr == nil {
		obj.LocalRegistrationService = updatedObj.LocalRegistrationService
	}
	return
}

// DeleteClusters calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalLocalRegistrationService) DeleteClusters(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ClustersGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.LocalRegistrationService", "Clusters", displayName)
	}
	err = obj.client.Global().DeleteLocalRegistrationServiceClusterByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetLocalRegistrationServiceByName(ctx, obj.GetName())
	if err == nil {
		obj.LocalRegistrationService = updatedObj.LocalRegistrationService
	}
	return
}

// GetTemplate returns link of given type
func (obj *GlobalLocalRegistrationService) GetTemplate(ctx context.Context) (
	result *GlobalServiceTemplate, err error) {
	if obj.Spec.TemplateGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.LocalRegistrationService", "Template")
	}
	return obj.client.Global().GetServiceTemplateByName(ctx, obj.Spec.TemplateGvk.Name)
}

// LinkTemplate links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalLocalRegistrationService) LinkTemplate(ctx context.Context,
	linkToAdd *GlobalServiceTemplate) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/templateGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "ServiceTemplate",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().LocalRegistrationServices().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.LocalRegistrationService = result
	return nil
}

// UnlinkTemplate unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalLocalRegistrationService) UnlinkTemplate(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/templateGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().LocalRegistrationServices().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.LocalRegistrationService = result
	return nil

}

type localregistrationserviceGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *localregistrationserviceGlobalTsmV1Chainer) Subscribe() {
	key := "localregistrationservices.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewLocalRegistrationServiceInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *localregistrationserviceGlobalTsmV1Chainer) Unsubscribe() {
	key := "localregistrationservices.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *localregistrationserviceGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "localregistrationservices.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *localregistrationserviceGlobalTsmV1Chainer) Clusters(name string) *localregistrationserviceclusterGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["localregistrationserviceclusters.global.tsm.tanzu.vmware.com"] = name
	return &localregistrationserviceclusterGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetClusters calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *localregistrationserviceGlobalTsmV1Chainer) GetClusters(ctx context.Context, displayName string) (result *GlobalLocalRegistrationServiceCluster, err error) {
	hashedName := helper.GetHashedName("localregistrationserviceclusters.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetLocalRegistrationServiceClusterByName(ctx, hashedName)
}

// AddClusters calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *localregistrationserviceGlobalTsmV1Chainer) AddClusters(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.LocalRegistrationServiceCluster) (result *GlobalLocalRegistrationServiceCluster, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("localregistrationserviceclusters.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateLocalRegistrationServiceClusterByName(ctx, objToCreate)
}

// DeleteClusters calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *localregistrationserviceGlobalTsmV1Chainer) DeleteClusters(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("localregistrationserviceclusters.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteLocalRegistrationServiceClusterByName(ctx, hashedName)
}

// GetLogFolderByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetLogFolderByName(ctx context.Context, hashedName string) (*GlobalLogFolder, error) {
	key := "logfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.LogFolder)
		return &GlobalLogFolder{
			client:    group.client,
			LogFolder: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			LogFolders().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalLogFolder{
			client:    group.client,
			LogFolder: result,
		}, nil
	}
}

// DeleteLogFolderByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteLogFolderByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		LogFolders().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.LogGvk {
		err := group.client.
			Global().DeleteLogByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		LogFolders().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/logFolderGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["clusterconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateLogFolderByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateLogFolderByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.LogFolder) (*GlobalLogFolder, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.LogGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		LogFolders().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["clusterconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/logFolderGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "LogFolder",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalLogFolder{
		client:    group.client,
		LogFolder: result,
	}, nil
}

// UpdateLogFolderByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateLogFolderByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.LogFolder) (*GlobalLogFolder, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			LogFolders().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		LogFolders().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalLogFolder{
		client:    group.client,
		LogFolder: result,
	}, nil
}

// ListLogFolders returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListLogFolders(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalLogFolder, err error) {
	key := "logfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalLogFolder, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.LogFolder)
			result[k] = &GlobalLogFolder{
				client:    group.client,
				LogFolder: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			LogFolders().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalLogFolder, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalLogFolder{
				client:    group.client,
				LogFolder: &item,
			}
		}
	}
	return
}

type GlobalLogFolder struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.LogFolder
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalLogFolder) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteLogFolderByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.LogFolder = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalLogFolder) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateLogFolderByName(ctx, obj.LogFolder)
	if err != nil {
		return err
	}
	obj.LogFolder = result.LogFolder
	return nil
}

func (obj *GlobalLogFolder) GetParent(ctx context.Context) (result *GlobalClusterConfig, err error) {
	hashedName := helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["clusterconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetClusterConfigByName(ctx, hashedName)
}

// GetAllLog returns all children of given type
func (obj *GlobalLogFolder) GetAllLog(ctx context.Context) (
	result []*GlobalLog, err error) {
	result = make([]*GlobalLog, 0, len(obj.Spec.LogGvk))
	for _, v := range obj.Spec.LogGvk {
		l, err := obj.client.Global().GetLogByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetLog returns child which has given displayName
func (obj *GlobalLogFolder) GetLog(ctx context.Context,
	displayName string) (result *GlobalLog, err error) {
	l, ok := obj.Spec.LogGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.LogFolder", "Log", displayName)
	}
	result, err = obj.client.Global().GetLogByName(ctx, l.Name)
	return
}

// AddLog calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalLogFolder) AddLog(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Log) (result *GlobalLog, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["logfolders.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["logfolders.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateLogByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetLogFolderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.LogFolder = updatedObj.LogFolder
	}
	return
}

// DeleteLog calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalLogFolder) DeleteLog(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.LogGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.LogFolder", "Log", displayName)
	}
	err = obj.client.Global().DeleteLogByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetLogFolderByName(ctx, obj.GetName())
	if err == nil {
		obj.LogFolder = updatedObj.LogFolder
	}
	return
}

type logfolderGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *logfolderGlobalTsmV1Chainer) Subscribe() {
	key := "logfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewLogFolderInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *logfolderGlobalTsmV1Chainer) Unsubscribe() {
	key := "logfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *logfolderGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "logfolders.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *logfolderGlobalTsmV1Chainer) Log(name string) *logGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["logs.global.tsm.tanzu.vmware.com"] = name
	return &logGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetLog calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *logfolderGlobalTsmV1Chainer) GetLog(ctx context.Context, displayName string) (result *GlobalLog, err error) {
	hashedName := helper.GetHashedName("logs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetLogByName(ctx, hashedName)
}

// AddLog calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *logfolderGlobalTsmV1Chainer) AddLog(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Log) (result *GlobalLog, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("logs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateLogByName(ctx, objToCreate)
}

// DeleteLog calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *logfolderGlobalTsmV1Chainer) DeleteLog(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("logs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteLogByName(ctx, hashedName)
}

// GetLogByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetLogByName(ctx context.Context, hashedName string) (*GlobalLog, error) {
	key := "logs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Log)
		return &GlobalLog{
			client: group.client,
			Log:    result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Logs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalLog{
			client: group.client,
			Log:    result,
		}, nil
	}
}

// DeleteLogByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteLogByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Logs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Logs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/logGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["logfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("logfolders.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		LogFolders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateLogByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateLogByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Log) (*GlobalLog, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Logs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["logfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("logfolders.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"logGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"Log\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		LogFolders().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalLog{
		client: group.client,
		Log:    result,
	}, nil
}

// UpdateLogByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateLogByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Log) (*GlobalLog, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Logs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueRequest :=
		objToUpdate.Spec.Request
	patchOpRequest := PatchOp{
		Op:    "replace",
		Path:  "/spec/request",
		Value: patchValueRequest,
	}
	patch = append(patch, patchOpRequest)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Logs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalLog{
		client: group.client,
		Log:    result,
	}, nil
}

// ListLogs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListLogs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalLog, err error) {
	key := "logs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalLog, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Log)
			result[k] = &GlobalLog{
				client: group.client,
				Log:    item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Logs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalLog, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalLog{
				client: group.client,
				Log:    &item,
			}
		}
	}
	return
}

type GlobalLog struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Log
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalLog) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteLogByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Log = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalLog) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateLogByName(ctx, obj.Log)
	if err != nil {
		return err
	}
	obj.Log = result.Log
	return nil
}

func (obj *GlobalLog) GetParent(ctx context.Context) (result *GlobalLogFolder, err error) {
	hashedName := helper.GetHashedName("logfolders.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["logfolders.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetLogFolderByName(ctx, hashedName)
}

type logGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *logGlobalTsmV1Chainer) Subscribe() {
	key := "logs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewLogInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *logGlobalTsmV1Chainer) Unsubscribe() {
	key := "logs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *logGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "logs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetNetworkAttachmentDefinitionConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetNetworkAttachmentDefinitionConfigByName(ctx context.Context, hashedName string) (*GlobalNetworkAttachmentDefinitionConfig, error) {
	key := "networkattachmentdefinitionconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.NetworkAttachmentDefinitionConfig)
		return &GlobalNetworkAttachmentDefinitionConfig{
			client:                            group.client,
			NetworkAttachmentDefinitionConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			NetworkAttachmentDefinitionConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalNetworkAttachmentDefinitionConfig{
			client:                            group.client,
			NetworkAttachmentDefinitionConfig: result,
		}, nil
	}
}

// DeleteNetworkAttachmentDefinitionConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteNetworkAttachmentDefinitionConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		NetworkAttachmentDefinitionConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		NetworkAttachmentDefinitionConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/networkAttachmentDefinitionGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateNetworkAttachmentDefinitionConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateNetworkAttachmentDefinitionConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NetworkAttachmentDefinitionConfig) (*GlobalNetworkAttachmentDefinitionConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		NetworkAttachmentDefinitionConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"networkAttachmentDefinitionGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"NetworkAttachmentDefinitionConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalNetworkAttachmentDefinitionConfig{
		client:                            group.client,
		NetworkAttachmentDefinitionConfig: result,
	}, nil
}

// UpdateNetworkAttachmentDefinitionConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateNetworkAttachmentDefinitionConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.NetworkAttachmentDefinitionConfig) (*GlobalNetworkAttachmentDefinitionConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			NetworkAttachmentDefinitionConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueMetadata :=
		objToUpdate.Spec.Metadata
	patchOpMetadata := PatchOp{
		Op:    "replace",
		Path:  "/spec/metadata",
		Value: patchValueMetadata,
	}
	patch = append(patch, patchOpMetadata)

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueNamespace :=
		objToUpdate.Spec.Namespace
	patchOpNamespace := PatchOp{
		Op:    "replace",
		Path:  "/spec/namespace",
		Value: patchValueNamespace,
	}
	patch = append(patch, patchOpNamespace)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		NetworkAttachmentDefinitionConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalNetworkAttachmentDefinitionConfig{
		client:                            group.client,
		NetworkAttachmentDefinitionConfig: result,
	}, nil
}

// ListNetworkAttachmentDefinitionConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListNetworkAttachmentDefinitionConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalNetworkAttachmentDefinitionConfig, err error) {
	key := "networkattachmentdefinitionconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalNetworkAttachmentDefinitionConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.NetworkAttachmentDefinitionConfig)
			result[k] = &GlobalNetworkAttachmentDefinitionConfig{
				client:                            group.client,
				NetworkAttachmentDefinitionConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			NetworkAttachmentDefinitionConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalNetworkAttachmentDefinitionConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalNetworkAttachmentDefinitionConfig{
				client:                            group.client,
				NetworkAttachmentDefinitionConfig: &item,
			}
		}
	}
	return
}

type GlobalNetworkAttachmentDefinitionConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.NetworkAttachmentDefinitionConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalNetworkAttachmentDefinitionConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteNetworkAttachmentDefinitionConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.NetworkAttachmentDefinitionConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalNetworkAttachmentDefinitionConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateNetworkAttachmentDefinitionConfigByName(ctx, obj.NetworkAttachmentDefinitionConfig)
	if err != nil {
		return err
	}
	obj.NetworkAttachmentDefinitionConfig = result.NetworkAttachmentDefinitionConfig
	return nil
}

func (obj *GlobalNetworkAttachmentDefinitionConfig) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

type networkattachmentdefinitionconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *networkattachmentdefinitionconfigGlobalTsmV1Chainer) Subscribe() {
	key := "networkattachmentdefinitionconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewNetworkAttachmentDefinitionConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *networkattachmentdefinitionconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "networkattachmentdefinitionconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *networkattachmentdefinitionconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "networkattachmentdefinitionconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetNetworkAttachmentDefinitionByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetNetworkAttachmentDefinitionByName(ctx context.Context, hashedName string) (*GlobalNetworkAttachmentDefinition, error) {
	key := "networkattachmentdefinitions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.NetworkAttachmentDefinition)
		return &GlobalNetworkAttachmentDefinition{
			client:                      group.client,
			NetworkAttachmentDefinition: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			NetworkAttachmentDefinitions().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalNetworkAttachmentDefinition{
			client:                      group.client,
			NetworkAttachmentDefinition: result,
		}, nil
	}
}

// DeleteNetworkAttachmentDefinitionByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteNetworkAttachmentDefinitionByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		NetworkAttachmentDefinitions().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		NetworkAttachmentDefinitions().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/networkAttachmentDefinitionGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateNetworkAttachmentDefinitionByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateNetworkAttachmentDefinitionByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NetworkAttachmentDefinition) (*GlobalNetworkAttachmentDefinition, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		NetworkAttachmentDefinitions().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"networkAttachmentDefinitionGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"NetworkAttachmentDefinition\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalNetworkAttachmentDefinition{
		client:                      group.client,
		NetworkAttachmentDefinition: result,
	}, nil
}

// UpdateNetworkAttachmentDefinitionByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateNetworkAttachmentDefinitionByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.NetworkAttachmentDefinition) (*GlobalNetworkAttachmentDefinition, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			NetworkAttachmentDefinitions().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueMetadata :=
		objToUpdate.Spec.Metadata
	patchOpMetadata := PatchOp{
		Op:    "replace",
		Path:  "/spec/metadata",
		Value: patchValueMetadata,
	}
	patch = append(patch, patchOpMetadata)

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueNamespace :=
		objToUpdate.Spec.Namespace
	patchOpNamespace := PatchOp{
		Op:    "replace",
		Path:  "/spec/namespace",
		Value: patchValueNamespace,
	}
	patch = append(patch, patchOpNamespace)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		NetworkAttachmentDefinitions().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalNetworkAttachmentDefinition{
		client:                      group.client,
		NetworkAttachmentDefinition: result,
	}, nil
}

// ListNetworkAttachmentDefinitions returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListNetworkAttachmentDefinitions(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalNetworkAttachmentDefinition, err error) {
	key := "networkattachmentdefinitions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalNetworkAttachmentDefinition, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.NetworkAttachmentDefinition)
			result[k] = &GlobalNetworkAttachmentDefinition{
				client:                      group.client,
				NetworkAttachmentDefinition: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			NetworkAttachmentDefinitions().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalNetworkAttachmentDefinition, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalNetworkAttachmentDefinition{
				client:                      group.client,
				NetworkAttachmentDefinition: &item,
			}
		}
	}
	return
}

type GlobalNetworkAttachmentDefinition struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.NetworkAttachmentDefinition
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalNetworkAttachmentDefinition) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteNetworkAttachmentDefinitionByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.NetworkAttachmentDefinition = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalNetworkAttachmentDefinition) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateNetworkAttachmentDefinitionByName(ctx, obj.NetworkAttachmentDefinition)
	if err != nil {
		return err
	}
	obj.NetworkAttachmentDefinition = result.NetworkAttachmentDefinition
	return nil
}

func (obj *GlobalNetworkAttachmentDefinition) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

type networkattachmentdefinitionGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *networkattachmentdefinitionGlobalTsmV1Chainer) Subscribe() {
	key := "networkattachmentdefinitions.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewNetworkAttachmentDefinitionInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *networkattachmentdefinitionGlobalTsmV1Chainer) Unsubscribe() {
	key := "networkattachmentdefinitions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *networkattachmentdefinitionGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "networkattachmentdefinitions.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetNodeDefinitionByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetNodeDefinitionByName(ctx context.Context, hashedName string) (*GlobalNodeDefinition, error) {
	key := "nodedefinitions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.NodeDefinition)
		return &GlobalNodeDefinition{
			client:         group.client,
			NodeDefinition: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			NodeDefinitions().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalNodeDefinition{
			client:         group.client,
			NodeDefinition: result,
		}, nil
	}
}

// DeleteNodeDefinitionByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteNodeDefinitionByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		NodeDefinitions().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		NodeDefinitions().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/definitionVersionsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["nodetemplates.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("nodetemplates.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		NodeTemplates().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateNodeDefinitionByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateNodeDefinitionByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NodeDefinition) (*GlobalNodeDefinition, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		NodeDefinitions().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["nodetemplates.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("nodetemplates.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"definitionVersionsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"NodeDefinition\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		NodeTemplates().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalNodeDefinition{
		client:         group.client,
		NodeDefinition: result,
	}, nil
}

// UpdateNodeDefinitionByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateNodeDefinitionByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.NodeDefinition) (*GlobalNodeDefinition, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			NodeDefinitions().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueType :=
		objToUpdate.Spec.Type
	patchOpType := PatchOp{
		Op:    "replace",
		Path:  "/spec/type",
		Value: patchValueType,
	}
	patch = append(patch, patchOpType)

	patchValueVersion :=
		objToUpdate.Spec.Version
	patchOpVersion := PatchOp{
		Op:    "replace",
		Path:  "/spec/version",
		Value: patchValueVersion,
	}
	patch = append(patch, patchOpVersion)

	patchValueProvider :=
		objToUpdate.Spec.Provider
	patchOpProvider := PatchOp{
		Op:    "replace",
		Path:  "/spec/provider",
		Value: patchValueProvider,
	}
	patch = append(patch, patchOpProvider)

	patchValueImageInfo :=
		objToUpdate.Spec.ImageInfo
	patchOpImageInfo := PatchOp{
		Op:    "replace",
		Path:  "/spec/imageInfo",
		Value: patchValueImageInfo,
	}
	patch = append(patch, patchOpImageInfo)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		NodeDefinitions().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalNodeDefinition{
		client:         group.client,
		NodeDefinition: result,
	}, nil
}

// ListNodeDefinitions returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListNodeDefinitions(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalNodeDefinition, err error) {
	key := "nodedefinitions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalNodeDefinition, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.NodeDefinition)
			result[k] = &GlobalNodeDefinition{
				client:         group.client,
				NodeDefinition: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			NodeDefinitions().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalNodeDefinition, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalNodeDefinition{
				client:         group.client,
				NodeDefinition: &item,
			}
		}
	}
	return
}

type GlobalNodeDefinition struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.NodeDefinition
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalNodeDefinition) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteNodeDefinitionByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.NodeDefinition = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalNodeDefinition) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateNodeDefinitionByName(ctx, obj.NodeDefinition)
	if err != nil {
		return err
	}
	obj.NodeDefinition = result.NodeDefinition
	return nil
}

func (obj *GlobalNodeDefinition) GetParent(ctx context.Context) (result *GlobalNodeTemplate, err error) {
	hashedName := helper.GetHashedName("nodetemplates.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["nodetemplates.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetNodeTemplateByName(ctx, hashedName)
}

type nodedefinitionGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *nodedefinitionGlobalTsmV1Chainer) Subscribe() {
	key := "nodedefinitions.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewNodeDefinitionInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *nodedefinitionGlobalTsmV1Chainer) Unsubscribe() {
	key := "nodedefinitions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *nodedefinitionGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "nodedefinitions.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetNodeFolderClusterByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetNodeFolderClusterByName(ctx context.Context, hashedName string) (*GlobalNodeFolderCluster, error) {
	key := "nodefolderclusters.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.NodeFolderCluster)
		return &GlobalNodeFolderCluster{
			client:            group.client,
			NodeFolderCluster: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			NodeFolderClusters().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalNodeFolderCluster{
			client:            group.client,
			NodeFolderCluster: result,
		}, nil
	}
}

// DeleteNodeFolderClusterByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteNodeFolderClusterByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		NodeFolderClusters().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		NodeFolderClusters().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/clustersGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["nodefolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("nodefolders.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		NodeFolders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateNodeFolderClusterByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateNodeFolderClusterByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NodeFolderCluster) (*GlobalNodeFolderCluster, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		NodeFolderClusters().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["nodefolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("nodefolders.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"clustersGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"NodeFolderCluster\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		NodeFolders().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalNodeFolderCluster{
		client:            group.client,
		NodeFolderCluster: result,
	}, nil
}

// UpdateNodeFolderClusterByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateNodeFolderClusterByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.NodeFolderCluster) (*GlobalNodeFolderCluster, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			NodeFolderClusters().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		NodeFolderClusters().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalNodeFolderCluster{
		client:            group.client,
		NodeFolderCluster: result,
	}, nil
}

// ListNodeFolderClusters returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListNodeFolderClusters(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalNodeFolderCluster, err error) {
	key := "nodefolderclusters.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalNodeFolderCluster, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.NodeFolderCluster)
			result[k] = &GlobalNodeFolderCluster{
				client:            group.client,
				NodeFolderCluster: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			NodeFolderClusters().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalNodeFolderCluster, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalNodeFolderCluster{
				client:            group.client,
				NodeFolderCluster: &item,
			}
		}
	}
	return
}

type GlobalNodeFolderCluster struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.NodeFolderCluster
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalNodeFolderCluster) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteNodeFolderClusterByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.NodeFolderCluster = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalNodeFolderCluster) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateNodeFolderClusterByName(ctx, obj.NodeFolderCluster)
	if err != nil {
		return err
	}
	obj.NodeFolderCluster = result.NodeFolderCluster
	return nil
}

func (obj *GlobalNodeFolderCluster) GetParent(ctx context.Context) (result *GlobalNodeFolder, err error) {
	hashedName := helper.GetHashedName("nodefolders.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["nodefolders.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetNodeFolderByName(ctx, hashedName)
}

type nodefolderclusterGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *nodefolderclusterGlobalTsmV1Chainer) Subscribe() {
	key := "nodefolderclusters.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewNodeFolderClusterInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *nodefolderclusterGlobalTsmV1Chainer) Unsubscribe() {
	key := "nodefolderclusters.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *nodefolderclusterGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "nodefolderclusters.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetNodeFolderByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetNodeFolderByName(ctx context.Context, hashedName string) (*GlobalNodeFolder, error) {
	key := "nodefolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.NodeFolder)
		return &GlobalNodeFolder{
			client:     group.client,
			NodeFolder: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			NodeFolders().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalNodeFolder{
			client:     group.client,
			NodeFolder: result,
		}, nil
	}
}

// DeleteNodeFolderByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteNodeFolderByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		NodeFolders().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.ClustersGvk {
		err := group.client.
			Global().DeleteNodeFolderClusterByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		NodeFolders().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/nodeFolderGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["runtimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateNodeFolderByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateNodeFolderByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NodeFolder) (*GlobalNodeFolder, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.ClustersGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		NodeFolders().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["runtimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/nodeFolderGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "NodeFolder",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalNodeFolder{
		client:     group.client,
		NodeFolder: result,
	}, nil
}

// UpdateNodeFolderByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateNodeFolderByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.NodeFolder) (*GlobalNodeFolder, error) {
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			NodeFolders().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		NodeFolders().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalNodeFolder{
		client:     group.client,
		NodeFolder: result,
	}, nil
}

// ListNodeFolders returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListNodeFolders(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalNodeFolder, err error) {
	key := "nodefolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalNodeFolder, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.NodeFolder)
			result[k] = &GlobalNodeFolder{
				client:     group.client,
				NodeFolder: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			NodeFolders().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalNodeFolder, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalNodeFolder{
				client:     group.client,
				NodeFolder: &item,
			}
		}
	}
	return
}

type GlobalNodeFolder struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.NodeFolder
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalNodeFolder) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteNodeFolderByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.NodeFolder = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalNodeFolder) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateNodeFolderByName(ctx, obj.NodeFolder)
	if err != nil {
		return err
	}
	obj.NodeFolder = result.NodeFolder
	return nil
}

func (obj *GlobalNodeFolder) GetParent(ctx context.Context) (result *GlobalRuntime, err error) {
	hashedName := helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["runtimes.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetRuntimeByName(ctx, hashedName)
}

// GetAllClusters returns all children of given type
func (obj *GlobalNodeFolder) GetAllClusters(ctx context.Context) (
	result []*GlobalNodeFolderCluster, err error) {
	result = make([]*GlobalNodeFolderCluster, 0, len(obj.Spec.ClustersGvk))
	for _, v := range obj.Spec.ClustersGvk {
		l, err := obj.client.Global().GetNodeFolderClusterByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetClusters returns child which has given displayName
func (obj *GlobalNodeFolder) GetClusters(ctx context.Context,
	displayName string) (result *GlobalNodeFolderCluster, err error) {
	l, ok := obj.Spec.ClustersGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.NodeFolder", "Clusters", displayName)
	}
	result, err = obj.client.Global().GetNodeFolderClusterByName(ctx, l.Name)
	return
}

// AddClusters calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalNodeFolder) AddClusters(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NodeFolderCluster) (result *GlobalNodeFolderCluster, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["nodefolders.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["nodefolders.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateNodeFolderClusterByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetNodeFolderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.NodeFolder = updatedObj.NodeFolder
	}
	return
}

// DeleteClusters calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalNodeFolder) DeleteClusters(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ClustersGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.NodeFolder", "Clusters", displayName)
	}
	err = obj.client.Global().DeleteNodeFolderClusterByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetNodeFolderByName(ctx, obj.GetName())
	if err == nil {
		obj.NodeFolder = updatedObj.NodeFolder
	}
	return
}

type nodefolderGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *nodefolderGlobalTsmV1Chainer) Subscribe() {
	key := "nodefolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewNodeFolderInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *nodefolderGlobalTsmV1Chainer) Unsubscribe() {
	key := "nodefolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *nodefolderGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "nodefolders.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *nodefolderGlobalTsmV1Chainer) Clusters(name string) *nodefolderclusterGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["nodefolderclusters.global.tsm.tanzu.vmware.com"] = name
	return &nodefolderclusterGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetClusters calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *nodefolderGlobalTsmV1Chainer) GetClusters(ctx context.Context, displayName string) (result *GlobalNodeFolderCluster, err error) {
	hashedName := helper.GetHashedName("nodefolderclusters.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetNodeFolderClusterByName(ctx, hashedName)
}

// AddClusters calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *nodefolderGlobalTsmV1Chainer) AddClusters(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NodeFolderCluster) (result *GlobalNodeFolderCluster, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("nodefolderclusters.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateNodeFolderClusterByName(ctx, objToCreate)
}

// DeleteClusters calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *nodefolderGlobalTsmV1Chainer) DeleteClusters(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("nodefolderclusters.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteNodeFolderClusterByName(ctx, hashedName)
}

// GetNodeGroupByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetNodeGroupByName(ctx context.Context, hashedName string) (*GlobalNodeGroup, error) {
	key := "nodegroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.NodeGroup)
		return &GlobalNodeGroup{
			client:    group.client,
			NodeGroup: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			NodeGroups().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalNodeGroup{
			client:    group.client,
			NodeGroup: result,
		}, nil
	}
}

// DeleteNodeGroupByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteNodeGroupByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		NodeGroups().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		NodeGroups().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/nodeGroupsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["resourcegroups.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("resourcegroups.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ResourceGroups().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateNodeGroupByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateNodeGroupByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NodeGroup) (*GlobalNodeGroup, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		NodeGroups().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["resourcegroups.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("resourcegroups.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"nodeGroupsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"NodeGroup\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ResourceGroups().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalNodeGroup{
		client:    group.client,
		NodeGroup: result,
	}, nil
}

// UpdateNodeGroupByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateNodeGroupByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.NodeGroup) (*GlobalNodeGroup, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			NodeGroups().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDisplayName :=
		objToUpdate.Spec.DisplayName
	patchOpDisplayName := PatchOp{
		Op:    "replace",
		Path:  "/spec/displayName",
		Value: patchValueDisplayName,
	}
	patch = append(patch, patchOpDisplayName)

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueScope :=
		objToUpdate.Spec.Scope
	patchOpScope := PatchOp{
		Op:    "replace",
		Path:  "/spec/scope",
		Value: patchValueScope,
	}
	patch = append(patch, patchOpScope)

	patchValueColor :=
		objToUpdate.Spec.Color
	patchOpColor := PatchOp{
		Op:    "replace",
		Path:  "/spec/color",
		Value: patchValueColor,
	}
	patch = append(patch, patchOpColor)

	patchValueRules :=
		objToUpdate.Spec.Rules
	patchOpRules := PatchOp{
		Op:    "replace",
		Path:  "/spec/rules",
		Value: patchValueRules,
	}
	patch = append(patch, patchOpRules)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		NodeGroups().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalNodeGroup{
		client:    group.client,
		NodeGroup: result,
	}, nil
}

// ListNodeGroups returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListNodeGroups(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalNodeGroup, err error) {
	key := "nodegroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalNodeGroup, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.NodeGroup)
			result[k] = &GlobalNodeGroup{
				client:    group.client,
				NodeGroup: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			NodeGroups().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalNodeGroup, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalNodeGroup{
				client:    group.client,
				NodeGroup: &item,
			}
		}
	}
	return
}

type GlobalNodeGroup struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.NodeGroup
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalNodeGroup) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteNodeGroupByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.NodeGroup = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalNodeGroup) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateNodeGroupByName(ctx, obj.NodeGroup)
	if err != nil {
		return err
	}
	obj.NodeGroup = result.NodeGroup
	return nil
}

func (obj *GlobalNodeGroup) GetParent(ctx context.Context) (result *GlobalResourceGroup, err error) {
	hashedName := helper.GetHashedName("resourcegroups.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["resourcegroups.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetResourceGroupByName(ctx, hashedName)
}

type nodegroupGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *nodegroupGlobalTsmV1Chainer) Subscribe() {
	key := "nodegroups.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewNodeGroupInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *nodegroupGlobalTsmV1Chainer) Unsubscribe() {
	key := "nodegroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *nodegroupGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "nodegroups.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetNodeStatusByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetNodeStatusByName(ctx context.Context, hashedName string) (*GlobalNodeStatus, error) {
	key := "nodestatuses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.NodeStatus)
		return &GlobalNodeStatus{
			client:     group.client,
			NodeStatus: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			NodeStatuses().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalNodeStatus{
			client:     group.client,
			NodeStatus: result,
		}, nil
	}
}

// DeleteNodeStatusByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteNodeStatusByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		NodeStatuses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		NodeStatuses().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/statusGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["nodes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("nodes.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Nodes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateNodeStatusByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateNodeStatusByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NodeStatus) (*GlobalNodeStatus, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		NodeStatuses().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["nodes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("nodes.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/statusGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "NodeStatus",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Nodes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalNodeStatus{
		client:     group.client,
		NodeStatus: result,
	}, nil
}

// UpdateNodeStatusByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateNodeStatusByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.NodeStatus) (*GlobalNodeStatus, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			NodeStatuses().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueAddresses :=
		objToUpdate.Spec.Addresses
	patchOpAddresses := PatchOp{
		Op:    "replace",
		Path:  "/spec/addresses",
		Value: patchValueAddresses,
	}
	patch = append(patch, patchOpAddresses)

	patchValueAllocatable :=
		objToUpdate.Spec.Allocatable
	patchOpAllocatable := PatchOp{
		Op:    "replace",
		Path:  "/spec/allocatable",
		Value: patchValueAllocatable,
	}
	patch = append(patch, patchOpAllocatable)

	patchValueCapacity :=
		objToUpdate.Spec.Capacity
	patchOpCapacity := PatchOp{
		Op:    "replace",
		Path:  "/spec/capacity",
		Value: patchValueCapacity,
	}
	patch = append(patch, patchOpCapacity)

	patchValueDaemonEndpoints :=
		objToUpdate.Spec.DaemonEndpoints
	patchOpDaemonEndpoints := PatchOp{
		Op:    "replace",
		Path:  "/spec/daemonEndpoints",
		Value: patchValueDaemonEndpoints,
	}
	patch = append(patch, patchOpDaemonEndpoints)

	patchValueConditions :=
		objToUpdate.Spec.Conditions
	patchOpConditions := PatchOp{
		Op:    "replace",
		Path:  "/spec/conditions",
		Value: patchValueConditions,
	}
	patch = append(patch, patchOpConditions)

	patchValueImages :=
		objToUpdate.Spec.Images
	patchOpImages := PatchOp{
		Op:    "replace",
		Path:  "/spec/images",
		Value: patchValueImages,
	}
	patch = append(patch, patchOpImages)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		NodeStatuses().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalNodeStatus{
		client:     group.client,
		NodeStatus: result,
	}, nil
}

// ListNodeStatuses returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListNodeStatuses(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalNodeStatus, err error) {
	key := "nodestatuses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalNodeStatus, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.NodeStatus)
			result[k] = &GlobalNodeStatus{
				client:     group.client,
				NodeStatus: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			NodeStatuses().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalNodeStatus, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalNodeStatus{
				client:     group.client,
				NodeStatus: &item,
			}
		}
	}
	return
}

type GlobalNodeStatus struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.NodeStatus
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalNodeStatus) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteNodeStatusByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.NodeStatus = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalNodeStatus) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateNodeStatusByName(ctx, obj.NodeStatus)
	if err != nil {
		return err
	}
	obj.NodeStatus = result.NodeStatus
	return nil
}

func (obj *GlobalNodeStatus) GetParent(ctx context.Context) (result *GlobalNode, err error) {
	hashedName := helper.GetHashedName("nodes.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["nodes.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetNodeByName(ctx, hashedName)
}

type nodestatusGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *nodestatusGlobalTsmV1Chainer) Subscribe() {
	key := "nodestatuses.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewNodeStatusInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *nodestatusGlobalTsmV1Chainer) Unsubscribe() {
	key := "nodestatuses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *nodestatusGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "nodestatuses.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetNodeTemplateByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetNodeTemplateByName(ctx context.Context, hashedName string) (*GlobalNodeTemplate, error) {
	key := "nodetemplates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.NodeTemplate)
		return &GlobalNodeTemplate{
			client:       group.client,
			NodeTemplate: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			NodeTemplates().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalNodeTemplate{
			client:       group.client,
			NodeTemplate: result,
		}, nil
	}
}

// DeleteNodeTemplateByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteNodeTemplateByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		NodeTemplates().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.DefinitionVersionsGvk {
		err := group.client.
			Global().DeleteNodeDefinitionByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		NodeTemplates().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/nodeTemplatesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["templategroups.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("templategroups.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		TemplateGroups().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateNodeTemplateByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateNodeTemplateByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NodeTemplate) (*GlobalNodeTemplate, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.DefinitionVersionsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		NodeTemplates().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["templategroups.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("templategroups.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"nodeTemplatesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"NodeTemplate\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		TemplateGroups().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalNodeTemplate{
		client:       group.client,
		NodeTemplate: result,
	}, nil
}

// UpdateNodeTemplateByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateNodeTemplateByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.NodeTemplate) (*GlobalNodeTemplate, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			NodeTemplates().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		NodeTemplates().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalNodeTemplate{
		client:       group.client,
		NodeTemplate: result,
	}, nil
}

// ListNodeTemplates returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListNodeTemplates(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalNodeTemplate, err error) {
	key := "nodetemplates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalNodeTemplate, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.NodeTemplate)
			result[k] = &GlobalNodeTemplate{
				client:       group.client,
				NodeTemplate: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			NodeTemplates().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalNodeTemplate, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalNodeTemplate{
				client:       group.client,
				NodeTemplate: &item,
			}
		}
	}
	return
}

type GlobalNodeTemplate struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.NodeTemplate
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalNodeTemplate) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteNodeTemplateByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.NodeTemplate = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalNodeTemplate) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateNodeTemplateByName(ctx, obj.NodeTemplate)
	if err != nil {
		return err
	}
	obj.NodeTemplate = result.NodeTemplate
	return nil
}

func (obj *GlobalNodeTemplate) GetParent(ctx context.Context) (result *GlobalTemplateGroup, err error) {
	hashedName := helper.GetHashedName("templategroups.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["templategroups.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetTemplateGroupByName(ctx, hashedName)
}

// GetAllDefinitionVersions returns all children of given type
func (obj *GlobalNodeTemplate) GetAllDefinitionVersions(ctx context.Context) (
	result []*GlobalNodeDefinition, err error) {
	result = make([]*GlobalNodeDefinition, 0, len(obj.Spec.DefinitionVersionsGvk))
	for _, v := range obj.Spec.DefinitionVersionsGvk {
		l, err := obj.client.Global().GetNodeDefinitionByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetDefinitionVersions returns child which has given displayName
func (obj *GlobalNodeTemplate) GetDefinitionVersions(ctx context.Context,
	displayName string) (result *GlobalNodeDefinition, err error) {
	l, ok := obj.Spec.DefinitionVersionsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.NodeTemplate", "DefinitionVersions", displayName)
	}
	result, err = obj.client.Global().GetNodeDefinitionByName(ctx, l.Name)
	return
}

// AddDefinitionVersions calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalNodeTemplate) AddDefinitionVersions(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NodeDefinition) (result *GlobalNodeDefinition, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["nodetemplates.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["nodetemplates.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateNodeDefinitionByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetNodeTemplateByName(ctx, obj.GetName())
	if getErr == nil {
		obj.NodeTemplate = updatedObj.NodeTemplate
	}
	return
}

// DeleteDefinitionVersions calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalNodeTemplate) DeleteDefinitionVersions(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.DefinitionVersionsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.NodeTemplate", "DefinitionVersions", displayName)
	}
	err = obj.client.Global().DeleteNodeDefinitionByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetNodeTemplateByName(ctx, obj.GetName())
	if err == nil {
		obj.NodeTemplate = updatedObj.NodeTemplate
	}
	return
}

type nodetemplateGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *nodetemplateGlobalTsmV1Chainer) Subscribe() {
	key := "nodetemplates.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewNodeTemplateInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *nodetemplateGlobalTsmV1Chainer) Unsubscribe() {
	key := "nodetemplates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *nodetemplateGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "nodetemplates.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *nodetemplateGlobalTsmV1Chainer) DefinitionVersions(name string) *nodedefinitionGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["nodedefinitions.global.tsm.tanzu.vmware.com"] = name
	return &nodedefinitionGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetDefinitionVersions calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *nodetemplateGlobalTsmV1Chainer) GetDefinitionVersions(ctx context.Context, displayName string) (result *GlobalNodeDefinition, err error) {
	hashedName := helper.GetHashedName("nodedefinitions.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetNodeDefinitionByName(ctx, hashedName)
}

// AddDefinitionVersions calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *nodetemplateGlobalTsmV1Chainer) AddDefinitionVersions(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NodeDefinition) (result *GlobalNodeDefinition, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("nodedefinitions.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateNodeDefinitionByName(ctx, objToCreate)
}

// DeleteDefinitionVersions calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *nodetemplateGlobalTsmV1Chainer) DeleteDefinitionVersions(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("nodedefinitions.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteNodeDefinitionByName(ctx, hashedName)
}

// GetNodeByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetNodeByName(ctx context.Context, hashedName string) (*GlobalNode, error) {
	key := "nodes.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Node)
		return &GlobalNode{
			client: group.client,
			Node:   result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Nodes().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalNode{
			client: group.client,
			Node:   result,
		}, nil
	}
}

// DeleteNodeByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteNodeByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Nodes().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.StatusGvk != nil {
		err := group.client.
			Global().
			DeleteNodeStatusByName(ctx, result.Spec.StatusGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Nodes().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/nodesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["clusters.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusters.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Clusters().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateNodeByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateNodeByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Node) (*GlobalNode, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.StatusGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Nodes().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["clusters.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusters.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"nodesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"Node\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Clusters().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalNode{
		client: group.client,
		Node:   result,
	}, nil
}

// UpdateNodeByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateNodeByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Node) (*GlobalNode, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Nodes().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueExternalID :=
		objToUpdate.Spec.ExternalID
	patchOpExternalID := PatchOp{
		Op:    "replace",
		Path:  "/spec/externalID",
		Value: patchValueExternalID,
	}
	patch = append(patch, patchOpExternalID)

	patchValueProviderID :=
		objToUpdate.Spec.ProviderID
	patchOpProviderID := PatchOp{
		Op:    "replace",
		Path:  "/spec/providerID",
		Value: patchValueProviderID,
	}
	patch = append(patch, patchOpProviderID)

	patchValueArchitecture :=
		objToUpdate.Spec.Architecture
	patchOpArchitecture := PatchOp{
		Op:    "replace",
		Path:  "/spec/architecture",
		Value: patchValueArchitecture,
	}
	patch = append(patch, patchOpArchitecture)

	patchValueContainerRuntimeVersion :=
		objToUpdate.Spec.ContainerRuntimeVersion
	patchOpContainerRuntimeVersion := PatchOp{
		Op:    "replace",
		Path:  "/spec/containerRuntimeVersion",
		Value: patchValueContainerRuntimeVersion,
	}
	patch = append(patch, patchOpContainerRuntimeVersion)

	patchValueKernelVersion :=
		objToUpdate.Spec.KernelVersion
	patchOpKernelVersion := PatchOp{
		Op:    "replace",
		Path:  "/spec/kernelVersion",
		Value: patchValueKernelVersion,
	}
	patch = append(patch, patchOpKernelVersion)

	patchValueOperatingSystem :=
		objToUpdate.Spec.OperatingSystem
	patchOpOperatingSystem := PatchOp{
		Op:    "replace",
		Path:  "/spec/operatingSystem",
		Value: patchValueOperatingSystem,
	}
	patch = append(patch, patchOpOperatingSystem)

	patchValueOsImage :=
		objToUpdate.Spec.OsImage
	patchOpOsImage := PatchOp{
		Op:    "replace",
		Path:  "/spec/osImage",
		Value: patchValueOsImage,
	}
	patch = append(patch, patchOpOsImage)

	patchValueSystemUUID :=
		objToUpdate.Spec.SystemUUID
	patchOpSystemUUID := PatchOp{
		Op:    "replace",
		Path:  "/spec/systemUUID",
		Value: patchValueSystemUUID,
	}
	patch = append(patch, patchOpSystemUUID)

	patchValueHostName :=
		objToUpdate.Spec.HostName
	patchOpHostName := PatchOp{
		Op:    "replace",
		Path:  "/spec/hostName",
		Value: patchValueHostName,
	}
	patch = append(patch, patchOpHostName)

	patchValueApiLink :=
		objToUpdate.Spec.ApiLink
	patchOpApiLink := PatchOp{
		Op:    "replace",
		Path:  "/spec/apiLink",
		Value: patchValueApiLink,
	}
	patch = append(patch, patchOpApiLink)

	patchValueBootID :=
		objToUpdate.Spec.BootID
	patchOpBootID := PatchOp{
		Op:    "replace",
		Path:  "/spec/bootID",
		Value: patchValueBootID,
	}
	patch = append(patch, patchOpBootID)

	patchValueKubeletVersion :=
		objToUpdate.Spec.KubeletVersion
	patchOpKubeletVersion := PatchOp{
		Op:    "replace",
		Path:  "/spec/kubeletVersion",
		Value: patchValueKubeletVersion,
	}
	patch = append(patch, patchOpKubeletVersion)

	patchValueMachineID :=
		objToUpdate.Spec.MachineID
	patchOpMachineID := PatchOp{
		Op:    "replace",
		Path:  "/spec/machineID",
		Value: patchValueMachineID,
	}
	patch = append(patch, patchOpMachineID)

	patchValueCreationTimestamp :=
		objToUpdate.Spec.CreationTimestamp
	patchOpCreationTimestamp := PatchOp{
		Op:    "replace",
		Path:  "/spec/creationTimestamp",
		Value: patchValueCreationTimestamp,
	}
	patch = append(patch, patchOpCreationTimestamp)

	patchValueAnnotations :=
		objToUpdate.Spec.Annotations
	patchOpAnnotations := PatchOp{
		Op:    "replace",
		Path:  "/spec/annotations",
		Value: patchValueAnnotations,
	}
	patch = append(patch, patchOpAnnotations)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueUid :=
		objToUpdate.Spec.Uid
	patchOpUid := PatchOp{
		Op:    "replace",
		Path:  "/spec/uid",
		Value: patchValueUid,
	}
	patch = append(patch, patchOpUid)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	patchValueKStatus :=
		objToUpdate.Spec.KStatus
	patchOpKStatus := PatchOp{
		Op:    "replace",
		Path:  "/spec/kStatus",
		Value: patchValueKStatus,
	}
	patch = append(patch, patchOpKStatus)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Nodes().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalNode{
		client: group.client,
		Node:   result,
	}, nil
}

// ListNodes returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListNodes(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalNode, err error) {
	key := "nodes.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalNode, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Node)
			result[k] = &GlobalNode{
				client: group.client,
				Node:   item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Nodes().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalNode, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalNode{
				client: group.client,
				Node:   &item,
			}
		}
	}
	return
}

type GlobalNode struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Node
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalNode) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteNodeByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Node = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalNode) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateNodeByName(ctx, obj.Node)
	if err != nil {
		return err
	}
	obj.Node = result.Node
	return nil
}

func (obj *GlobalNode) GetParent(ctx context.Context) (result *GlobalCluster, err error) {
	hashedName := helper.GetHashedName("clusters.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["clusters.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetClusterByName(ctx, hashedName)
}

// GetStatus returns child of given type
func (obj *GlobalNode) GetStatus(ctx context.Context) (
	result *GlobalNodeStatus, err error) {
	if obj.Spec.StatusGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Node", "Status")
	}
	return obj.client.Global().GetNodeStatusByName(ctx, obj.Spec.StatusGvk.Name)
}

// AddStatus calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalNode) AddStatus(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NodeStatus) (result *GlobalNodeStatus, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["nodes.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["nodes.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateNodeStatusByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetNodeByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Node = updatedObj.Node
	}
	return
}

// DeleteStatus calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalNode) DeleteStatus(ctx context.Context) (err error) {
	if obj.Spec.StatusGvk != nil {
		err = obj.client.
			Global().DeleteNodeStatusByName(ctx, obj.Spec.StatusGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetNodeByName(ctx, obj.GetName())
	if err == nil {
		obj.Node = updatedObj.Node
	}
	return
}

type nodeGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *nodeGlobalTsmV1Chainer) Subscribe() {
	key := "nodes.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewNodeInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *nodeGlobalTsmV1Chainer) Unsubscribe() {
	key := "nodes.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *nodeGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "nodes.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *nodeGlobalTsmV1Chainer) Status(name string) *nodestatusGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["nodestatuses.global.tsm.tanzu.vmware.com"] = name
	return &nodestatusGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetStatus calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *nodeGlobalTsmV1Chainer) GetStatus(ctx context.Context, displayName string) (result *GlobalNodeStatus, err error) {
	hashedName := helper.GetHashedName("nodestatuses.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetNodeStatusByName(ctx, hashedName)
}

// AddStatus calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *nodeGlobalTsmV1Chainer) AddStatus(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NodeStatus) (result *GlobalNodeStatus, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("nodestatuses.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateNodeStatusByName(ctx, objToCreate)
}

// DeleteStatus calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *nodeGlobalTsmV1Chainer) DeleteStatus(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("nodestatuses.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteNodeStatusByName(ctx, hashedName)
}

// GetOutboundAuthenticationModeByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetOutboundAuthenticationModeByName(ctx context.Context, hashedName string) (*GlobalOutboundAuthenticationMode, error) {
	key := "outboundauthenticationmodes.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.OutboundAuthenticationMode)
		return &GlobalOutboundAuthenticationMode{
			client:                     group.client,
			OutboundAuthenticationMode: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			OutboundAuthenticationModes().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalOutboundAuthenticationMode{
			client:                     group.client,
			OutboundAuthenticationMode: result,
		}, nil
	}
}

// DeleteOutboundAuthenticationModeByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteOutboundAuthenticationModeByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		OutboundAuthenticationModes().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		OutboundAuthenticationModes().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/outboundAuthenticationModeGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["hostconfigv2s.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("hostconfigv2s.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		HostConfigV2s().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateOutboundAuthenticationModeByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateOutboundAuthenticationModeByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.OutboundAuthenticationMode) (*GlobalOutboundAuthenticationMode, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		OutboundAuthenticationModes().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["hostconfigv2s.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("hostconfigv2s.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/outboundAuthenticationModeGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "OutboundAuthenticationMode",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		HostConfigV2s().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalOutboundAuthenticationMode{
		client:                     group.client,
		OutboundAuthenticationMode: result,
	}, nil
}

// UpdateOutboundAuthenticationModeByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateOutboundAuthenticationModeByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.OutboundAuthenticationMode) (*GlobalOutboundAuthenticationMode, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			OutboundAuthenticationModes().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueMode :=
		objToUpdate.Spec.Mode
	patchOpMode := PatchOp{
		Op:    "replace",
		Path:  "/spec/mode",
		Value: patchValueMode,
	}
	patch = append(patch, patchOpMode)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		OutboundAuthenticationModes().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalOutboundAuthenticationMode{
		client:                     group.client,
		OutboundAuthenticationMode: result,
	}, nil
}

// ListOutboundAuthenticationModes returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListOutboundAuthenticationModes(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalOutboundAuthenticationMode, err error) {
	key := "outboundauthenticationmodes.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalOutboundAuthenticationMode, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.OutboundAuthenticationMode)
			result[k] = &GlobalOutboundAuthenticationMode{
				client:                     group.client,
				OutboundAuthenticationMode: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			OutboundAuthenticationModes().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalOutboundAuthenticationMode, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalOutboundAuthenticationMode{
				client:                     group.client,
				OutboundAuthenticationMode: &item,
			}
		}
	}
	return
}

type GlobalOutboundAuthenticationMode struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.OutboundAuthenticationMode
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalOutboundAuthenticationMode) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteOutboundAuthenticationModeByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.OutboundAuthenticationMode = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalOutboundAuthenticationMode) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateOutboundAuthenticationModeByName(ctx, obj.OutboundAuthenticationMode)
	if err != nil {
		return err
	}
	obj.OutboundAuthenticationMode = result.OutboundAuthenticationMode
	return nil
}

func (obj *GlobalOutboundAuthenticationMode) GetParent(ctx context.Context) (result *GlobalHostConfigV2, err error) {
	hashedName := helper.GetHashedName("hostconfigv2s.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["hostconfigv2s.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetHostConfigV2ByName(ctx, hashedName)
}

type outboundauthenticationmodeGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *outboundauthenticationmodeGlobalTsmV1Chainer) Subscribe() {
	key := "outboundauthenticationmodes.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewOutboundAuthenticationModeInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *outboundauthenticationmodeGlobalTsmV1Chainer) Unsubscribe() {
	key := "outboundauthenticationmodes.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *outboundauthenticationmodeGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "outboundauthenticationmodes.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetPeerAuthenticationByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetPeerAuthenticationByName(ctx context.Context, hashedName string) (*GlobalPeerAuthentication, error) {
	key := "peerauthentications.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.PeerAuthentication)
		return &GlobalPeerAuthentication{
			client:             group.client,
			PeerAuthentication: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			PeerAuthentications().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalPeerAuthentication{
			client:             group.client,
			PeerAuthentication: result,
		}, nil
	}
}

// DeletePeerAuthenticationByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeletePeerAuthenticationByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		PeerAuthentications().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		PeerAuthentications().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/peerAuthenticationGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreatePeerAuthenticationByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreatePeerAuthenticationByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PeerAuthentication) (*GlobalPeerAuthentication, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		PeerAuthentications().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"peerAuthenticationGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"PeerAuthentication\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalPeerAuthentication{
		client:             group.client,
		PeerAuthentication: result,
	}, nil
}

// UpdatePeerAuthenticationByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdatePeerAuthenticationByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.PeerAuthentication) (*GlobalPeerAuthentication, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			PeerAuthentications().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueAnnotations :=
		objToUpdate.Spec.Annotations
	patchOpAnnotations := PatchOp{
		Op:    "replace",
		Path:  "/spec/annotations",
		Value: patchValueAnnotations,
	}
	patch = append(patch, patchOpAnnotations)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		PeerAuthentications().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalPeerAuthentication{
		client:             group.client,
		PeerAuthentication: result,
	}, nil
}

// ListPeerAuthentications returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListPeerAuthentications(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalPeerAuthentication, err error) {
	key := "peerauthentications.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalPeerAuthentication, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.PeerAuthentication)
			result[k] = &GlobalPeerAuthentication{
				client:             group.client,
				PeerAuthentication: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			PeerAuthentications().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalPeerAuthentication, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalPeerAuthentication{
				client:             group.client,
				PeerAuthentication: &item,
			}
		}
	}
	return
}

type GlobalPeerAuthentication struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.PeerAuthentication
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalPeerAuthentication) Delete(ctx context.Context) error {
	err := obj.client.Global().DeletePeerAuthenticationByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.PeerAuthentication = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalPeerAuthentication) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdatePeerAuthenticationByName(ctx, obj.PeerAuthentication)
	if err != nil {
		return err
	}
	obj.PeerAuthentication = result.PeerAuthentication
	return nil
}

func (obj *GlobalPeerAuthentication) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

type peerauthenticationGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *peerauthenticationGlobalTsmV1Chainer) Subscribe() {
	key := "peerauthentications.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewPeerAuthenticationInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *peerauthenticationGlobalTsmV1Chainer) Unsubscribe() {
	key := "peerauthentications.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *peerauthenticationGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "peerauthentications.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetPiiDiscoveryRTByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetPiiDiscoveryRTByName(ctx context.Context, hashedName string) (*GlobalPiiDiscoveryRT, error) {
	key := "piidiscoveryrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.PiiDiscoveryRT)
		return &GlobalPiiDiscoveryRT{
			client:         group.client,
			PiiDiscoveryRT: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			PiiDiscoveryRTs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalPiiDiscoveryRT{
			client:         group.client,
			PiiDiscoveryRT: result,
		}, nil
	}
}

// DeletePiiDiscoveryRTByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeletePiiDiscoveryRTByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		PiiDiscoveryRTs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		PiiDiscoveryRTs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/piiDiscoveryGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreatePiiDiscoveryRTByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreatePiiDiscoveryRTByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PiiDiscoveryRT) (*GlobalPiiDiscoveryRT, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		PiiDiscoveryRTs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"piiDiscoveryGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"PiiDiscoveryRT\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalPiiDiscoveryRT{
		client:         group.client,
		PiiDiscoveryRT: result,
	}, nil
}

// UpdatePiiDiscoveryRTByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdatePiiDiscoveryRTByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.PiiDiscoveryRT) (*GlobalPiiDiscoveryRT, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			PiiDiscoveryRTs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueGnsid :=
		objToUpdate.Spec.Gnsid
	patchOpGnsid := PatchOp{
		Op:    "replace",
		Path:  "/spec/gnsid",
		Value: patchValueGnsid,
	}
	patch = append(patch, patchOpGnsid)

	patchValueSelectors :=
		objToUpdate.Spec.Selectors
	patchOpSelectors := PatchOp{
		Op:    "replace",
		Path:  "/spec/selectors",
		Value: patchValueSelectors,
	}
	patch = append(patch, patchOpSelectors)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		PiiDiscoveryRTs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalPiiDiscoveryRT{
		client:         group.client,
		PiiDiscoveryRT: result,
	}, nil
}

// ListPiiDiscoveryRTs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListPiiDiscoveryRTs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalPiiDiscoveryRT, err error) {
	key := "piidiscoveryrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalPiiDiscoveryRT, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.PiiDiscoveryRT)
			result[k] = &GlobalPiiDiscoveryRT{
				client:         group.client,
				PiiDiscoveryRT: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			PiiDiscoveryRTs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalPiiDiscoveryRT, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalPiiDiscoveryRT{
				client:         group.client,
				PiiDiscoveryRT: &item,
			}
		}
	}
	return
}

type GlobalPiiDiscoveryRT struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.PiiDiscoveryRT
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalPiiDiscoveryRT) Delete(ctx context.Context) error {
	err := obj.client.Global().DeletePiiDiscoveryRTByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.PiiDiscoveryRT = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalPiiDiscoveryRT) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdatePiiDiscoveryRTByName(ctx, obj.PiiDiscoveryRT)
	if err != nil {
		return err
	}
	obj.PiiDiscoveryRT = result.PiiDiscoveryRT
	return nil
}

func (obj *GlobalPiiDiscoveryRT) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

type piidiscoveryrtGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *piidiscoveryrtGlobalTsmV1Chainer) Subscribe() {
	key := "piidiscoveryrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewPiiDiscoveryRTInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *piidiscoveryrtGlobalTsmV1Chainer) Unsubscribe() {
	key := "piidiscoveryrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *piidiscoveryrtGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "piidiscoveryrts.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetPiiDiscoveryByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetPiiDiscoveryByName(ctx context.Context, hashedName string) (*GlobalPiiDiscovery, error) {
	key := "piidiscoveries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.PiiDiscovery)
		return &GlobalPiiDiscovery{
			client:       group.client,
			PiiDiscovery: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			PiiDiscoveries().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalPiiDiscovery{
			client:       group.client,
			PiiDiscovery: result,
		}, nil
	}
}

// DeletePiiDiscoveryByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeletePiiDiscoveryByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		PiiDiscoveries().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		PiiDiscoveries().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/piiDiscoveryGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreatePiiDiscoveryByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreatePiiDiscoveryByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PiiDiscovery) (*GlobalPiiDiscovery, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		PiiDiscoveries().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"piiDiscoveryGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"PiiDiscovery\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalPiiDiscovery{
		client:       group.client,
		PiiDiscovery: result,
	}, nil
}

// UpdatePiiDiscoveryByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdatePiiDiscoveryByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.PiiDiscovery) (*GlobalPiiDiscovery, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			PiiDiscoveries().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		PiiDiscoveries().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalPiiDiscovery{
		client:       group.client,
		PiiDiscovery: result,
	}, nil
}

// ListPiiDiscoveries returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListPiiDiscoveries(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalPiiDiscovery, err error) {
	key := "piidiscoveries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalPiiDiscovery, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.PiiDiscovery)
			result[k] = &GlobalPiiDiscovery{
				client:       group.client,
				PiiDiscovery: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			PiiDiscoveries().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalPiiDiscovery, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalPiiDiscovery{
				client:       group.client,
				PiiDiscovery: &item,
			}
		}
	}
	return
}

type GlobalPiiDiscovery struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.PiiDiscovery
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalPiiDiscovery) Delete(ctx context.Context) error {
	err := obj.client.Global().DeletePiiDiscoveryByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.PiiDiscovery = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalPiiDiscovery) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdatePiiDiscoveryByName(ctx, obj.PiiDiscovery)
	if err != nil {
		return err
	}
	obj.PiiDiscovery = result.PiiDiscovery
	return nil
}

func (obj *GlobalPiiDiscovery) GetParent(ctx context.Context) (result *GlobalGNS, err error) {
	hashedName := helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnss.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGNSByName(ctx, hashedName)
}

type piidiscoveryGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *piidiscoveryGlobalTsmV1Chainer) Subscribe() {
	key := "piidiscoveries.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewPiiDiscoveryInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *piidiscoveryGlobalTsmV1Chainer) Unsubscribe() {
	key := "piidiscoveries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *piidiscoveryGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "piidiscoveries.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetPolicyConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetPolicyConfigByName(ctx context.Context, hashedName string) (*GlobalPolicyConfig, error) {
	key := "policyconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.PolicyConfig)
		return &GlobalPolicyConfig{
			client:       group.client,
			PolicyConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			PolicyConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalPolicyConfig{
			client:       group.client,
			PolicyConfig: result,
		}, nil
	}
}

// DeletePolicyConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeletePolicyConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		PolicyConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		PolicyConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/policyGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreatePolicyConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreatePolicyConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PolicyConfig) (*GlobalPolicyConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		PolicyConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"policyGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"PolicyConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalPolicyConfig{
		client:       group.client,
		PolicyConfig: result,
	}, nil
}

// UpdatePolicyConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdatePolicyConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.PolicyConfig) (*GlobalPolicyConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			PolicyConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueSrc :=
		objToUpdate.Spec.Src
	patchOpSrc := PatchOp{
		Op:    "replace",
		Path:  "/spec/src",
		Value: patchValueSrc,
	}
	patch = append(patch, patchOpSrc)

	patchValueDst :=
		objToUpdate.Spec.Dst
	patchOpDst := PatchOp{
		Op:    "replace",
		Path:  "/spec/dst",
		Value: patchValueDst,
	}
	patch = append(patch, patchOpDst)

	patchValueAction :=
		objToUpdate.Spec.Action
	patchOpAction := PatchOp{
		Op:    "replace",
		Path:  "/spec/action",
		Value: patchValueAction,
	}
	patch = append(patch, patchOpAction)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		PolicyConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalPolicyConfig{
		client:       group.client,
		PolicyConfig: result,
	}, nil
}

// ListPolicyConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListPolicyConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalPolicyConfig, err error) {
	key := "policyconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalPolicyConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.PolicyConfig)
			result[k] = &GlobalPolicyConfig{
				client:       group.client,
				PolicyConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			PolicyConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalPolicyConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalPolicyConfig{
				client:       group.client,
				PolicyConfig: &item,
			}
		}
	}
	return
}

type GlobalPolicyConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.PolicyConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalPolicyConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeletePolicyConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.PolicyConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalPolicyConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdatePolicyConfigByName(ctx, obj.PolicyConfig)
	if err != nil {
		return err
	}
	obj.PolicyConfig = result.PolicyConfig
	return nil
}

func (obj *GlobalPolicyConfig) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

type policyconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *policyconfigGlobalTsmV1Chainer) Subscribe() {
	key := "policyconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewPolicyConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *policyconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "policyconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *policyconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "policyconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetPolicyTemplateByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetPolicyTemplateByName(ctx context.Context, hashedName string) (*GlobalPolicyTemplate, error) {
	key := "policytemplates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.PolicyTemplate)
		return &GlobalPolicyTemplate{
			client:         group.client,
			PolicyTemplate: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			PolicyTemplates().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalPolicyTemplate{
			client:         group.client,
			PolicyTemplate: result,
		}, nil
	}
}

// DeletePolicyTemplateByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeletePolicyTemplateByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		PolicyTemplates().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		PolicyTemplates().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/policyTemplatesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["templategroups.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("templategroups.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		TemplateGroups().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreatePolicyTemplateByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreatePolicyTemplateByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PolicyTemplate) (*GlobalPolicyTemplate, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		PolicyTemplates().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["templategroups.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("templategroups.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"policyTemplatesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"PolicyTemplate\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		TemplateGroups().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalPolicyTemplate{
		client:         group.client,
		PolicyTemplate: result,
	}, nil
}

// UpdatePolicyTemplateByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdatePolicyTemplateByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.PolicyTemplate) (*GlobalPolicyTemplate, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			PolicyTemplates().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		PolicyTemplates().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalPolicyTemplate{
		client:         group.client,
		PolicyTemplate: result,
	}, nil
}

// ListPolicyTemplates returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListPolicyTemplates(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalPolicyTemplate, err error) {
	key := "policytemplates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalPolicyTemplate, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.PolicyTemplate)
			result[k] = &GlobalPolicyTemplate{
				client:         group.client,
				PolicyTemplate: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			PolicyTemplates().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalPolicyTemplate, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalPolicyTemplate{
				client:         group.client,
				PolicyTemplate: &item,
			}
		}
	}
	return
}

type GlobalPolicyTemplate struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.PolicyTemplate
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalPolicyTemplate) Delete(ctx context.Context) error {
	err := obj.client.Global().DeletePolicyTemplateByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.PolicyTemplate = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalPolicyTemplate) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdatePolicyTemplateByName(ctx, obj.PolicyTemplate)
	if err != nil {
		return err
	}
	obj.PolicyTemplate = result.PolicyTemplate
	return nil
}

func (obj *GlobalPolicyTemplate) GetParent(ctx context.Context) (result *GlobalTemplateGroup, err error) {
	hashedName := helper.GetHashedName("templategroups.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["templategroups.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetTemplateGroupByName(ctx, hashedName)
}

type policytemplateGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *policytemplateGlobalTsmV1Chainer) Subscribe() {
	key := "policytemplates.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewPolicyTemplateInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *policytemplateGlobalTsmV1Chainer) Unsubscribe() {
	key := "policytemplates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *policytemplateGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "policytemplates.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetAccessControlPolicyByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetAccessControlPolicyByName(ctx context.Context, hashedName string) (*GlobalAccessControlPolicy, error) {
	key := "accesscontrolpolicies.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.AccessControlPolicy)
		return &GlobalAccessControlPolicy{
			client:              group.client,
			AccessControlPolicy: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			AccessControlPolicies().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalAccessControlPolicy{
			client:              group.client,
			AccessControlPolicy: result,
		}, nil
	}
}

// DeleteAccessControlPolicyByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteAccessControlPolicyByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AccessControlPolicies().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.PolicyConfigsGvk {
		err := group.client.
			Global().DeleteACPConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		AccessControlPolicies().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/policyGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAccessControlPolicyByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateAccessControlPolicyByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AccessControlPolicy) (*GlobalAccessControlPolicy, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.PolicyConfigsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		AccessControlPolicies().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/policyGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "AccessControlPolicy",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalAccessControlPolicy{
		client:              group.client,
		AccessControlPolicy: result,
	}, nil
}

// UpdateAccessControlPolicyByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateAccessControlPolicyByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.AccessControlPolicy) (*GlobalAccessControlPolicy, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			AccessControlPolicies().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		AccessControlPolicies().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalAccessControlPolicy{
		client:              group.client,
		AccessControlPolicy: result,
	}, nil
}

// ListAccessControlPolicies returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListAccessControlPolicies(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalAccessControlPolicy, err error) {
	key := "accesscontrolpolicies.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalAccessControlPolicy, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.AccessControlPolicy)
			result[k] = &GlobalAccessControlPolicy{
				client:              group.client,
				AccessControlPolicy: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			AccessControlPolicies().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalAccessControlPolicy, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalAccessControlPolicy{
				client:              group.client,
				AccessControlPolicy: &item,
			}
		}
	}
	return
}

type GlobalAccessControlPolicy struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.AccessControlPolicy
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalAccessControlPolicy) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteAccessControlPolicyByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AccessControlPolicy = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalAccessControlPolicy) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateAccessControlPolicyByName(ctx, obj.AccessControlPolicy)
	if err != nil {
		return err
	}
	obj.AccessControlPolicy = result.AccessControlPolicy
	return nil
}

func (obj *GlobalAccessControlPolicy) GetParent(ctx context.Context) (result *GlobalConfig, err error) {
	hashedName := helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetConfigByName(ctx, hashedName)
}

// GetAllPolicyConfigs returns all children of given type
func (obj *GlobalAccessControlPolicy) GetAllPolicyConfigs(ctx context.Context) (
	result []*GlobalACPConfig, err error) {
	result = make([]*GlobalACPConfig, 0, len(obj.Spec.PolicyConfigsGvk))
	for _, v := range obj.Spec.PolicyConfigsGvk {
		l, err := obj.client.Global().GetACPConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetPolicyConfigs returns child which has given displayName
func (obj *GlobalAccessControlPolicy) GetPolicyConfigs(ctx context.Context,
	displayName string) (result *GlobalACPConfig, err error) {
	l, ok := obj.Spec.PolicyConfigsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.AccessControlPolicy", "PolicyConfigs", displayName)
	}
	result, err = obj.client.Global().GetACPConfigByName(ctx, l.Name)
	return
}

// AddPolicyConfigs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalAccessControlPolicy) AddPolicyConfigs(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ACPConfig) (result *GlobalACPConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["accesscontrolpolicies.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["accesscontrolpolicies.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateACPConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetAccessControlPolicyByName(ctx, obj.GetName())
	if getErr == nil {
		obj.AccessControlPolicy = updatedObj.AccessControlPolicy
	}
	return
}

// DeletePolicyConfigs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalAccessControlPolicy) DeletePolicyConfigs(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.PolicyConfigsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.AccessControlPolicy", "PolicyConfigs", displayName)
	}
	err = obj.client.Global().DeleteACPConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetAccessControlPolicyByName(ctx, obj.GetName())
	if err == nil {
		obj.AccessControlPolicy = updatedObj.AccessControlPolicy
	}
	return
}

type accesscontrolpolicyGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *accesscontrolpolicyGlobalTsmV1Chainer) Subscribe() {
	key := "accesscontrolpolicies.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewAccessControlPolicyInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *accesscontrolpolicyGlobalTsmV1Chainer) Unsubscribe() {
	key := "accesscontrolpolicies.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *accesscontrolpolicyGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "accesscontrolpolicies.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *accesscontrolpolicyGlobalTsmV1Chainer) PolicyConfigs(name string) *acpconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["acpconfigs.global.tsm.tanzu.vmware.com"] = name
	return &acpconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetPolicyConfigs calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *accesscontrolpolicyGlobalTsmV1Chainer) GetPolicyConfigs(ctx context.Context, displayName string) (result *GlobalACPConfig, err error) {
	hashedName := helper.GetHashedName("acpconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetACPConfigByName(ctx, hashedName)
}

// AddPolicyConfigs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *accesscontrolpolicyGlobalTsmV1Chainer) AddPolicyConfigs(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ACPConfig) (result *GlobalACPConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("acpconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateACPConfigByName(ctx, objToCreate)
}

// DeletePolicyConfigs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *accesscontrolpolicyGlobalTsmV1Chainer) DeletePolicyConfigs(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("acpconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteACPConfigByName(ctx, hashedName)
}

// GetProgressiveUpgradeByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetProgressiveUpgradeByName(ctx context.Context, hashedName string) (*GlobalProgressiveUpgrade, error) {
	key := "progressiveupgrades.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgrade)
		return &GlobalProgressiveUpgrade{
			client:             group.client,
			ProgressiveUpgrade: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ProgressiveUpgrades().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalProgressiveUpgrade{
			client:             group.client,
			ProgressiveUpgrade: result,
		}, nil
	}
}

// DeleteProgressiveUpgradeByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteProgressiveUpgradeByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ProgressiveUpgrades().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.UpgradeGvk {
		err := group.client.
			Global().DeleteProgressiveUpgradeConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ProgressiveUpgrades().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/progressiveUpgradeGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateProgressiveUpgradeByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateProgressiveUpgradeByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgrade) (*GlobalProgressiveUpgrade, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.UpgradeGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ProgressiveUpgrades().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/progressiveUpgradeGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "ProgressiveUpgrade",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalProgressiveUpgrade{
		client:             group.client,
		ProgressiveUpgrade: result,
	}, nil
}

// UpdateProgressiveUpgradeByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateProgressiveUpgradeByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgrade) (*GlobalProgressiveUpgrade, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ProgressiveUpgrades().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ProgressiveUpgrades().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalProgressiveUpgrade{
		client:             group.client,
		ProgressiveUpgrade: result,
	}, nil
}

// ListProgressiveUpgrades returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListProgressiveUpgrades(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalProgressiveUpgrade, err error) {
	key := "progressiveupgrades.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalProgressiveUpgrade, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgrade)
			result[k] = &GlobalProgressiveUpgrade{
				client:             group.client,
				ProgressiveUpgrade: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ProgressiveUpgrades().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalProgressiveUpgrade, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalProgressiveUpgrade{
				client:             group.client,
				ProgressiveUpgrade: &item,
			}
		}
	}
	return
}

type GlobalProgressiveUpgrade struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgrade
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalProgressiveUpgrade) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteProgressiveUpgradeByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ProgressiveUpgrade = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalProgressiveUpgrade) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateProgressiveUpgradeByName(ctx, obj.ProgressiveUpgrade)
	if err != nil {
		return err
	}
	obj.ProgressiveUpgrade = result.ProgressiveUpgrade
	return nil
}

func (obj *GlobalProgressiveUpgrade) GetParent(ctx context.Context) (result *GlobalConfig, err error) {
	hashedName := helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetConfigByName(ctx, hashedName)
}

// GetAllUpgrade returns all children of given type
func (obj *GlobalProgressiveUpgrade) GetAllUpgrade(ctx context.Context) (
	result []*GlobalProgressiveUpgradeConfig, err error) {
	result = make([]*GlobalProgressiveUpgradeConfig, 0, len(obj.Spec.UpgradeGvk))
	for _, v := range obj.Spec.UpgradeGvk {
		l, err := obj.client.Global().GetProgressiveUpgradeConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetUpgrade returns child which has given displayName
func (obj *GlobalProgressiveUpgrade) GetUpgrade(ctx context.Context,
	displayName string) (result *GlobalProgressiveUpgradeConfig, err error) {
	l, ok := obj.Spec.UpgradeGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ProgressiveUpgrade", "Upgrade", displayName)
	}
	result, err = obj.client.Global().GetProgressiveUpgradeConfigByName(ctx, l.Name)
	return
}

// AddUpgrade calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalProgressiveUpgrade) AddUpgrade(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgradeConfig) (result *GlobalProgressiveUpgradeConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["progressiveupgrades.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["progressiveupgrades.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateProgressiveUpgradeConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetProgressiveUpgradeByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ProgressiveUpgrade = updatedObj.ProgressiveUpgrade
	}
	return
}

// DeleteUpgrade calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalProgressiveUpgrade) DeleteUpgrade(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.UpgradeGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ProgressiveUpgrade", "Upgrade", displayName)
	}
	err = obj.client.Global().DeleteProgressiveUpgradeConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetProgressiveUpgradeByName(ctx, obj.GetName())
	if err == nil {
		obj.ProgressiveUpgrade = updatedObj.ProgressiveUpgrade
	}
	return
}

type progressiveupgradeGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *progressiveupgradeGlobalTsmV1Chainer) Subscribe() {
	key := "progressiveupgrades.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewProgressiveUpgradeInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *progressiveupgradeGlobalTsmV1Chainer) Unsubscribe() {
	key := "progressiveupgrades.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *progressiveupgradeGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "progressiveupgrades.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *progressiveupgradeGlobalTsmV1Chainer) Upgrade(name string) *progressiveupgradeconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["progressiveupgradeconfigs.global.tsm.tanzu.vmware.com"] = name
	return &progressiveupgradeconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetUpgrade calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *progressiveupgradeGlobalTsmV1Chainer) GetUpgrade(ctx context.Context, displayName string) (result *GlobalProgressiveUpgradeConfig, err error) {
	hashedName := helper.GetHashedName("progressiveupgradeconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetProgressiveUpgradeConfigByName(ctx, hashedName)
}

// AddUpgrade calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *progressiveupgradeGlobalTsmV1Chainer) AddUpgrade(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgradeConfig) (result *GlobalProgressiveUpgradeConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("progressiveupgradeconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateProgressiveUpgradeConfigByName(ctx, objToCreate)
}

// DeleteUpgrade calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *progressiveupgradeGlobalTsmV1Chainer) DeleteUpgrade(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("progressiveupgradeconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteProgressiveUpgradeConfigByName(ctx, hashedName)
}

// GetProgressiveUpgradeConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetProgressiveUpgradeConfigByName(ctx context.Context, hashedName string) (*GlobalProgressiveUpgradeConfig, error) {
	key := "progressiveupgradeconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgradeConfig)
		return &GlobalProgressiveUpgradeConfig{
			client:                   group.client,
			ProgressiveUpgradeConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ProgressiveUpgradeConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalProgressiveUpgradeConfig{
			client:                   group.client,
			ProgressiveUpgradeConfig: result,
		}, nil
	}
}

// DeleteProgressiveUpgradeConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteProgressiveUpgradeConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ProgressiveUpgradeConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ProgressiveUpgradeConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/upgradeGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["progressiveupgrades.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("progressiveupgrades.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ProgressiveUpgrades().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateProgressiveUpgradeConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateProgressiveUpgradeConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgradeConfig) (*GlobalProgressiveUpgradeConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ProgressiveUpgradeConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["progressiveupgrades.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("progressiveupgrades.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"upgradeGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ProgressiveUpgradeConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ProgressiveUpgrades().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalProgressiveUpgradeConfig{
		client:                   group.client,
		ProgressiveUpgradeConfig: result,
	}, nil
}

// UpdateProgressiveUpgradeConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateProgressiveUpgradeConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgradeConfig) (*GlobalProgressiveUpgradeConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ProgressiveUpgradeConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueServices :=
		objToUpdate.Spec.Services
	patchOpServices := PatchOp{
		Op:    "replace",
		Path:  "/spec/services",
		Value: patchValueServices,
	}
	patch = append(patch, patchOpServices)

	patchValueUpgradeStrategy :=
		objToUpdate.Spec.UpgradeStrategy
	patchOpUpgradeStrategy := PatchOp{
		Op:    "replace",
		Path:  "/spec/upgradeStrategy",
		Value: patchValueUpgradeStrategy,
	}
	patch = append(patch, patchOpUpgradeStrategy)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ProgressiveUpgradeConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalProgressiveUpgradeConfig{
		client:                   group.client,
		ProgressiveUpgradeConfig: result,
	}, nil
}

// ListProgressiveUpgradeConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListProgressiveUpgradeConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalProgressiveUpgradeConfig, err error) {
	key := "progressiveupgradeconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalProgressiveUpgradeConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgradeConfig)
			result[k] = &GlobalProgressiveUpgradeConfig{
				client:                   group.client,
				ProgressiveUpgradeConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ProgressiveUpgradeConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalProgressiveUpgradeConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalProgressiveUpgradeConfig{
				client:                   group.client,
				ProgressiveUpgradeConfig: &item,
			}
		}
	}
	return
}

type GlobalProgressiveUpgradeConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgradeConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalProgressiveUpgradeConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteProgressiveUpgradeConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ProgressiveUpgradeConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalProgressiveUpgradeConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateProgressiveUpgradeConfigByName(ctx, obj.ProgressiveUpgradeConfig)
	if err != nil {
		return err
	}
	obj.ProgressiveUpgradeConfig = result.ProgressiveUpgradeConfig
	return nil
}

func (obj *GlobalProgressiveUpgradeConfig) GetParent(ctx context.Context) (result *GlobalProgressiveUpgrade, err error) {
	hashedName := helper.GetHashedName("progressiveupgrades.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["progressiveupgrades.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetProgressiveUpgradeByName(ctx, hashedName)
}

type progressiveupgradeconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *progressiveupgradeconfigGlobalTsmV1Chainer) Subscribe() {
	key := "progressiveupgradeconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewProgressiveUpgradeConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *progressiveupgradeconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "progressiveupgradeconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *progressiveupgradeconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "progressiveupgradeconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetProgressiveUpgradeFolderByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetProgressiveUpgradeFolderByName(ctx context.Context, hashedName string) (*GlobalProgressiveUpgradeFolder, error) {
	key := "progressiveupgradefolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgradeFolder)
		return &GlobalProgressiveUpgradeFolder{
			client:                   group.client,
			ProgressiveUpgradeFolder: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ProgressiveUpgradeFolders().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalProgressiveUpgradeFolder{
			client:                   group.client,
			ProgressiveUpgradeFolder: result,
		}, nil
	}
}

// DeleteProgressiveUpgradeFolderByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteProgressiveUpgradeFolderByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ProgressiveUpgradeFolders().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.UpgradesGvk {
		err := group.client.
			Global().DeleteProgressiveUpgradeRuntimeByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ProgressiveUpgradeFolders().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/progressiveUpgradeGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["runtimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateProgressiveUpgradeFolderByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateProgressiveUpgradeFolderByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgradeFolder) (*GlobalProgressiveUpgradeFolder, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.UpgradesGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ProgressiveUpgradeFolders().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["runtimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/progressiveUpgradeGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "ProgressiveUpgradeFolder",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalProgressiveUpgradeFolder{
		client:                   group.client,
		ProgressiveUpgradeFolder: result,
	}, nil
}

// UpdateProgressiveUpgradeFolderByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateProgressiveUpgradeFolderByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgradeFolder) (*GlobalProgressiveUpgradeFolder, error) {
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ProgressiveUpgradeFolders().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ProgressiveUpgradeFolders().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalProgressiveUpgradeFolder{
		client:                   group.client,
		ProgressiveUpgradeFolder: result,
	}, nil
}

// ListProgressiveUpgradeFolders returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListProgressiveUpgradeFolders(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalProgressiveUpgradeFolder, err error) {
	key := "progressiveupgradefolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalProgressiveUpgradeFolder, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgradeFolder)
			result[k] = &GlobalProgressiveUpgradeFolder{
				client:                   group.client,
				ProgressiveUpgradeFolder: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ProgressiveUpgradeFolders().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalProgressiveUpgradeFolder, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalProgressiveUpgradeFolder{
				client:                   group.client,
				ProgressiveUpgradeFolder: &item,
			}
		}
	}
	return
}

type GlobalProgressiveUpgradeFolder struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgradeFolder
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalProgressiveUpgradeFolder) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteProgressiveUpgradeFolderByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ProgressiveUpgradeFolder = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalProgressiveUpgradeFolder) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateProgressiveUpgradeFolderByName(ctx, obj.ProgressiveUpgradeFolder)
	if err != nil {
		return err
	}
	obj.ProgressiveUpgradeFolder = result.ProgressiveUpgradeFolder
	return nil
}

func (obj *GlobalProgressiveUpgradeFolder) GetParent(ctx context.Context) (result *GlobalRuntime, err error) {
	hashedName := helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["runtimes.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetRuntimeByName(ctx, hashedName)
}

// GetAllUpgrades returns all children of given type
func (obj *GlobalProgressiveUpgradeFolder) GetAllUpgrades(ctx context.Context) (
	result []*GlobalProgressiveUpgradeRuntime, err error) {
	result = make([]*GlobalProgressiveUpgradeRuntime, 0, len(obj.Spec.UpgradesGvk))
	for _, v := range obj.Spec.UpgradesGvk {
		l, err := obj.client.Global().GetProgressiveUpgradeRuntimeByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetUpgrades returns child which has given displayName
func (obj *GlobalProgressiveUpgradeFolder) GetUpgrades(ctx context.Context,
	displayName string) (result *GlobalProgressiveUpgradeRuntime, err error) {
	l, ok := obj.Spec.UpgradesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ProgressiveUpgradeFolder", "Upgrades", displayName)
	}
	result, err = obj.client.Global().GetProgressiveUpgradeRuntimeByName(ctx, l.Name)
	return
}

// AddUpgrades calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalProgressiveUpgradeFolder) AddUpgrades(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgradeRuntime) (result *GlobalProgressiveUpgradeRuntime, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["progressiveupgradefolders.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["progressiveupgradefolders.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateProgressiveUpgradeRuntimeByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetProgressiveUpgradeFolderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ProgressiveUpgradeFolder = updatedObj.ProgressiveUpgradeFolder
	}
	return
}

// DeleteUpgrades calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalProgressiveUpgradeFolder) DeleteUpgrades(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.UpgradesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ProgressiveUpgradeFolder", "Upgrades", displayName)
	}
	err = obj.client.Global().DeleteProgressiveUpgradeRuntimeByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetProgressiveUpgradeFolderByName(ctx, obj.GetName())
	if err == nil {
		obj.ProgressiveUpgradeFolder = updatedObj.ProgressiveUpgradeFolder
	}
	return
}

type progressiveupgradefolderGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *progressiveupgradefolderGlobalTsmV1Chainer) Subscribe() {
	key := "progressiveupgradefolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewProgressiveUpgradeFolderInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *progressiveupgradefolderGlobalTsmV1Chainer) Unsubscribe() {
	key := "progressiveupgradefolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *progressiveupgradefolderGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "progressiveupgradefolders.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *progressiveupgradefolderGlobalTsmV1Chainer) Upgrades(name string) *progressiveupgraderuntimeGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["progressiveupgraderuntimes.global.tsm.tanzu.vmware.com"] = name
	return &progressiveupgraderuntimeGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetUpgrades calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *progressiveupgradefolderGlobalTsmV1Chainer) GetUpgrades(ctx context.Context, displayName string) (result *GlobalProgressiveUpgradeRuntime, err error) {
	hashedName := helper.GetHashedName("progressiveupgraderuntimes.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetProgressiveUpgradeRuntimeByName(ctx, hashedName)
}

// AddUpgrades calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *progressiveupgradefolderGlobalTsmV1Chainer) AddUpgrades(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgradeRuntime) (result *GlobalProgressiveUpgradeRuntime, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("progressiveupgraderuntimes.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateProgressiveUpgradeRuntimeByName(ctx, objToCreate)
}

// DeleteUpgrades calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *progressiveupgradefolderGlobalTsmV1Chainer) DeleteUpgrades(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("progressiveupgraderuntimes.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteProgressiveUpgradeRuntimeByName(ctx, hashedName)
}

// GetProgressiveUpgradeRuntimeByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetProgressiveUpgradeRuntimeByName(ctx context.Context, hashedName string) (*GlobalProgressiveUpgradeRuntime, error) {
	key := "progressiveupgraderuntimes.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgradeRuntime)
		return &GlobalProgressiveUpgradeRuntime{
			client:                    group.client,
			ProgressiveUpgradeRuntime: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ProgressiveUpgradeRuntimes().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalProgressiveUpgradeRuntime{
			client:                    group.client,
			ProgressiveUpgradeRuntime: result,
		}, nil
	}
}

// DeleteProgressiveUpgradeRuntimeByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteProgressiveUpgradeRuntimeByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ProgressiveUpgradeRuntimes().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ProgressiveUpgradeRuntimes().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/upgradesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["progressiveupgradefolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("progressiveupgradefolders.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ProgressiveUpgradeFolders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateProgressiveUpgradeRuntimeByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateProgressiveUpgradeRuntimeByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgradeRuntime) (*GlobalProgressiveUpgradeRuntime, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ProgressiveUpgradeRuntimes().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["progressiveupgradefolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("progressiveupgradefolders.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"upgradesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ProgressiveUpgradeRuntime\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ProgressiveUpgradeFolders().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalProgressiveUpgradeRuntime{
		client:                    group.client,
		ProgressiveUpgradeRuntime: result,
	}, nil
}

// UpdateProgressiveUpgradeRuntimeByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateProgressiveUpgradeRuntimeByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgradeRuntime) (*GlobalProgressiveUpgradeRuntime, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ProgressiveUpgradeRuntimes().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueUpgradeName :=
		objToUpdate.Spec.UpgradeName
	patchOpUpgradeName := PatchOp{
		Op:    "replace",
		Path:  "/spec/upgradeName",
		Value: patchValueUpgradeName,
	}
	patch = append(patch, patchOpUpgradeName)

	patchValueStatus :=
		objToUpdate.Spec.Status
	patchOpStatus := PatchOp{
		Op:    "replace",
		Path:  "/spec/status",
		Value: patchValueStatus,
	}
	patch = append(patch, patchOpStatus)

	patchValueStep :=
		objToUpdate.Spec.Step
	patchOpStep := PatchOp{
		Op:    "replace",
		Path:  "/spec/step",
		Value: patchValueStep,
	}
	patch = append(patch, patchOpStep)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ProgressiveUpgradeRuntimes().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalProgressiveUpgradeRuntime{
		client:                    group.client,
		ProgressiveUpgradeRuntime: result,
	}, nil
}

// ListProgressiveUpgradeRuntimes returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListProgressiveUpgradeRuntimes(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalProgressiveUpgradeRuntime, err error) {
	key := "progressiveupgraderuntimes.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalProgressiveUpgradeRuntime, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgradeRuntime)
			result[k] = &GlobalProgressiveUpgradeRuntime{
				client:                    group.client,
				ProgressiveUpgradeRuntime: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ProgressiveUpgradeRuntimes().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalProgressiveUpgradeRuntime, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalProgressiveUpgradeRuntime{
				client:                    group.client,
				ProgressiveUpgradeRuntime: &item,
			}
		}
	}
	return
}

type GlobalProgressiveUpgradeRuntime struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgradeRuntime
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalProgressiveUpgradeRuntime) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteProgressiveUpgradeRuntimeByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ProgressiveUpgradeRuntime = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalProgressiveUpgradeRuntime) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateProgressiveUpgradeRuntimeByName(ctx, obj.ProgressiveUpgradeRuntime)
	if err != nil {
		return err
	}
	obj.ProgressiveUpgradeRuntime = result.ProgressiveUpgradeRuntime
	return nil
}

func (obj *GlobalProgressiveUpgradeRuntime) GetParent(ctx context.Context) (result *GlobalProgressiveUpgradeFolder, err error) {
	hashedName := helper.GetHashedName("progressiveupgradefolders.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["progressiveupgradefolders.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetProgressiveUpgradeFolderByName(ctx, hashedName)
}

type progressiveupgraderuntimeGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *progressiveupgraderuntimeGlobalTsmV1Chainer) Subscribe() {
	key := "progressiveupgraderuntimes.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewProgressiveUpgradeRuntimeInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *progressiveupgraderuntimeGlobalTsmV1Chainer) Unsubscribe() {
	key := "progressiveupgraderuntimes.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *progressiveupgraderuntimeGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "progressiveupgraderuntimes.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetProjectConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetProjectConfigByName(ctx context.Context, hashedName string) (*GlobalProjectConfig, error) {
	key := "projectconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ProjectConfig)
		return &GlobalProjectConfig{
			client:        group.client,
			ProjectConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ProjectConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalProjectConfig{
			client:        group.client,
			ProjectConfig: result,
		}, nil
	}
}

// DeleteProjectConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteProjectConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ProjectConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.CertificateAuthoritiesGvk {
		err := group.client.
			Global().DeleteCertificateAuthorityConfigNByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ProjectConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/configGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["projects.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("projects.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Projects().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateProjectConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateProjectConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ProjectConfig) (*GlobalProjectConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.CertificateAuthoritiesGvk = nil
	objToCreate.Spec.SvcGroupsGvk = nil
	objToCreate.Spec.GnsGvk = nil
	objToCreate.Spec.PolicyConfigsGvk = nil
	objToCreate.Spec.TemplateGroupsGvk = nil
	objToCreate.Spec.CertificatesGvk = nil
	objToCreate.Spec.ExternalAccountsGvk = nil
	objToCreate.Spec.ExternalDNSGvk = nil
	objToCreate.Spec.AutoscalersGvk = nil
	objToCreate.Spec.ClustersGvk = nil
	objToCreate.Spec.ServiceLevelObjectivesGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ProjectConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["projects.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("projects.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/configGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "ProjectConfig",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Projects().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalProjectConfig{
		client:        group.client,
		ProjectConfig: result,
	}, nil
}

// UpdateProjectConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateProjectConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ProjectConfig) (*GlobalProjectConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ProjectConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ProjectConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalProjectConfig{
		client:        group.client,
		ProjectConfig: result,
	}, nil
}

// ListProjectConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListProjectConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalProjectConfig, err error) {
	key := "projectconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalProjectConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ProjectConfig)
			result[k] = &GlobalProjectConfig{
				client:        group.client,
				ProjectConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ProjectConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalProjectConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalProjectConfig{
				client:        group.client,
				ProjectConfig: &item,
			}
		}
	}
	return
}

type GlobalProjectConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ProjectConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalProjectConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteProjectConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ProjectConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalProjectConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateProjectConfigByName(ctx, obj.ProjectConfig)
	if err != nil {
		return err
	}
	obj.ProjectConfig = result.ProjectConfig
	return nil
}

func (obj *GlobalProjectConfig) GetParent(ctx context.Context) (result *GlobalProject, err error) {
	hashedName := helper.GetHashedName("projects.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["projects.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetProjectByName(ctx, hashedName)
}

// GetAllCertificateAuthorities returns all children of given type
func (obj *GlobalProjectConfig) GetAllCertificateAuthorities(ctx context.Context) (
	result []*GlobalCertificateAuthorityConfigN, err error) {
	result = make([]*GlobalCertificateAuthorityConfigN, 0, len(obj.Spec.CertificateAuthoritiesGvk))
	for _, v := range obj.Spec.CertificateAuthoritiesGvk {
		l, err := obj.client.Global().GetCertificateAuthorityConfigNByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetCertificateAuthorities returns child which has given displayName
func (obj *GlobalProjectConfig) GetCertificateAuthorities(ctx context.Context,
	displayName string) (result *GlobalCertificateAuthorityConfigN, err error) {
	l, ok := obj.Spec.CertificateAuthoritiesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ProjectConfig", "CertificateAuthorities", displayName)
	}
	result, err = obj.client.Global().GetCertificateAuthorityConfigNByName(ctx, l.Name)
	return
}

// AddCertificateAuthorities calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalProjectConfig) AddCertificateAuthorities(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.CertificateAuthorityConfigN) (result *GlobalCertificateAuthorityConfigN, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["projectconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["projectconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateCertificateAuthorityConfigNByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetProjectConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ProjectConfig = updatedObj.ProjectConfig
	}
	return
}

// DeleteCertificateAuthorities calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalProjectConfig) DeleteCertificateAuthorities(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.CertificateAuthoritiesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ProjectConfig", "CertificateAuthorities", displayName)
	}
	err = obj.client.Global().DeleteCertificateAuthorityConfigNByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetProjectConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.ProjectConfig = updatedObj.ProjectConfig
	}
	return
}

// GetAllSvcGroups returns all links of given type
func (obj *GlobalProjectConfig) GetAllSvcGroups(ctx context.Context) (
	result []*GlobalSvcGroup, err error) {
	result = make([]*GlobalSvcGroup, 0, len(obj.Spec.SvcGroupsGvk))
	for _, v := range obj.Spec.SvcGroupsGvk {
		l, err := obj.client.Global().GetSvcGroupByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetSvcGroups returns link which has given displayName
func (obj *GlobalProjectConfig) GetSvcGroups(ctx context.Context,
	displayName string) (result *GlobalSvcGroup, err error) {
	l, ok := obj.Spec.SvcGroupsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ProjectConfig", "SvcGroups", displayName)
	}
	result, err = obj.client.Global().GetSvcGroupByName(ctx, l.Name)
	return
}

// LinkSvcGroups links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalProjectConfig) LinkSvcGroups(ctx context.Context,
	linkToAdd *GlobalSvcGroup) error {

	payload := "{\"spec\": {\"svcGroupsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"SvcGroup\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectConfigs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ProjectConfig = result
	return nil
}

// UnlinkSvcGroups unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalProjectConfig) UnlinkSvcGroups(ctx context.Context,
	linkToRemove *GlobalSvcGroup) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/svcGroupsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ProjectConfig = result
	return nil

}

// GetAllGns returns all links of given type
func (obj *GlobalProjectConfig) GetAllGns(ctx context.Context) (
	result []*GlobalGNS, err error) {
	result = make([]*GlobalGNS, 0, len(obj.Spec.GnsGvk))
	for _, v := range obj.Spec.GnsGvk {
		l, err := obj.client.Global().GetGNSByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGns returns link which has given displayName
func (obj *GlobalProjectConfig) GetGns(ctx context.Context,
	displayName string) (result *GlobalGNS, err error) {
	l, ok := obj.Spec.GnsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ProjectConfig", "Gns", displayName)
	}
	result, err = obj.client.Global().GetGNSByName(ctx, l.Name)
	return
}

// LinkGns links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalProjectConfig) LinkGns(ctx context.Context,
	linkToAdd *GlobalGNS) error {

	payload := "{\"spec\": {\"gnsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"GNS\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectConfigs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ProjectConfig = result
	return nil
}

// UnlinkGns unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalProjectConfig) UnlinkGns(ctx context.Context,
	linkToRemove *GlobalGNS) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gnsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ProjectConfig = result
	return nil

}

// GetAllPolicyConfigs returns all links of given type
func (obj *GlobalProjectConfig) GetAllPolicyConfigs(ctx context.Context) (
	result []*GlobalACPConfig, err error) {
	result = make([]*GlobalACPConfig, 0, len(obj.Spec.PolicyConfigsGvk))
	for _, v := range obj.Spec.PolicyConfigsGvk {
		l, err := obj.client.Global().GetACPConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetPolicyConfigs returns link which has given displayName
func (obj *GlobalProjectConfig) GetPolicyConfigs(ctx context.Context,
	displayName string) (result *GlobalACPConfig, err error) {
	l, ok := obj.Spec.PolicyConfigsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ProjectConfig", "PolicyConfigs", displayName)
	}
	result, err = obj.client.Global().GetACPConfigByName(ctx, l.Name)
	return
}

// LinkPolicyConfigs links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalProjectConfig) LinkPolicyConfigs(ctx context.Context,
	linkToAdd *GlobalACPConfig) error {

	payload := "{\"spec\": {\"policyConfigsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ACPConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectConfigs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ProjectConfig = result
	return nil
}

// UnlinkPolicyConfigs unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalProjectConfig) UnlinkPolicyConfigs(ctx context.Context,
	linkToRemove *GlobalACPConfig) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/policyConfigsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ProjectConfig = result
	return nil

}

// GetAllTemplateGroups returns all links of given type
func (obj *GlobalProjectConfig) GetAllTemplateGroups(ctx context.Context) (
	result []*GlobalTemplateGroup, err error) {
	result = make([]*GlobalTemplateGroup, 0, len(obj.Spec.TemplateGroupsGvk))
	for _, v := range obj.Spec.TemplateGroupsGvk {
		l, err := obj.client.Global().GetTemplateGroupByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetTemplateGroups returns link which has given displayName
func (obj *GlobalProjectConfig) GetTemplateGroups(ctx context.Context,
	displayName string) (result *GlobalTemplateGroup, err error) {
	l, ok := obj.Spec.TemplateGroupsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ProjectConfig", "TemplateGroups", displayName)
	}
	result, err = obj.client.Global().GetTemplateGroupByName(ctx, l.Name)
	return
}

// LinkTemplateGroups links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalProjectConfig) LinkTemplateGroups(ctx context.Context,
	linkToAdd *GlobalTemplateGroup) error {

	payload := "{\"spec\": {\"templateGroupsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"TemplateGroup\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectConfigs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ProjectConfig = result
	return nil
}

// UnlinkTemplateGroups unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalProjectConfig) UnlinkTemplateGroups(ctx context.Context,
	linkToRemove *GlobalTemplateGroup) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/templateGroupsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ProjectConfig = result
	return nil

}

// GetAllCertificates returns all links of given type
func (obj *GlobalProjectConfig) GetAllCertificates(ctx context.Context) (
	result []*GlobalCertificateConfigN, err error) {
	result = make([]*GlobalCertificateConfigN, 0, len(obj.Spec.CertificatesGvk))
	for _, v := range obj.Spec.CertificatesGvk {
		l, err := obj.client.Global().GetCertificateConfigNByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetCertificates returns link which has given displayName
func (obj *GlobalProjectConfig) GetCertificates(ctx context.Context,
	displayName string) (result *GlobalCertificateConfigN, err error) {
	l, ok := obj.Spec.CertificatesGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ProjectConfig", "Certificates", displayName)
	}
	result, err = obj.client.Global().GetCertificateConfigNByName(ctx, l.Name)
	return
}

// LinkCertificates links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalProjectConfig) LinkCertificates(ctx context.Context,
	linkToAdd *GlobalCertificateConfigN) error {

	payload := "{\"spec\": {\"certificatesGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"CertificateConfigN\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectConfigs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ProjectConfig = result
	return nil
}

// UnlinkCertificates unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalProjectConfig) UnlinkCertificates(ctx context.Context,
	linkToRemove *GlobalCertificateConfigN) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/certificatesGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ProjectConfig = result
	return nil

}

// GetAllExternalAccounts returns all links of given type
func (obj *GlobalProjectConfig) GetAllExternalAccounts(ctx context.Context) (
	result []*GlobalExternalAccountConfigN, err error) {
	result = make([]*GlobalExternalAccountConfigN, 0, len(obj.Spec.ExternalAccountsGvk))
	for _, v := range obj.Spec.ExternalAccountsGvk {
		l, err := obj.client.Global().GetExternalAccountConfigNByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetExternalAccounts returns link which has given displayName
func (obj *GlobalProjectConfig) GetExternalAccounts(ctx context.Context,
	displayName string) (result *GlobalExternalAccountConfigN, err error) {
	l, ok := obj.Spec.ExternalAccountsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ProjectConfig", "ExternalAccounts", displayName)
	}
	result, err = obj.client.Global().GetExternalAccountConfigNByName(ctx, l.Name)
	return
}

// LinkExternalAccounts links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalProjectConfig) LinkExternalAccounts(ctx context.Context,
	linkToAdd *GlobalExternalAccountConfigN) error {

	payload := "{\"spec\": {\"externalAccountsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ExternalAccountConfigN\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectConfigs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ProjectConfig = result
	return nil
}

// UnlinkExternalAccounts unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalProjectConfig) UnlinkExternalAccounts(ctx context.Context,
	linkToRemove *GlobalExternalAccountConfigN) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/externalAccountsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ProjectConfig = result
	return nil

}

// GetAllExternalDNS returns all links of given type
func (obj *GlobalProjectConfig) GetAllExternalDNS(ctx context.Context) (
	result []*GlobalExternalDNSConfigN, err error) {
	result = make([]*GlobalExternalDNSConfigN, 0, len(obj.Spec.ExternalDNSGvk))
	for _, v := range obj.Spec.ExternalDNSGvk {
		l, err := obj.client.Global().GetExternalDNSConfigNByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetExternalDNS returns link which has given displayName
func (obj *GlobalProjectConfig) GetExternalDNS(ctx context.Context,
	displayName string) (result *GlobalExternalDNSConfigN, err error) {
	l, ok := obj.Spec.ExternalDNSGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ProjectConfig", "ExternalDNS", displayName)
	}
	result, err = obj.client.Global().GetExternalDNSConfigNByName(ctx, l.Name)
	return
}

// LinkExternalDNS links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalProjectConfig) LinkExternalDNS(ctx context.Context,
	linkToAdd *GlobalExternalDNSConfigN) error {

	payload := "{\"spec\": {\"externalDNSGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ExternalDNSConfigN\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectConfigs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ProjectConfig = result
	return nil
}

// UnlinkExternalDNS unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalProjectConfig) UnlinkExternalDNS(ctx context.Context,
	linkToRemove *GlobalExternalDNSConfigN) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/externalDNSGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ProjectConfig = result
	return nil

}

// GetAllAutoscalers returns all links of given type
func (obj *GlobalProjectConfig) GetAllAutoscalers(ctx context.Context) (
	result []*GlobalAutoscaler, err error) {
	result = make([]*GlobalAutoscaler, 0, len(obj.Spec.AutoscalersGvk))
	for _, v := range obj.Spec.AutoscalersGvk {
		l, err := obj.client.Global().GetAutoscalerByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetAutoscalers returns link which has given displayName
func (obj *GlobalProjectConfig) GetAutoscalers(ctx context.Context,
	displayName string) (result *GlobalAutoscaler, err error) {
	l, ok := obj.Spec.AutoscalersGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ProjectConfig", "Autoscalers", displayName)
	}
	result, err = obj.client.Global().GetAutoscalerByName(ctx, l.Name)
	return
}

// LinkAutoscalers links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalProjectConfig) LinkAutoscalers(ctx context.Context,
	linkToAdd *GlobalAutoscaler) error {

	payload := "{\"spec\": {\"autoscalersGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"Autoscaler\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectConfigs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ProjectConfig = result
	return nil
}

// UnlinkAutoscalers unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalProjectConfig) UnlinkAutoscalers(ctx context.Context,
	linkToRemove *GlobalAutoscaler) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/autoscalersGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ProjectConfig = result
	return nil

}

// GetAllClusters returns all links of given type
func (obj *GlobalProjectConfig) GetAllClusters(ctx context.Context) (
	result []*GlobalClusterSettings, err error) {
	result = make([]*GlobalClusterSettings, 0, len(obj.Spec.ClustersGvk))
	for _, v := range obj.Spec.ClustersGvk {
		l, err := obj.client.Global().GetClusterSettingsByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetClusters returns link which has given displayName
func (obj *GlobalProjectConfig) GetClusters(ctx context.Context,
	displayName string) (result *GlobalClusterSettings, err error) {
	l, ok := obj.Spec.ClustersGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ProjectConfig", "Clusters", displayName)
	}
	result, err = obj.client.Global().GetClusterSettingsByName(ctx, l.Name)
	return
}

// LinkClusters links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalProjectConfig) LinkClusters(ctx context.Context,
	linkToAdd *GlobalClusterSettings) error {

	payload := "{\"spec\": {\"clustersGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ClusterSettings\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectConfigs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ProjectConfig = result
	return nil
}

// UnlinkClusters unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalProjectConfig) UnlinkClusters(ctx context.Context,
	linkToRemove *GlobalClusterSettings) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/clustersGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ProjectConfig = result
	return nil

}

// GetAllServiceLevelObjectives returns all links of given type
func (obj *GlobalProjectConfig) GetAllServiceLevelObjectives(ctx context.Context) (
	result []*GlobalServiceLevelObjective, err error) {
	result = make([]*GlobalServiceLevelObjective, 0, len(obj.Spec.ServiceLevelObjectivesGvk))
	for _, v := range obj.Spec.ServiceLevelObjectivesGvk {
		l, err := obj.client.Global().GetServiceLevelObjectiveByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceLevelObjectives returns link which has given displayName
func (obj *GlobalProjectConfig) GetServiceLevelObjectives(ctx context.Context,
	displayName string) (result *GlobalServiceLevelObjective, err error) {
	l, ok := obj.Spec.ServiceLevelObjectivesGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ProjectConfig", "ServiceLevelObjectives", displayName)
	}
	result, err = obj.client.Global().GetServiceLevelObjectiveByName(ctx, l.Name)
	return
}

// LinkServiceLevelObjectives links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalProjectConfig) LinkServiceLevelObjectives(ctx context.Context,
	linkToAdd *GlobalServiceLevelObjective) error {

	payload := "{\"spec\": {\"serviceLevelObjectivesGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceLevelObjective\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectConfigs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ProjectConfig = result
	return nil
}

// UnlinkServiceLevelObjectives unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalProjectConfig) UnlinkServiceLevelObjectives(ctx context.Context,
	linkToRemove *GlobalServiceLevelObjective) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceLevelObjectivesGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ProjectConfig = result
	return nil

}

type projectconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *projectconfigGlobalTsmV1Chainer) Subscribe() {
	key := "projectconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewProjectConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *projectconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "projectconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *projectconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "projectconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *projectconfigGlobalTsmV1Chainer) CertificateAuthorities(name string) *certificateauthorityconfignGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["certificateauthorityconfigns.global.tsm.tanzu.vmware.com"] = name
	return &certificateauthorityconfignGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetCertificateAuthorities calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *projectconfigGlobalTsmV1Chainer) GetCertificateAuthorities(ctx context.Context, displayName string) (result *GlobalCertificateAuthorityConfigN, err error) {
	hashedName := helper.GetHashedName("certificateauthorityconfigns.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetCertificateAuthorityConfigNByName(ctx, hashedName)
}

// AddCertificateAuthorities calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *projectconfigGlobalTsmV1Chainer) AddCertificateAuthorities(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.CertificateAuthorityConfigN) (result *GlobalCertificateAuthorityConfigN, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("certificateauthorityconfigns.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateCertificateAuthorityConfigNByName(ctx, objToCreate)
}

// DeleteCertificateAuthorities calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *projectconfigGlobalTsmV1Chainer) DeleteCertificateAuthorities(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("certificateauthorityconfigns.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteCertificateAuthorityConfigNByName(ctx, hashedName)
}

// GetProjectInventoryByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetProjectInventoryByName(ctx context.Context, hashedName string) (*GlobalProjectInventory, error) {
	key := "projectinventories.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ProjectInventory)
		return &GlobalProjectInventory{
			client:           group.client,
			ProjectInventory: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ProjectInventories().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalProjectInventory{
			client:           group.client,
			ProjectInventory: result,
		}, nil
	}
}

// DeleteProjectInventoryByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteProjectInventoryByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ProjectInventories().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ProjectInventories().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/inventoryGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["projects.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("projects.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Projects().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateProjectInventoryByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateProjectInventoryByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ProjectInventory) (*GlobalProjectInventory, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ClustersGvk = nil
	objToCreate.Spec.ExternalDNSGvk = nil
	objToCreate.Spec.JobsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ProjectInventories().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["projects.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("projects.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/inventoryGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "ProjectInventory",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Projects().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalProjectInventory{
		client:           group.client,
		ProjectInventory: result,
	}, nil
}

// UpdateProjectInventoryByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateProjectInventoryByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ProjectInventory) (*GlobalProjectInventory, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ProjectInventories().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ProjectInventories().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalProjectInventory{
		client:           group.client,
		ProjectInventory: result,
	}, nil
}

// ListProjectInventories returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListProjectInventories(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalProjectInventory, err error) {
	key := "projectinventories.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalProjectInventory, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ProjectInventory)
			result[k] = &GlobalProjectInventory{
				client:           group.client,
				ProjectInventory: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ProjectInventories().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalProjectInventory, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalProjectInventory{
				client:           group.client,
				ProjectInventory: &item,
			}
		}
	}
	return
}

type GlobalProjectInventory struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ProjectInventory
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalProjectInventory) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteProjectInventoryByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ProjectInventory = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalProjectInventory) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateProjectInventoryByName(ctx, obj.ProjectInventory)
	if err != nil {
		return err
	}
	obj.ProjectInventory = result.ProjectInventory
	return nil
}

func (obj *GlobalProjectInventory) GetParent(ctx context.Context) (result *GlobalProject, err error) {
	hashedName := helper.GetHashedName("projects.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["projects.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetProjectByName(ctx, hashedName)
}

// GetAllClusters returns all links of given type
func (obj *GlobalProjectInventory) GetAllClusters(ctx context.Context) (
	result []*GlobalCluster, err error) {
	result = make([]*GlobalCluster, 0, len(obj.Spec.ClustersGvk))
	for _, v := range obj.Spec.ClustersGvk {
		l, err := obj.client.Global().GetClusterByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetClusters returns link which has given displayName
func (obj *GlobalProjectInventory) GetClusters(ctx context.Context,
	displayName string) (result *GlobalCluster, err error) {
	l, ok := obj.Spec.ClustersGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ProjectInventory", "Clusters", displayName)
	}
	result, err = obj.client.Global().GetClusterByName(ctx, l.Name)
	return
}

// LinkClusters links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalProjectInventory) LinkClusters(ctx context.Context,
	linkToAdd *GlobalCluster) error {

	payload := "{\"spec\": {\"clustersGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"Cluster\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectInventories().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ProjectInventory = result
	return nil
}

// UnlinkClusters unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalProjectInventory) UnlinkClusters(ctx context.Context,
	linkToRemove *GlobalCluster) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/clustersGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectInventories().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ProjectInventory = result
	return nil

}

// GetAllExternalDNS returns all links of given type
func (obj *GlobalProjectInventory) GetAllExternalDNS(ctx context.Context) (
	result []*GlobalExternalDNSInventory, err error) {
	result = make([]*GlobalExternalDNSInventory, 0, len(obj.Spec.ExternalDNSGvk))
	for _, v := range obj.Spec.ExternalDNSGvk {
		l, err := obj.client.Global().GetExternalDNSInventoryByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetExternalDNS returns link which has given displayName
func (obj *GlobalProjectInventory) GetExternalDNS(ctx context.Context,
	displayName string) (result *GlobalExternalDNSInventory, err error) {
	l, ok := obj.Spec.ExternalDNSGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ProjectInventory", "ExternalDNS", displayName)
	}
	result, err = obj.client.Global().GetExternalDNSInventoryByName(ctx, l.Name)
	return
}

// LinkExternalDNS links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalProjectInventory) LinkExternalDNS(ctx context.Context,
	linkToAdd *GlobalExternalDNSInventory) error {

	payload := "{\"spec\": {\"externalDNSGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ExternalDNSInventory\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectInventories().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ProjectInventory = result
	return nil
}

// UnlinkExternalDNS unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalProjectInventory) UnlinkExternalDNS(ctx context.Context,
	linkToRemove *GlobalExternalDNSInventory) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/externalDNSGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectInventories().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ProjectInventory = result
	return nil

}

// GetAllJobs returns all links of given type
func (obj *GlobalProjectInventory) GetAllJobs(ctx context.Context) (
	result []*GlobalJob, err error) {
	result = make([]*GlobalJob, 0, len(obj.Spec.JobsGvk))
	for _, v := range obj.Spec.JobsGvk {
		l, err := obj.client.Global().GetJobByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetJobs returns link which has given displayName
func (obj *GlobalProjectInventory) GetJobs(ctx context.Context,
	displayName string) (result *GlobalJob, err error) {
	l, ok := obj.Spec.JobsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ProjectInventory", "Jobs", displayName)
	}
	result, err = obj.client.Global().GetJobByName(ctx, l.Name)
	return
}

// LinkJobs links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalProjectInventory) LinkJobs(ctx context.Context,
	linkToAdd *GlobalJob) error {

	payload := "{\"spec\": {\"jobsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"Job\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectInventories().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ProjectInventory = result
	return nil
}

// UnlinkJobs unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalProjectInventory) UnlinkJobs(ctx context.Context,
	linkToRemove *GlobalJob) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/jobsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ProjectInventories().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ProjectInventory = result
	return nil

}

type projectinventoryGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *projectinventoryGlobalTsmV1Chainer) Subscribe() {
	key := "projectinventories.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewProjectInventoryInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *projectinventoryGlobalTsmV1Chainer) Unsubscribe() {
	key := "projectinventories.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *projectinventoryGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "projectinventories.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetProjectQueryByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetProjectQueryByName(ctx context.Context, hashedName string) (*GlobalProjectQuery, error) {
	key := "projectqueries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ProjectQuery)
		return &GlobalProjectQuery{
			client:       group.client,
			ProjectQuery: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ProjectQueries().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalProjectQuery{
			client:       group.client,
			ProjectQuery: result,
		}, nil
	}
}

// DeleteProjectQueryByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteProjectQueryByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ProjectQueries().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ProjectQueries().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/queryGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["projects.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("projects.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Projects().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateProjectQueryByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateProjectQueryByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ProjectQuery) (*GlobalProjectQuery, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ProjectQueries().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["projects.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("projects.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/queryGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "ProjectQuery",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Projects().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalProjectQuery{
		client:       group.client,
		ProjectQuery: result,
	}, nil
}

// UpdateProjectQueryByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateProjectQueryByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ProjectQuery) (*GlobalProjectQuery, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ProjectQueries().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ProjectQueries().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalProjectQuery{
		client:       group.client,
		ProjectQuery: result,
	}, nil
}

// ListProjectQueries returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListProjectQueries(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalProjectQuery, err error) {
	key := "projectqueries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalProjectQuery, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ProjectQuery)
			result[k] = &GlobalProjectQuery{
				client:       group.client,
				ProjectQuery: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ProjectQueries().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalProjectQuery, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalProjectQuery{
				client:       group.client,
				ProjectQuery: &item,
			}
		}
	}
	return
}

type GlobalProjectQuery struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ProjectQuery
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalProjectQuery) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteProjectQueryByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ProjectQuery = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalProjectQuery) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateProjectQueryByName(ctx, obj.ProjectQuery)
	if err != nil {
		return err
	}
	obj.ProjectQuery = result.ProjectQuery
	return nil
}

func (obj *GlobalProjectQuery) GetParent(ctx context.Context) (result *GlobalProject, err error) {
	hashedName := helper.GetHashedName("projects.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["projects.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetProjectByName(ctx, hashedName)
}

type projectqueryGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *projectqueryGlobalTsmV1Chainer) Subscribe() {
	key := "projectqueries.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewProjectQueryInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *projectqueryGlobalTsmV1Chainer) Unsubscribe() {
	key := "projectqueries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *projectqueryGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "projectqueries.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetProjectByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetProjectByName(ctx context.Context, hashedName string) (*GlobalProject, error) {
	key := "projects.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Project)
		return &GlobalProject{
			client:  group.client,
			Project: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Projects().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalProject{
			client:  group.client,
			Project: result,
		}, nil
	}
}

// DeleteProjectByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteProjectByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Projects().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.ConfigGvk != nil {
		err := group.client.
			Global().
			DeleteProjectConfigByName(ctx, result.Spec.ConfigGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.InventoryGvk != nil {
		err := group.client.
			Global().
			DeleteProjectInventoryByName(ctx, result.Spec.InventoryGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.QueryGvk != nil {
		err := group.client.
			Global().
			DeleteProjectQueryByName(ctx, result.Spec.QueryGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Projects().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/projectsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateProjectByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateProjectByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Project) (*GlobalProject, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ConfigGvk = nil
	objToCreate.Spec.InventoryGvk = nil
	objToCreate.Spec.QueryGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Projects().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"projectsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"Project\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalProject{
		client:  group.client,
		Project: result,
	}, nil
}

// UpdateProjectByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateProjectByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Project) (*GlobalProject, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Projects().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Projects().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalProject{
		client:  group.client,
		Project: result,
	}, nil
}

// ListProjects returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListProjects(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalProject, err error) {
	key := "projects.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalProject, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Project)
			result[k] = &GlobalProject{
				client:  group.client,
				Project: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Projects().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalProject, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalProject{
				client:  group.client,
				Project: &item,
			}
		}
	}
	return
}

type GlobalProject struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Project
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalProject) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteProjectByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Project = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalProject) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateProjectByName(ctx, obj.Project)
	if err != nil {
		return err
	}
	obj.Project = result.Project
	return nil
}

func (obj *GlobalProject) GetParent(ctx context.Context) (result *GlobalConfig, err error) {
	hashedName := helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetConfigByName(ctx, hashedName)
}

// GetConfig returns child of given type
func (obj *GlobalProject) GetConfig(ctx context.Context) (
	result *GlobalProjectConfig, err error) {
	if obj.Spec.ConfigGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Project", "Config")
	}
	return obj.client.Global().GetProjectConfigByName(ctx, obj.Spec.ConfigGvk.Name)
}

// AddConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalProject) AddConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ProjectConfig) (result *GlobalProjectConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["projects.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["projects.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateProjectConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetProjectByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Project = updatedObj.Project
	}
	return
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalProject) DeleteConfig(ctx context.Context) (err error) {
	if obj.Spec.ConfigGvk != nil {
		err = obj.client.
			Global().DeleteProjectConfigByName(ctx, obj.Spec.ConfigGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetProjectByName(ctx, obj.GetName())
	if err == nil {
		obj.Project = updatedObj.Project
	}
	return
}

// GetInventory returns child of given type
func (obj *GlobalProject) GetInventory(ctx context.Context) (
	result *GlobalProjectInventory, err error) {
	if obj.Spec.InventoryGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Project", "Inventory")
	}
	return obj.client.Global().GetProjectInventoryByName(ctx, obj.Spec.InventoryGvk.Name)
}

// AddInventory calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalProject) AddInventory(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ProjectInventory) (result *GlobalProjectInventory, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["projects.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["projects.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateProjectInventoryByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetProjectByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Project = updatedObj.Project
	}
	return
}

// DeleteInventory calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalProject) DeleteInventory(ctx context.Context) (err error) {
	if obj.Spec.InventoryGvk != nil {
		err = obj.client.
			Global().DeleteProjectInventoryByName(ctx, obj.Spec.InventoryGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetProjectByName(ctx, obj.GetName())
	if err == nil {
		obj.Project = updatedObj.Project
	}
	return
}

// GetQuery returns child of given type
func (obj *GlobalProject) GetQuery(ctx context.Context) (
	result *GlobalProjectQuery, err error) {
	if obj.Spec.QueryGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Project", "Query")
	}
	return obj.client.Global().GetProjectQueryByName(ctx, obj.Spec.QueryGvk.Name)
}

// AddQuery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalProject) AddQuery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ProjectQuery) (result *GlobalProjectQuery, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["projects.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["projects.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateProjectQueryByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetProjectByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Project = updatedObj.Project
	}
	return
}

// DeleteQuery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalProject) DeleteQuery(ctx context.Context) (err error) {
	if obj.Spec.QueryGvk != nil {
		err = obj.client.
			Global().DeleteProjectQueryByName(ctx, obj.Spec.QueryGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetProjectByName(ctx, obj.GetName())
	if err == nil {
		obj.Project = updatedObj.Project
	}
	return
}

type projectGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *projectGlobalTsmV1Chainer) Subscribe() {
	key := "projects.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewProjectInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *projectGlobalTsmV1Chainer) Unsubscribe() {
	key := "projects.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *projectGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "projects.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *projectGlobalTsmV1Chainer) Config(name string) *projectconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["projectconfigs.global.tsm.tanzu.vmware.com"] = name
	return &projectconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetConfig calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *projectGlobalTsmV1Chainer) GetConfig(ctx context.Context, displayName string) (result *GlobalProjectConfig, err error) {
	hashedName := helper.GetHashedName("projectconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetProjectConfigByName(ctx, hashedName)
}

// AddConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *projectGlobalTsmV1Chainer) AddConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ProjectConfig) (result *GlobalProjectConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("projectconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateProjectConfigByName(ctx, objToCreate)
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *projectGlobalTsmV1Chainer) DeleteConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("projectconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteProjectConfigByName(ctx, hashedName)
}

func (c *projectGlobalTsmV1Chainer) Inventory(name string) *projectinventoryGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["projectinventories.global.tsm.tanzu.vmware.com"] = name
	return &projectinventoryGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetInventory calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *projectGlobalTsmV1Chainer) GetInventory(ctx context.Context, displayName string) (result *GlobalProjectInventory, err error) {
	hashedName := helper.GetHashedName("projectinventories.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetProjectInventoryByName(ctx, hashedName)
}

// AddInventory calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *projectGlobalTsmV1Chainer) AddInventory(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ProjectInventory) (result *GlobalProjectInventory, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("projectinventories.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateProjectInventoryByName(ctx, objToCreate)
}

// DeleteInventory calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *projectGlobalTsmV1Chainer) DeleteInventory(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("projectinventories.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteProjectInventoryByName(ctx, hashedName)
}

func (c *projectGlobalTsmV1Chainer) Query(name string) *projectqueryGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["projectqueries.global.tsm.tanzu.vmware.com"] = name
	return &projectqueryGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetQuery calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *projectGlobalTsmV1Chainer) GetQuery(ctx context.Context, displayName string) (result *GlobalProjectQuery, err error) {
	hashedName := helper.GetHashedName("projectqueries.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetProjectQueryByName(ctx, hashedName)
}

// AddQuery calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *projectGlobalTsmV1Chainer) AddQuery(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ProjectQuery) (result *GlobalProjectQuery, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("projectqueries.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateProjectQueryByName(ctx, objToCreate)
}

// DeleteQuery calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *projectGlobalTsmV1Chainer) DeleteQuery(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("projectqueries.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteProjectQueryByName(ctx, hashedName)
}

// GetPublicServiceRTByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetPublicServiceRTByName(ctx context.Context, hashedName string) (*GlobalPublicServiceRT, error) {
	key := "publicservicerts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.PublicServiceRT)
		return &GlobalPublicServiceRT{
			client:          group.client,
			PublicServiceRT: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			PublicServiceRTs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalPublicServiceRT{
			client:          group.client,
			PublicServiceRT: result,
		}, nil
	}
}

// DeletePublicServiceRTByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeletePublicServiceRTByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		PublicServiceRTs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		PublicServiceRTs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/publicServiceGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreatePublicServiceRTByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreatePublicServiceRTByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PublicServiceRT) (*GlobalPublicServiceRT, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		PublicServiceRTs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"publicServiceGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"PublicServiceRT\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalPublicServiceRT{
		client:          group.client,
		PublicServiceRT: result,
	}, nil
}

// UpdatePublicServiceRTByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdatePublicServiceRTByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.PublicServiceRT) (*GlobalPublicServiceRT, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			PublicServiceRTs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueOwnedBy :=
		objToUpdate.Spec.OwnedBy
	patchOpOwnedBy := PatchOp{
		Op:    "replace",
		Path:  "/spec/ownedBy",
		Value: patchValueOwnedBy,
	}
	patch = append(patch, patchOpOwnedBy)

	if objToUpdate.Spec.FqdnList != nil {
		patchValueFqdnList :=
			objToUpdate.Spec.FqdnList
		patchOpFqdnList := PatchOp{
			Op:    "replace",
			Path:  "/spec/fqdnList",
			Value: patchValueFqdnList,
		}
		patch = append(patch, patchOpFqdnList)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		PublicServiceRTs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalPublicServiceRT{
		client:          group.client,
		PublicServiceRT: result,
	}, nil
}

// ListPublicServiceRTs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListPublicServiceRTs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalPublicServiceRT, err error) {
	key := "publicservicerts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalPublicServiceRT, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.PublicServiceRT)
			result[k] = &GlobalPublicServiceRT{
				client:          group.client,
				PublicServiceRT: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			PublicServiceRTs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalPublicServiceRT, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalPublicServiceRT{
				client:          group.client,
				PublicServiceRT: &item,
			}
		}
	}
	return
}

type GlobalPublicServiceRT struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.PublicServiceRT
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalPublicServiceRT) Delete(ctx context.Context) error {
	err := obj.client.Global().DeletePublicServiceRTByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.PublicServiceRT = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalPublicServiceRT) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdatePublicServiceRTByName(ctx, obj.PublicServiceRT)
	if err != nil {
		return err
	}
	obj.PublicServiceRT = result.PublicServiceRT
	return nil
}

func (obj *GlobalPublicServiceRT) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

type publicservicertGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *publicservicertGlobalTsmV1Chainer) Subscribe() {
	key := "publicservicerts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewPublicServiceRTInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *publicservicertGlobalTsmV1Chainer) Unsubscribe() {
	key := "publicservicerts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *publicservicertGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "publicservicerts.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetRemoteGatewayServiceConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetRemoteGatewayServiceConfigByName(ctx context.Context, hashedName string) (*GlobalRemoteGatewayServiceConfig, error) {
	key := "remotegatewayserviceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.RemoteGatewayServiceConfig)
		return &GlobalRemoteGatewayServiceConfig{
			client:                     group.client,
			RemoteGatewayServiceConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			RemoteGatewayServiceConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalRemoteGatewayServiceConfig{
			client:                     group.client,
			RemoteGatewayServiceConfig: result,
		}, nil
	}
}

// DeleteRemoteGatewayServiceConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteRemoteGatewayServiceConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		RemoteGatewayServiceConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		RemoteGatewayServiceConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/remoteGatewayServiceConfigsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["clusterfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusterfolders.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ClusterFolders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateRemoteGatewayServiceConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateRemoteGatewayServiceConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.RemoteGatewayServiceConfig) (*GlobalRemoteGatewayServiceConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		RemoteGatewayServiceConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["clusterfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusterfolders.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"remoteGatewayServiceConfigsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"RemoteGatewayServiceConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ClusterFolders().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalRemoteGatewayServiceConfig{
		client:                     group.client,
		RemoteGatewayServiceConfig: result,
	}, nil
}

// UpdateRemoteGatewayServiceConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateRemoteGatewayServiceConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.RemoteGatewayServiceConfig) (*GlobalRemoteGatewayServiceConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			RemoteGatewayServiceConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueOwnedBy :=
		objToUpdate.Spec.OwnedBy
	patchOpOwnedBy := PatchOp{
		Op:    "replace",
		Path:  "/spec/ownedBy",
		Value: patchValueOwnedBy,
	}
	patch = append(patch, patchOpOwnedBy)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueNodeIPs :=
		objToUpdate.Spec.NodeIPs
	patchOpNodeIPs := PatchOp{
		Op:    "replace",
		Path:  "/spec/nodeIPs",
		Value: patchValueNodeIPs,
	}
	patch = append(patch, patchOpNodeIPs)

	patchValuePorts :=
		objToUpdate.Spec.Ports
	patchOpPorts := PatchOp{
		Op:    "replace",
		Path:  "/spec/ports",
		Value: patchValuePorts,
	}
	patch = append(patch, patchOpPorts)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		RemoteGatewayServiceConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalRemoteGatewayServiceConfig{
		client:                     group.client,
		RemoteGatewayServiceConfig: result,
	}, nil
}

// ListRemoteGatewayServiceConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListRemoteGatewayServiceConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalRemoteGatewayServiceConfig, err error) {
	key := "remotegatewayserviceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalRemoteGatewayServiceConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.RemoteGatewayServiceConfig)
			result[k] = &GlobalRemoteGatewayServiceConfig{
				client:                     group.client,
				RemoteGatewayServiceConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			RemoteGatewayServiceConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalRemoteGatewayServiceConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalRemoteGatewayServiceConfig{
				client:                     group.client,
				RemoteGatewayServiceConfig: &item,
			}
		}
	}
	return
}

type GlobalRemoteGatewayServiceConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.RemoteGatewayServiceConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalRemoteGatewayServiceConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteRemoteGatewayServiceConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.RemoteGatewayServiceConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalRemoteGatewayServiceConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateRemoteGatewayServiceConfigByName(ctx, obj.RemoteGatewayServiceConfig)
	if err != nil {
		return err
	}
	obj.RemoteGatewayServiceConfig = result.RemoteGatewayServiceConfig
	return nil
}

func (obj *GlobalRemoteGatewayServiceConfig) GetParent(ctx context.Context) (result *GlobalClusterFolder, err error) {
	hashedName := helper.GetHashedName("clusterfolders.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["clusterfolders.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetClusterFolderByName(ctx, hashedName)
}

type remotegatewayserviceconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *remotegatewayserviceconfigGlobalTsmV1Chainer) Subscribe() {
	key := "remotegatewayserviceconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewRemoteGatewayServiceConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *remotegatewayserviceconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "remotegatewayserviceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *remotegatewayserviceconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "remotegatewayserviceconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetResourceGroupRTByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetResourceGroupRTByName(ctx context.Context, hashedName string) (*GlobalResourceGroupRT, error) {
	key := "resourcegrouprts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ResourceGroupRT)
		return &GlobalResourceGroupRT{
			client:          group.client,
			ResourceGroupRT: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ResourceGroupRTs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalResourceGroupRT{
			client:          group.client,
			ResourceGroupRT: result,
		}, nil
	}
}

// DeleteResourceGroupRTByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteResourceGroupRTByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ResourceGroupRTs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.SvcGroupRTGvk {
		err := group.client.
			Global().DeleteSvcGroupRTByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ResourceGroupRTs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/resourceGroupGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["clusterconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateResourceGroupRTByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateResourceGroupRTByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ResourceGroupRT) (*GlobalResourceGroupRT, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.SvcGroupRTGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ResourceGroupRTs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["clusterconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/resourceGroupGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "ResourceGroupRT",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalResourceGroupRT{
		client:          group.client,
		ResourceGroupRT: result,
	}, nil
}

// UpdateResourceGroupRTByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateResourceGroupRTByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ResourceGroupRT) (*GlobalResourceGroupRT, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ResourceGroupRTs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ResourceGroupRTs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalResourceGroupRT{
		client:          group.client,
		ResourceGroupRT: result,
	}, nil
}

// ListResourceGroupRTs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListResourceGroupRTs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalResourceGroupRT, err error) {
	key := "resourcegrouprts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalResourceGroupRT, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ResourceGroupRT)
			result[k] = &GlobalResourceGroupRT{
				client:          group.client,
				ResourceGroupRT: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ResourceGroupRTs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalResourceGroupRT, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalResourceGroupRT{
				client:          group.client,
				ResourceGroupRT: &item,
			}
		}
	}
	return
}

type GlobalResourceGroupRT struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ResourceGroupRT
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalResourceGroupRT) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteResourceGroupRTByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ResourceGroupRT = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalResourceGroupRT) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateResourceGroupRTByName(ctx, obj.ResourceGroupRT)
	if err != nil {
		return err
	}
	obj.ResourceGroupRT = result.ResourceGroupRT
	return nil
}

func (obj *GlobalResourceGroupRT) GetParent(ctx context.Context) (result *GlobalClusterConfig, err error) {
	hashedName := helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["clusterconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetClusterConfigByName(ctx, hashedName)
}

// GetAllSvcGroupRT returns all children of given type
func (obj *GlobalResourceGroupRT) GetAllSvcGroupRT(ctx context.Context) (
	result []*GlobalSvcGroupRT, err error) {
	result = make([]*GlobalSvcGroupRT, 0, len(obj.Spec.SvcGroupRTGvk))
	for _, v := range obj.Spec.SvcGroupRTGvk {
		l, err := obj.client.Global().GetSvcGroupRTByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetSvcGroupRT returns child which has given displayName
func (obj *GlobalResourceGroupRT) GetSvcGroupRT(ctx context.Context,
	displayName string) (result *GlobalSvcGroupRT, err error) {
	l, ok := obj.Spec.SvcGroupRTGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ResourceGroupRT", "SvcGroupRT", displayName)
	}
	result, err = obj.client.Global().GetSvcGroupRTByName(ctx, l.Name)
	return
}

// AddSvcGroupRT calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalResourceGroupRT) AddSvcGroupRT(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SvcGroupRT) (result *GlobalSvcGroupRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["resourcegrouprts.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["resourcegrouprts.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateSvcGroupRTByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetResourceGroupRTByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ResourceGroupRT = updatedObj.ResourceGroupRT
	}
	return
}

// DeleteSvcGroupRT calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalResourceGroupRT) DeleteSvcGroupRT(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.SvcGroupRTGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ResourceGroupRT", "SvcGroupRT", displayName)
	}
	err = obj.client.Global().DeleteSvcGroupRTByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetResourceGroupRTByName(ctx, obj.GetName())
	if err == nil {
		obj.ResourceGroupRT = updatedObj.ResourceGroupRT
	}
	return
}

type resourcegrouprtGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *resourcegrouprtGlobalTsmV1Chainer) Subscribe() {
	key := "resourcegrouprts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewResourceGroupRTInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *resourcegrouprtGlobalTsmV1Chainer) Unsubscribe() {
	key := "resourcegrouprts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *resourcegrouprtGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "resourcegrouprts.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *resourcegrouprtGlobalTsmV1Chainer) SvcGroupRT(name string) *svcgrouprtGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["svcgrouprts.global.tsm.tanzu.vmware.com"] = name
	return &svcgrouprtGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetSvcGroupRT calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *resourcegrouprtGlobalTsmV1Chainer) GetSvcGroupRT(ctx context.Context, displayName string) (result *GlobalSvcGroupRT, err error) {
	hashedName := helper.GetHashedName("svcgrouprts.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetSvcGroupRTByName(ctx, hashedName)
}

// AddSvcGroupRT calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *resourcegrouprtGlobalTsmV1Chainer) AddSvcGroupRT(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SvcGroupRT) (result *GlobalSvcGroupRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("svcgrouprts.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateSvcGroupRTByName(ctx, objToCreate)
}

// DeleteSvcGroupRT calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *resourcegrouprtGlobalTsmV1Chainer) DeleteSvcGroupRT(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("svcgrouprts.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteSvcGroupRTByName(ctx, hashedName)
}

// GetResourceGroupByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetResourceGroupByName(ctx context.Context, hashedName string) (*GlobalResourceGroup, error) {
	key := "resourcegroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ResourceGroup)
		return &GlobalResourceGroup{
			client:        group.client,
			ResourceGroup: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ResourceGroups().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalResourceGroup{
			client:        group.client,
			ResourceGroup: result,
		}, nil
	}
}

// DeleteResourceGroupByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteResourceGroupByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ResourceGroups().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.AppGroupsGvk {
		err := group.client.
			Global().DeleteAppGroupByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.SvcGroupsGvk {
		err := group.client.
			Global().DeleteSvcGroupByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.NodeGroupsGvk {
		err := group.client.
			Global().DeleteNodeGroupByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.DataGroupsGvk {
		err := group.client.
			Global().DeleteDataGroupByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.UserGroupsGvk {
		err := group.client.
			Global().DeleteUserGroupByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ResourceGroups().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/resourceGroupsGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateResourceGroupByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateResourceGroupByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ResourceGroup) (*GlobalResourceGroup, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.AppGroupsGvk = nil
	objToCreate.Spec.SvcGroupsGvk = nil
	objToCreate.Spec.NodeGroupsGvk = nil
	objToCreate.Spec.DataGroupsGvk = nil
	objToCreate.Spec.UserGroupsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ResourceGroups().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/resourceGroupsGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "ResourceGroup",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalResourceGroup{
		client:        group.client,
		ResourceGroup: result,
	}, nil
}

// UpdateResourceGroupByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateResourceGroupByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ResourceGroup) (*GlobalResourceGroup, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ResourceGroups().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ResourceGroups().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalResourceGroup{
		client:        group.client,
		ResourceGroup: result,
	}, nil
}

// ListResourceGroups returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListResourceGroups(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalResourceGroup, err error) {
	key := "resourcegroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalResourceGroup, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ResourceGroup)
			result[k] = &GlobalResourceGroup{
				client:        group.client,
				ResourceGroup: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ResourceGroups().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalResourceGroup, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalResourceGroup{
				client:        group.client,
				ResourceGroup: &item,
			}
		}
	}
	return
}

type GlobalResourceGroup struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ResourceGroup
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalResourceGroup) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteResourceGroupByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ResourceGroup = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalResourceGroup) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateResourceGroupByName(ctx, obj.ResourceGroup)
	if err != nil {
		return err
	}
	obj.ResourceGroup = result.ResourceGroup
	return nil
}

func (obj *GlobalResourceGroup) GetParent(ctx context.Context) (result *GlobalConfig, err error) {
	hashedName := helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetConfigByName(ctx, hashedName)
}

// GetAllAppGroups returns all children of given type
func (obj *GlobalResourceGroup) GetAllAppGroups(ctx context.Context) (
	result []*GlobalAppGroup, err error) {
	result = make([]*GlobalAppGroup, 0, len(obj.Spec.AppGroupsGvk))
	for _, v := range obj.Spec.AppGroupsGvk {
		l, err := obj.client.Global().GetAppGroupByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetAppGroups returns child which has given displayName
func (obj *GlobalResourceGroup) GetAppGroups(ctx context.Context,
	displayName string) (result *GlobalAppGroup, err error) {
	l, ok := obj.Spec.AppGroupsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ResourceGroup", "AppGroups", displayName)
	}
	result, err = obj.client.Global().GetAppGroupByName(ctx, l.Name)
	return
}

// AddAppGroups calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalResourceGroup) AddAppGroups(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AppGroup) (result *GlobalAppGroup, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["resourcegroups.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["resourcegroups.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateAppGroupByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetResourceGroupByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ResourceGroup = updatedObj.ResourceGroup
	}
	return
}

// DeleteAppGroups calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalResourceGroup) DeleteAppGroups(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.AppGroupsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ResourceGroup", "AppGroups", displayName)
	}
	err = obj.client.Global().DeleteAppGroupByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetResourceGroupByName(ctx, obj.GetName())
	if err == nil {
		obj.ResourceGroup = updatedObj.ResourceGroup
	}
	return
}

// GetAllSvcGroups returns all children of given type
func (obj *GlobalResourceGroup) GetAllSvcGroups(ctx context.Context) (
	result []*GlobalSvcGroup, err error) {
	result = make([]*GlobalSvcGroup, 0, len(obj.Spec.SvcGroupsGvk))
	for _, v := range obj.Spec.SvcGroupsGvk {
		l, err := obj.client.Global().GetSvcGroupByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetSvcGroups returns child which has given displayName
func (obj *GlobalResourceGroup) GetSvcGroups(ctx context.Context,
	displayName string) (result *GlobalSvcGroup, err error) {
	l, ok := obj.Spec.SvcGroupsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ResourceGroup", "SvcGroups", displayName)
	}
	result, err = obj.client.Global().GetSvcGroupByName(ctx, l.Name)
	return
}

// AddSvcGroups calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalResourceGroup) AddSvcGroups(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SvcGroup) (result *GlobalSvcGroup, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["resourcegroups.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["resourcegroups.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateSvcGroupByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetResourceGroupByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ResourceGroup = updatedObj.ResourceGroup
	}
	return
}

// DeleteSvcGroups calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalResourceGroup) DeleteSvcGroups(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.SvcGroupsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ResourceGroup", "SvcGroups", displayName)
	}
	err = obj.client.Global().DeleteSvcGroupByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetResourceGroupByName(ctx, obj.GetName())
	if err == nil {
		obj.ResourceGroup = updatedObj.ResourceGroup
	}
	return
}

// GetAllNodeGroups returns all children of given type
func (obj *GlobalResourceGroup) GetAllNodeGroups(ctx context.Context) (
	result []*GlobalNodeGroup, err error) {
	result = make([]*GlobalNodeGroup, 0, len(obj.Spec.NodeGroupsGvk))
	for _, v := range obj.Spec.NodeGroupsGvk {
		l, err := obj.client.Global().GetNodeGroupByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetNodeGroups returns child which has given displayName
func (obj *GlobalResourceGroup) GetNodeGroups(ctx context.Context,
	displayName string) (result *GlobalNodeGroup, err error) {
	l, ok := obj.Spec.NodeGroupsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ResourceGroup", "NodeGroups", displayName)
	}
	result, err = obj.client.Global().GetNodeGroupByName(ctx, l.Name)
	return
}

// AddNodeGroups calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalResourceGroup) AddNodeGroups(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NodeGroup) (result *GlobalNodeGroup, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["resourcegroups.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["resourcegroups.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateNodeGroupByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetResourceGroupByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ResourceGroup = updatedObj.ResourceGroup
	}
	return
}

// DeleteNodeGroups calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalResourceGroup) DeleteNodeGroups(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.NodeGroupsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ResourceGroup", "NodeGroups", displayName)
	}
	err = obj.client.Global().DeleteNodeGroupByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetResourceGroupByName(ctx, obj.GetName())
	if err == nil {
		obj.ResourceGroup = updatedObj.ResourceGroup
	}
	return
}

// GetAllDataGroups returns all children of given type
func (obj *GlobalResourceGroup) GetAllDataGroups(ctx context.Context) (
	result []*GlobalDataGroup, err error) {
	result = make([]*GlobalDataGroup, 0, len(obj.Spec.DataGroupsGvk))
	for _, v := range obj.Spec.DataGroupsGvk {
		l, err := obj.client.Global().GetDataGroupByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetDataGroups returns child which has given displayName
func (obj *GlobalResourceGroup) GetDataGroups(ctx context.Context,
	displayName string) (result *GlobalDataGroup, err error) {
	l, ok := obj.Spec.DataGroupsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ResourceGroup", "DataGroups", displayName)
	}
	result, err = obj.client.Global().GetDataGroupByName(ctx, l.Name)
	return
}

// AddDataGroups calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalResourceGroup) AddDataGroups(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DataGroup) (result *GlobalDataGroup, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["resourcegroups.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["resourcegroups.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateDataGroupByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetResourceGroupByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ResourceGroup = updatedObj.ResourceGroup
	}
	return
}

// DeleteDataGroups calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalResourceGroup) DeleteDataGroups(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.DataGroupsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ResourceGroup", "DataGroups", displayName)
	}
	err = obj.client.Global().DeleteDataGroupByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetResourceGroupByName(ctx, obj.GetName())
	if err == nil {
		obj.ResourceGroup = updatedObj.ResourceGroup
	}
	return
}

// GetAllUserGroups returns all children of given type
func (obj *GlobalResourceGroup) GetAllUserGroups(ctx context.Context) (
	result []*GlobalUserGroup, err error) {
	result = make([]*GlobalUserGroup, 0, len(obj.Spec.UserGroupsGvk))
	for _, v := range obj.Spec.UserGroupsGvk {
		l, err := obj.client.Global().GetUserGroupByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetUserGroups returns child which has given displayName
func (obj *GlobalResourceGroup) GetUserGroups(ctx context.Context,
	displayName string) (result *GlobalUserGroup, err error) {
	l, ok := obj.Spec.UserGroupsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ResourceGroup", "UserGroups", displayName)
	}
	result, err = obj.client.Global().GetUserGroupByName(ctx, l.Name)
	return
}

// AddUserGroups calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalResourceGroup) AddUserGroups(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.UserGroup) (result *GlobalUserGroup, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["resourcegroups.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["resourcegroups.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateUserGroupByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetResourceGroupByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ResourceGroup = updatedObj.ResourceGroup
	}
	return
}

// DeleteUserGroups calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalResourceGroup) DeleteUserGroups(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.UserGroupsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ResourceGroup", "UserGroups", displayName)
	}
	err = obj.client.Global().DeleteUserGroupByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetResourceGroupByName(ctx, obj.GetName())
	if err == nil {
		obj.ResourceGroup = updatedObj.ResourceGroup
	}
	return
}

type resourcegroupGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *resourcegroupGlobalTsmV1Chainer) Subscribe() {
	key := "resourcegroups.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewResourceGroupInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *resourcegroupGlobalTsmV1Chainer) Unsubscribe() {
	key := "resourcegroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *resourcegroupGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "resourcegroups.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *resourcegroupGlobalTsmV1Chainer) AppGroups(name string) *appgroupGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["appgroups.global.tsm.tanzu.vmware.com"] = name
	return &appgroupGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetAppGroups calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *resourcegroupGlobalTsmV1Chainer) GetAppGroups(ctx context.Context, displayName string) (result *GlobalAppGroup, err error) {
	hashedName := helper.GetHashedName("appgroups.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetAppGroupByName(ctx, hashedName)
}

// AddAppGroups calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *resourcegroupGlobalTsmV1Chainer) AddAppGroups(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AppGroup) (result *GlobalAppGroup, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("appgroups.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateAppGroupByName(ctx, objToCreate)
}

// DeleteAppGroups calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *resourcegroupGlobalTsmV1Chainer) DeleteAppGroups(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("appgroups.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteAppGroupByName(ctx, hashedName)
}

func (c *resourcegroupGlobalTsmV1Chainer) SvcGroups(name string) *svcgroupGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["svcgroups.global.tsm.tanzu.vmware.com"] = name
	return &svcgroupGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetSvcGroups calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *resourcegroupGlobalTsmV1Chainer) GetSvcGroups(ctx context.Context, displayName string) (result *GlobalSvcGroup, err error) {
	hashedName := helper.GetHashedName("svcgroups.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetSvcGroupByName(ctx, hashedName)
}

// AddSvcGroups calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *resourcegroupGlobalTsmV1Chainer) AddSvcGroups(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SvcGroup) (result *GlobalSvcGroup, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("svcgroups.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateSvcGroupByName(ctx, objToCreate)
}

// DeleteSvcGroups calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *resourcegroupGlobalTsmV1Chainer) DeleteSvcGroups(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("svcgroups.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteSvcGroupByName(ctx, hashedName)
}

func (c *resourcegroupGlobalTsmV1Chainer) NodeGroups(name string) *nodegroupGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["nodegroups.global.tsm.tanzu.vmware.com"] = name
	return &nodegroupGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetNodeGroups calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *resourcegroupGlobalTsmV1Chainer) GetNodeGroups(ctx context.Context, displayName string) (result *GlobalNodeGroup, err error) {
	hashedName := helper.GetHashedName("nodegroups.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetNodeGroupByName(ctx, hashedName)
}

// AddNodeGroups calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *resourcegroupGlobalTsmV1Chainer) AddNodeGroups(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NodeGroup) (result *GlobalNodeGroup, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("nodegroups.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateNodeGroupByName(ctx, objToCreate)
}

// DeleteNodeGroups calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *resourcegroupGlobalTsmV1Chainer) DeleteNodeGroups(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("nodegroups.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteNodeGroupByName(ctx, hashedName)
}

func (c *resourcegroupGlobalTsmV1Chainer) DataGroups(name string) *datagroupGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["datagroups.global.tsm.tanzu.vmware.com"] = name
	return &datagroupGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetDataGroups calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *resourcegroupGlobalTsmV1Chainer) GetDataGroups(ctx context.Context, displayName string) (result *GlobalDataGroup, err error) {
	hashedName := helper.GetHashedName("datagroups.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetDataGroupByName(ctx, hashedName)
}

// AddDataGroups calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *resourcegroupGlobalTsmV1Chainer) AddDataGroups(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DataGroup) (result *GlobalDataGroup, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("datagroups.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateDataGroupByName(ctx, objToCreate)
}

// DeleteDataGroups calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *resourcegroupGlobalTsmV1Chainer) DeleteDataGroups(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("datagroups.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteDataGroupByName(ctx, hashedName)
}

func (c *resourcegroupGlobalTsmV1Chainer) UserGroups(name string) *usergroupGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["usergroups.global.tsm.tanzu.vmware.com"] = name
	return &usergroupGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetUserGroups calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *resourcegroupGlobalTsmV1Chainer) GetUserGroups(ctx context.Context, displayName string) (result *GlobalUserGroup, err error) {
	hashedName := helper.GetHashedName("usergroups.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetUserGroupByName(ctx, hashedName)
}

// AddUserGroups calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *resourcegroupGlobalTsmV1Chainer) AddUserGroups(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.UserGroup) (result *GlobalUserGroup, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("usergroups.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateUserGroupByName(ctx, objToCreate)
}

// DeleteUserGroups calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *resourcegroupGlobalTsmV1Chainer) DeleteUserGroups(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("usergroups.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteUserGroupByName(ctx, hashedName)
}

// GetRootByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetRootByName(ctx context.Context, hashedName string) (*GlobalRoot, error) {
	key := "roots.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Root)
		return &GlobalRoot{
			client: group.client,
			Root:   result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Roots().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalRoot{
			client: group.client,
			Root:   result,
		}, nil
	}
}

// DeleteRootByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteRootByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Roots().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.ConfigGvk != nil {
		err := group.client.
			Global().
			DeleteConfigByName(ctx, result.Spec.ConfigGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.InventoryGvk != nil {
		err := group.client.
			Global().
			DeleteInventoryByName(ctx, result.Spec.InventoryGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.RuntimeGvk != nil {
		err := group.client.
			Global().
			DeleteRuntimeByName(ctx, result.Spec.RuntimeGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Roots().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateRootByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateRootByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Root) (*GlobalRoot, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.ConfigGvk = nil
	objToCreate.Spec.InventoryGvk = nil
	objToCreate.Spec.RuntimeGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Roots().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalRoot{
		client: group.client,
		Root:   result,
	}, nil
}

// UpdateRootByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateRootByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Root) (*GlobalRoot, error) {
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Roots().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Roots().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalRoot{
		client: group.client,
		Root:   result,
	}, nil
}

// ListRoots returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListRoots(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalRoot, err error) {
	key := "roots.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalRoot, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Root)
			result[k] = &GlobalRoot{
				client: group.client,
				Root:   item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Roots().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalRoot, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalRoot{
				client: group.client,
				Root:   &item,
			}
		}
	}
	return
}

type GlobalRoot struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Root
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalRoot) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteRootByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Root = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalRoot) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateRootByName(ctx, obj.Root)
	if err != nil {
		return err
	}
	obj.Root = result.Root
	return nil
}

// GetGlobalRoot calculates the hashed name based on parents and
// returns given object
func (c *Clientset) GetGlobalRoot(ctx context.Context) (result *GlobalRoot, err error) {
	hashedName := helper.GetHashedName("roots.global.tsm.tanzu.vmware.com", nil, helper.DEFAULT_KEY)
	return c.Global().GetRootByName(ctx, hashedName)
}

func (c *Clientset) GlobalRoot() *rootGlobalTsmV1Chainer {
	parentLabels := make(map[string]string)
	parentLabels["roots.global.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &rootGlobalTsmV1Chainer{
		client:       c,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// AddGlobalRoot calculates hashed name of the object based on
// parents names and creates it. objToCreate.Name is changed to the hashed name. Original name (helper.DEFAULT_KEY) is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) AddGlobalRoot(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Root) (result *GlobalRoot, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.Global().CreateRootByName(ctx, objToCreate)
}

// DeleteGlobalRoot calculates hashedName of object based on
// parents and deletes given object
func (c *Clientset) DeleteGlobalRoot(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("roots.global.tsm.tanzu.vmware.com", nil, helper.DEFAULT_KEY)
	return c.Global().DeleteRootByName(ctx, hashedName)
}

// GetConfig returns child of given type
func (obj *GlobalRoot) GetConfig(ctx context.Context) (
	result *GlobalConfig, err error) {
	if obj.Spec.ConfigGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Root", "Config")
	}
	return obj.client.Global().GetConfigByName(ctx, obj.Spec.ConfigGvk.Name)
}

// AddConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalRoot) AddConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Config) (result *GlobalConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["roots.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["roots.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetRootByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Root = updatedObj.Root
	}
	return
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalRoot) DeleteConfig(ctx context.Context) (err error) {
	if obj.Spec.ConfigGvk != nil {
		err = obj.client.
			Global().DeleteConfigByName(ctx, obj.Spec.ConfigGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetRootByName(ctx, obj.GetName())
	if err == nil {
		obj.Root = updatedObj.Root
	}
	return
}

// GetInventory returns child of given type
func (obj *GlobalRoot) GetInventory(ctx context.Context) (
	result *GlobalInventory, err error) {
	if obj.Spec.InventoryGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Root", "Inventory")
	}
	return obj.client.Global().GetInventoryByName(ctx, obj.Spec.InventoryGvk.Name)
}

// AddInventory calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalRoot) AddInventory(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Inventory) (result *GlobalInventory, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["roots.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["roots.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateInventoryByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetRootByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Root = updatedObj.Root
	}
	return
}

// DeleteInventory calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalRoot) DeleteInventory(ctx context.Context) (err error) {
	if obj.Spec.InventoryGvk != nil {
		err = obj.client.
			Global().DeleteInventoryByName(ctx, obj.Spec.InventoryGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetRootByName(ctx, obj.GetName())
	if err == nil {
		obj.Root = updatedObj.Root
	}
	return
}

// GetRuntime returns child of given type
func (obj *GlobalRoot) GetRuntime(ctx context.Context) (
	result *GlobalRuntime, err error) {
	if obj.Spec.RuntimeGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Root", "Runtime")
	}
	return obj.client.Global().GetRuntimeByName(ctx, obj.Spec.RuntimeGvk.Name)
}

// AddRuntime calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalRoot) AddRuntime(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Runtime) (result *GlobalRuntime, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["roots.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["roots.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateRuntimeByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetRootByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Root = updatedObj.Root
	}
	return
}

// DeleteRuntime calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalRoot) DeleteRuntime(ctx context.Context) (err error) {
	if obj.Spec.RuntimeGvk != nil {
		err = obj.client.
			Global().DeleteRuntimeByName(ctx, obj.Spec.RuntimeGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetRootByName(ctx, obj.GetName())
	if err == nil {
		obj.Root = updatedObj.Root
	}
	return
}

type rootGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *rootGlobalTsmV1Chainer) Subscribe() {
	key := "roots.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewRootInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *rootGlobalTsmV1Chainer) Unsubscribe() {
	key := "roots.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *rootGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "roots.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *rootGlobalTsmV1Chainer) Config() *configGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["configs.global.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &configGlobalTsmV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetConfig calculates hashed name of the object based on it's parents and returns the object
func (c *rootGlobalTsmV1Chainer) GetConfig(ctx context.Context) (result *GlobalConfig, err error) {
	hashedName := helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Global().GetConfigByName(ctx, hashedName)
}

// AddConfig calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *rootGlobalTsmV1Chainer) AddConfig(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Config) (result *GlobalConfig, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateConfigByName(ctx, objToCreate)
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *rootGlobalTsmV1Chainer) DeleteConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteConfigByName(ctx, hashedName)
}

func (c *rootGlobalTsmV1Chainer) Inventory() *inventoryGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["inventories.global.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &inventoryGlobalTsmV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetInventory calculates hashed name of the object based on it's parents and returns the object
func (c *rootGlobalTsmV1Chainer) GetInventory(ctx context.Context) (result *GlobalInventory, err error) {
	hashedName := helper.GetHashedName("inventories.global.tsm.tanzu.vmware.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Global().GetInventoryByName(ctx, hashedName)
}

// AddInventory calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *rootGlobalTsmV1Chainer) AddInventory(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Inventory) (result *GlobalInventory, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("inventories.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateInventoryByName(ctx, objToCreate)
}

// DeleteInventory calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *rootGlobalTsmV1Chainer) DeleteInventory(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("inventories.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteInventoryByName(ctx, hashedName)
}

func (c *rootGlobalTsmV1Chainer) Runtime() *runtimeGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["runtimes.global.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &runtimeGlobalTsmV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetRuntime calculates hashed name of the object based on it's parents and returns the object
func (c *rootGlobalTsmV1Chainer) GetRuntime(ctx context.Context) (result *GlobalRuntime, err error) {
	hashedName := helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Global().GetRuntimeByName(ctx, hashedName)
}

// AddRuntime calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *rootGlobalTsmV1Chainer) AddRuntime(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Runtime) (result *GlobalRuntime, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateRuntimeByName(ctx, objToCreate)
}

// DeleteRuntime calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *rootGlobalTsmV1Chainer) DeleteRuntime(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteRuntimeByName(ctx, hashedName)
}

// GetRPolicyByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetRPolicyByName(ctx context.Context, hashedName string) (*GlobalRPolicy, error) {
	key := "rpolicies.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.RPolicy)
		return &GlobalRPolicy{
			client:  group.client,
			RPolicy: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			RPolicies().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalRPolicy{
			client:  group.client,
			RPolicy: result,
		}, nil
	}
}

// DeleteRPolicyByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteRPolicyByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		RPolicies().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		RPolicies().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/routingPoliciesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["globalnses.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("globalnses.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GlobalNses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateRPolicyByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateRPolicyByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.RPolicy) (*GlobalRPolicy, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		RPolicies().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["globalnses.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("globalnses.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"routingPoliciesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"RPolicy\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GlobalNses().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalRPolicy{
		client:  group.client,
		RPolicy: result,
	}, nil
}

// UpdateRPolicyByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateRPolicyByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.RPolicy) (*GlobalRPolicy, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			RPolicies().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueHealthCheckId :=
		objToUpdate.Spec.HealthCheckId
	patchOpHealthCheckId := PatchOp{
		Op:    "replace",
		Path:  "/spec/healthCheckId",
		Value: patchValueHealthCheckId,
	}
	patch = append(patch, patchOpHealthCheckId)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		RPolicies().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalRPolicy{
		client:  group.client,
		RPolicy: result,
	}, nil
}

// ListRPolicies returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListRPolicies(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalRPolicy, err error) {
	key := "rpolicies.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalRPolicy, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.RPolicy)
			result[k] = &GlobalRPolicy{
				client:  group.client,
				RPolicy: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			RPolicies().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalRPolicy, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalRPolicy{
				client:  group.client,
				RPolicy: &item,
			}
		}
	}
	return
}

type GlobalRPolicy struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.RPolicy
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalRPolicy) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteRPolicyByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.RPolicy = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalRPolicy) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateRPolicyByName(ctx, obj.RPolicy)
	if err != nil {
		return err
	}
	obj.RPolicy = result.RPolicy
	return nil
}

func (obj *GlobalRPolicy) GetParent(ctx context.Context) (result *GlobalGlobalNs, err error) {
	hashedName := helper.GetHashedName("globalnses.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["globalnses.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGlobalNsByName(ctx, hashedName)
}

type rpolicyGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *rpolicyGlobalTsmV1Chainer) Subscribe() {
	key := "rpolicies.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewRPolicyInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *rpolicyGlobalTsmV1Chainer) Unsubscribe() {
	key := "rpolicies.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *rpolicyGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "rpolicies.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetRuntimeByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetRuntimeByName(ctx context.Context, hashedName string) (*GlobalRuntime, error) {
	key := "runtimes.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Runtime)
		return &GlobalRuntime{
			client:  group.client,
			Runtime: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Runtimes().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalRuntime{
			client:  group.client,
			Runtime: result,
		}, nil
	}
}

// DeleteRuntimeByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteRuntimeByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.AllsparkServicesGvk != nil {
		err := group.client.
			Global().
			DeleteAllSparkServicesByName(ctx, result.Spec.AllsparkServicesGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.UserFolderGvk != nil {
		err := group.client.
			Global().
			DeleteUserFolderByName(ctx, result.Spec.UserFolderGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.DataFolderGvk != nil {
		err := group.client.
			Global().
			DeleteDataFolderByName(ctx, result.Spec.DataFolderGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.AppFolderGvk != nil {
		err := group.client.
			Global().
			DeleteAppFolderByName(ctx, result.Spec.AppFolderGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.NodeFolderGvk != nil {
		err := group.client.
			Global().
			DeleteNodeFolderByName(ctx, result.Spec.NodeFolderGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.ClusterFolderGvk != nil {
		err := group.client.
			Global().
			DeleteClusterFolderByName(ctx, result.Spec.ClusterFolderGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.ProgressiveUpgradeGvk != nil {
		err := group.client.
			Global().
			DeleteProgressiveUpgradeFolderByName(ctx, result.Spec.ProgressiveUpgradeGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.JobConfigFolderGvk != nil {
		err := group.client.
			Global().
			DeleteJobConfigFolderByName(ctx, result.Spec.JobConfigFolderGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.ExternalDNSGvk != nil {
		err := group.client.
			Global().
			DeleteExternalDNSRuntimeByName(ctx, result.Spec.ExternalDNSGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.SloFolderGvk != nil {
		err := group.client.
			Global().
			DeleteSLOFolderByName(ctx, result.Spec.SloFolderGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.ServiceDirectoryRTGvk != nil {
		err := group.client.
			Global().
			DeleteServiceDirectoryRTByName(ctx, result.Spec.ServiceDirectoryRTGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/runtimeGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["roots.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("roots.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Roots().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateRuntimeByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateRuntimeByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Runtime) (*GlobalRuntime, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.AllsparkServicesGvk = nil
	objToCreate.Spec.UserFolderGvk = nil
	objToCreate.Spec.DataFolderGvk = nil
	objToCreate.Spec.AppFolderGvk = nil
	objToCreate.Spec.NodeFolderGvk = nil
	objToCreate.Spec.ClusterFolderGvk = nil
	objToCreate.Spec.ProgressiveUpgradeGvk = nil
	objToCreate.Spec.JobConfigFolderGvk = nil
	objToCreate.Spec.ExternalDNSGvk = nil
	objToCreate.Spec.SloFolderGvk = nil
	objToCreate.Spec.ServiceDirectoryRTGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["roots.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("roots.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/runtimeGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "Runtime",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Roots().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalRuntime{
		client:  group.client,
		Runtime: result,
	}, nil
}

// UpdateRuntimeByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateRuntimeByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Runtime) (*GlobalRuntime, error) {
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Runtimes().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalRuntime{
		client:  group.client,
		Runtime: result,
	}, nil
}

// ListRuntimes returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListRuntimes(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalRuntime, err error) {
	key := "runtimes.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalRuntime, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Runtime)
			result[k] = &GlobalRuntime{
				client:  group.client,
				Runtime: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Runtimes().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalRuntime, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalRuntime{
				client:  group.client,
				Runtime: &item,
			}
		}
	}
	return
}

type GlobalRuntime struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Runtime
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalRuntime) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteRuntimeByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Runtime = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalRuntime) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateRuntimeByName(ctx, obj.Runtime)
	if err != nil {
		return err
	}
	obj.Runtime = result.Runtime
	return nil
}

func (obj *GlobalRuntime) GetParent(ctx context.Context) (result *GlobalRoot, err error) {
	hashedName := helper.GetHashedName("roots.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["roots.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetRootByName(ctx, hashedName)
}

// GetAllsparkServices returns child of given type
func (obj *GlobalRuntime) GetAllsparkServices(ctx context.Context) (
	result *GlobalAllSparkServices, err error) {
	if obj.Spec.AllsparkServicesGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Runtime", "AllsparkServices")
	}
	return obj.client.Global().GetAllSparkServicesByName(ctx, obj.Spec.AllsparkServicesGvk.Name)
}

// AddAllsparkServices calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalRuntime) AddAllsparkServices(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AllSparkServices) (result *GlobalAllSparkServices, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["runtimes.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["runtimes.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateAllSparkServicesByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetRuntimeByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

// DeleteAllsparkServices calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalRuntime) DeleteAllsparkServices(ctx context.Context) (err error) {
	if obj.Spec.AllsparkServicesGvk != nil {
		err = obj.client.
			Global().DeleteAllSparkServicesByName(ctx, obj.Spec.AllsparkServicesGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetRuntimeByName(ctx, obj.GetName())
	if err == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

// GetUserFolder returns child of given type
func (obj *GlobalRuntime) GetUserFolder(ctx context.Context) (
	result *GlobalUserFolder, err error) {
	if obj.Spec.UserFolderGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Runtime", "UserFolder")
	}
	return obj.client.Global().GetUserFolderByName(ctx, obj.Spec.UserFolderGvk.Name)
}

// AddUserFolder calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalRuntime) AddUserFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.UserFolder) (result *GlobalUserFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["runtimes.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["runtimes.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateUserFolderByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetRuntimeByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

// DeleteUserFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalRuntime) DeleteUserFolder(ctx context.Context) (err error) {
	if obj.Spec.UserFolderGvk != nil {
		err = obj.client.
			Global().DeleteUserFolderByName(ctx, obj.Spec.UserFolderGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetRuntimeByName(ctx, obj.GetName())
	if err == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

// GetDataFolder returns child of given type
func (obj *GlobalRuntime) GetDataFolder(ctx context.Context) (
	result *GlobalDataFolder, err error) {
	if obj.Spec.DataFolderGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Runtime", "DataFolder")
	}
	return obj.client.Global().GetDataFolderByName(ctx, obj.Spec.DataFolderGvk.Name)
}

// AddDataFolder calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalRuntime) AddDataFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DataFolder) (result *GlobalDataFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["runtimes.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["runtimes.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateDataFolderByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetRuntimeByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

// DeleteDataFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalRuntime) DeleteDataFolder(ctx context.Context) (err error) {
	if obj.Spec.DataFolderGvk != nil {
		err = obj.client.
			Global().DeleteDataFolderByName(ctx, obj.Spec.DataFolderGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetRuntimeByName(ctx, obj.GetName())
	if err == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

// GetAppFolder returns child of given type
func (obj *GlobalRuntime) GetAppFolder(ctx context.Context) (
	result *GlobalAppFolder, err error) {
	if obj.Spec.AppFolderGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Runtime", "AppFolder")
	}
	return obj.client.Global().GetAppFolderByName(ctx, obj.Spec.AppFolderGvk.Name)
}

// AddAppFolder calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalRuntime) AddAppFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AppFolder) (result *GlobalAppFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["runtimes.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["runtimes.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateAppFolderByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetRuntimeByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

// DeleteAppFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalRuntime) DeleteAppFolder(ctx context.Context) (err error) {
	if obj.Spec.AppFolderGvk != nil {
		err = obj.client.
			Global().DeleteAppFolderByName(ctx, obj.Spec.AppFolderGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetRuntimeByName(ctx, obj.GetName())
	if err == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

// GetNodeFolder returns child of given type
func (obj *GlobalRuntime) GetNodeFolder(ctx context.Context) (
	result *GlobalNodeFolder, err error) {
	if obj.Spec.NodeFolderGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Runtime", "NodeFolder")
	}
	return obj.client.Global().GetNodeFolderByName(ctx, obj.Spec.NodeFolderGvk.Name)
}

// AddNodeFolder calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalRuntime) AddNodeFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NodeFolder) (result *GlobalNodeFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["runtimes.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["runtimes.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateNodeFolderByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetRuntimeByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

// DeleteNodeFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalRuntime) DeleteNodeFolder(ctx context.Context) (err error) {
	if obj.Spec.NodeFolderGvk != nil {
		err = obj.client.
			Global().DeleteNodeFolderByName(ctx, obj.Spec.NodeFolderGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetRuntimeByName(ctx, obj.GetName())
	if err == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

// GetClusterFolder returns child of given type
func (obj *GlobalRuntime) GetClusterFolder(ctx context.Context) (
	result *GlobalClusterFolder, err error) {
	if obj.Spec.ClusterFolderGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Runtime", "ClusterFolder")
	}
	return obj.client.Global().GetClusterFolderByName(ctx, obj.Spec.ClusterFolderGvk.Name)
}

// AddClusterFolder calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalRuntime) AddClusterFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ClusterFolder) (result *GlobalClusterFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["runtimes.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["runtimes.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateClusterFolderByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetRuntimeByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

// DeleteClusterFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalRuntime) DeleteClusterFolder(ctx context.Context) (err error) {
	if obj.Spec.ClusterFolderGvk != nil {
		err = obj.client.
			Global().DeleteClusterFolderByName(ctx, obj.Spec.ClusterFolderGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetRuntimeByName(ctx, obj.GetName())
	if err == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

// GetProgressiveUpgrade returns child of given type
func (obj *GlobalRuntime) GetProgressiveUpgrade(ctx context.Context) (
	result *GlobalProgressiveUpgradeFolder, err error) {
	if obj.Spec.ProgressiveUpgradeGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Runtime", "ProgressiveUpgrade")
	}
	return obj.client.Global().GetProgressiveUpgradeFolderByName(ctx, obj.Spec.ProgressiveUpgradeGvk.Name)
}

// AddProgressiveUpgrade calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalRuntime) AddProgressiveUpgrade(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgradeFolder) (result *GlobalProgressiveUpgradeFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["runtimes.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["runtimes.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateProgressiveUpgradeFolderByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetRuntimeByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

// DeleteProgressiveUpgrade calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalRuntime) DeleteProgressiveUpgrade(ctx context.Context) (err error) {
	if obj.Spec.ProgressiveUpgradeGvk != nil {
		err = obj.client.
			Global().DeleteProgressiveUpgradeFolderByName(ctx, obj.Spec.ProgressiveUpgradeGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetRuntimeByName(ctx, obj.GetName())
	if err == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

// GetJobConfigFolder returns child of given type
func (obj *GlobalRuntime) GetJobConfigFolder(ctx context.Context) (
	result *GlobalJobConfigFolder, err error) {
	if obj.Spec.JobConfigFolderGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Runtime", "JobConfigFolder")
	}
	return obj.client.Global().GetJobConfigFolderByName(ctx, obj.Spec.JobConfigFolderGvk.Name)
}

// AddJobConfigFolder calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalRuntime) AddJobConfigFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.JobConfigFolder) (result *GlobalJobConfigFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["runtimes.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["runtimes.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateJobConfigFolderByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetRuntimeByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

// DeleteJobConfigFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalRuntime) DeleteJobConfigFolder(ctx context.Context) (err error) {
	if obj.Spec.JobConfigFolderGvk != nil {
		err = obj.client.
			Global().DeleteJobConfigFolderByName(ctx, obj.Spec.JobConfigFolderGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetRuntimeByName(ctx, obj.GetName())
	if err == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

// GetExternalDNS returns child of given type
func (obj *GlobalRuntime) GetExternalDNS(ctx context.Context) (
	result *GlobalExternalDNSRuntime, err error) {
	if obj.Spec.ExternalDNSGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Runtime", "ExternalDNS")
	}
	return obj.client.Global().GetExternalDNSRuntimeByName(ctx, obj.Spec.ExternalDNSGvk.Name)
}

// AddExternalDNS calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalRuntime) AddExternalDNS(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntime) (result *GlobalExternalDNSRuntime, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["runtimes.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["runtimes.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateExternalDNSRuntimeByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetRuntimeByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

// DeleteExternalDNS calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalRuntime) DeleteExternalDNS(ctx context.Context) (err error) {
	if obj.Spec.ExternalDNSGvk != nil {
		err = obj.client.
			Global().DeleteExternalDNSRuntimeByName(ctx, obj.Spec.ExternalDNSGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetRuntimeByName(ctx, obj.GetName())
	if err == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

// GetSloFolder returns child of given type
func (obj *GlobalRuntime) GetSloFolder(ctx context.Context) (
	result *GlobalSLOFolder, err error) {
	if obj.Spec.SloFolderGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Runtime", "SloFolder")
	}
	return obj.client.Global().GetSLOFolderByName(ctx, obj.Spec.SloFolderGvk.Name)
}

// AddSloFolder calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalRuntime) AddSloFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SLOFolder) (result *GlobalSLOFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["runtimes.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["runtimes.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateSLOFolderByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetRuntimeByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

// DeleteSloFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalRuntime) DeleteSloFolder(ctx context.Context) (err error) {
	if obj.Spec.SloFolderGvk != nil {
		err = obj.client.
			Global().DeleteSLOFolderByName(ctx, obj.Spec.SloFolderGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetRuntimeByName(ctx, obj.GetName())
	if err == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

// GetServiceDirectoryRT returns child of given type
func (obj *GlobalRuntime) GetServiceDirectoryRT(ctx context.Context) (
	result *GlobalServiceDirectoryRT, err error) {
	if obj.Spec.ServiceDirectoryRTGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Runtime", "ServiceDirectoryRT")
	}
	return obj.client.Global().GetServiceDirectoryRTByName(ctx, obj.Spec.ServiceDirectoryRTGvk.Name)
}

// AddServiceDirectoryRT calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalRuntime) AddServiceDirectoryRT(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryRT) (result *GlobalServiceDirectoryRT, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["runtimes.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["runtimes.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceDirectoryRTByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetRuntimeByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

// DeleteServiceDirectoryRT calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalRuntime) DeleteServiceDirectoryRT(ctx context.Context) (err error) {
	if obj.Spec.ServiceDirectoryRTGvk != nil {
		err = obj.client.
			Global().DeleteServiceDirectoryRTByName(ctx, obj.Spec.ServiceDirectoryRTGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Global().GetRuntimeByName(ctx, obj.GetName())
	if err == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

type runtimeGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *runtimeGlobalTsmV1Chainer) Subscribe() {
	key := "runtimes.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewRuntimeInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *runtimeGlobalTsmV1Chainer) Unsubscribe() {
	key := "runtimes.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *runtimeGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "runtimes.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *runtimeGlobalTsmV1Chainer) AllsparkServices() *allsparkservicesGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["allsparkserviceses.global.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &allsparkservicesGlobalTsmV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetAllsparkServices calculates hashed name of the object based on it's parents and returns the object
func (c *runtimeGlobalTsmV1Chainer) GetAllsparkServices(ctx context.Context) (result *GlobalAllSparkServices, err error) {
	hashedName := helper.GetHashedName("allsparkserviceses.global.tsm.tanzu.vmware.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Global().GetAllSparkServicesByName(ctx, hashedName)
}

// AddAllsparkServices calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *runtimeGlobalTsmV1Chainer) AddAllsparkServices(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AllSparkServices) (result *GlobalAllSparkServices, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("allsparkserviceses.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateAllSparkServicesByName(ctx, objToCreate)
}

// DeleteAllsparkServices calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *runtimeGlobalTsmV1Chainer) DeleteAllsparkServices(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("allsparkserviceses.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteAllSparkServicesByName(ctx, hashedName)
}

func (c *runtimeGlobalTsmV1Chainer) UserFolder() *userfolderGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["userfolders.global.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &userfolderGlobalTsmV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetUserFolder calculates hashed name of the object based on it's parents and returns the object
func (c *runtimeGlobalTsmV1Chainer) GetUserFolder(ctx context.Context) (result *GlobalUserFolder, err error) {
	hashedName := helper.GetHashedName("userfolders.global.tsm.tanzu.vmware.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Global().GetUserFolderByName(ctx, hashedName)
}

// AddUserFolder calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *runtimeGlobalTsmV1Chainer) AddUserFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.UserFolder) (result *GlobalUserFolder, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("userfolders.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateUserFolderByName(ctx, objToCreate)
}

// DeleteUserFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *runtimeGlobalTsmV1Chainer) DeleteUserFolder(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("userfolders.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteUserFolderByName(ctx, hashedName)
}

func (c *runtimeGlobalTsmV1Chainer) DataFolder() *datafolderGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["datafolders.global.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &datafolderGlobalTsmV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetDataFolder calculates hashed name of the object based on it's parents and returns the object
func (c *runtimeGlobalTsmV1Chainer) GetDataFolder(ctx context.Context) (result *GlobalDataFolder, err error) {
	hashedName := helper.GetHashedName("datafolders.global.tsm.tanzu.vmware.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Global().GetDataFolderByName(ctx, hashedName)
}

// AddDataFolder calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *runtimeGlobalTsmV1Chainer) AddDataFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DataFolder) (result *GlobalDataFolder, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("datafolders.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateDataFolderByName(ctx, objToCreate)
}

// DeleteDataFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *runtimeGlobalTsmV1Chainer) DeleteDataFolder(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("datafolders.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteDataFolderByName(ctx, hashedName)
}

func (c *runtimeGlobalTsmV1Chainer) AppFolder(name string) *appfolderGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["appfolders.global.tsm.tanzu.vmware.com"] = name
	return &appfolderGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetAppFolder calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *runtimeGlobalTsmV1Chainer) GetAppFolder(ctx context.Context, displayName string) (result *GlobalAppFolder, err error) {
	hashedName := helper.GetHashedName("appfolders.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetAppFolderByName(ctx, hashedName)
}

// AddAppFolder calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *runtimeGlobalTsmV1Chainer) AddAppFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AppFolder) (result *GlobalAppFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("appfolders.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateAppFolderByName(ctx, objToCreate)
}

// DeleteAppFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *runtimeGlobalTsmV1Chainer) DeleteAppFolder(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("appfolders.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteAppFolderByName(ctx, hashedName)
}

func (c *runtimeGlobalTsmV1Chainer) NodeFolder() *nodefolderGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["nodefolders.global.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &nodefolderGlobalTsmV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetNodeFolder calculates hashed name of the object based on it's parents and returns the object
func (c *runtimeGlobalTsmV1Chainer) GetNodeFolder(ctx context.Context) (result *GlobalNodeFolder, err error) {
	hashedName := helper.GetHashedName("nodefolders.global.tsm.tanzu.vmware.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Global().GetNodeFolderByName(ctx, hashedName)
}

// AddNodeFolder calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *runtimeGlobalTsmV1Chainer) AddNodeFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NodeFolder) (result *GlobalNodeFolder, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("nodefolders.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateNodeFolderByName(ctx, objToCreate)
}

// DeleteNodeFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *runtimeGlobalTsmV1Chainer) DeleteNodeFolder(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("nodefolders.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteNodeFolderByName(ctx, hashedName)
}

func (c *runtimeGlobalTsmV1Chainer) ClusterFolder(name string) *clusterfolderGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["clusterfolders.global.tsm.tanzu.vmware.com"] = name
	return &clusterfolderGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetClusterFolder calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *runtimeGlobalTsmV1Chainer) GetClusterFolder(ctx context.Context, displayName string) (result *GlobalClusterFolder, err error) {
	hashedName := helper.GetHashedName("clusterfolders.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetClusterFolderByName(ctx, hashedName)
}

// AddClusterFolder calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *runtimeGlobalTsmV1Chainer) AddClusterFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ClusterFolder) (result *GlobalClusterFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("clusterfolders.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateClusterFolderByName(ctx, objToCreate)
}

// DeleteClusterFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *runtimeGlobalTsmV1Chainer) DeleteClusterFolder(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("clusterfolders.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteClusterFolderByName(ctx, hashedName)
}

func (c *runtimeGlobalTsmV1Chainer) ProgressiveUpgrade() *progressiveupgradefolderGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["progressiveupgradefolders.global.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &progressiveupgradefolderGlobalTsmV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetProgressiveUpgrade calculates hashed name of the object based on it's parents and returns the object
func (c *runtimeGlobalTsmV1Chainer) GetProgressiveUpgrade(ctx context.Context) (result *GlobalProgressiveUpgradeFolder, err error) {
	hashedName := helper.GetHashedName("progressiveupgradefolders.global.tsm.tanzu.vmware.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Global().GetProgressiveUpgradeFolderByName(ctx, hashedName)
}

// AddProgressiveUpgrade calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *runtimeGlobalTsmV1Chainer) AddProgressiveUpgrade(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ProgressiveUpgradeFolder) (result *GlobalProgressiveUpgradeFolder, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("progressiveupgradefolders.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateProgressiveUpgradeFolderByName(ctx, objToCreate)
}

// DeleteProgressiveUpgrade calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *runtimeGlobalTsmV1Chainer) DeleteProgressiveUpgrade(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("progressiveupgradefolders.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteProgressiveUpgradeFolderByName(ctx, hashedName)
}

func (c *runtimeGlobalTsmV1Chainer) JobConfigFolder() *jobconfigfolderGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["jobconfigfolders.global.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &jobconfigfolderGlobalTsmV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetJobConfigFolder calculates hashed name of the object based on it's parents and returns the object
func (c *runtimeGlobalTsmV1Chainer) GetJobConfigFolder(ctx context.Context) (result *GlobalJobConfigFolder, err error) {
	hashedName := helper.GetHashedName("jobconfigfolders.global.tsm.tanzu.vmware.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Global().GetJobConfigFolderByName(ctx, hashedName)
}

// AddJobConfigFolder calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *runtimeGlobalTsmV1Chainer) AddJobConfigFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.JobConfigFolder) (result *GlobalJobConfigFolder, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("jobconfigfolders.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateJobConfigFolderByName(ctx, objToCreate)
}

// DeleteJobConfigFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *runtimeGlobalTsmV1Chainer) DeleteJobConfigFolder(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("jobconfigfolders.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteJobConfigFolderByName(ctx, hashedName)
}

func (c *runtimeGlobalTsmV1Chainer) ExternalDNS() *externaldnsruntimeGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["externaldnsruntimes.global.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &externaldnsruntimeGlobalTsmV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetExternalDNS calculates hashed name of the object based on it's parents and returns the object
func (c *runtimeGlobalTsmV1Chainer) GetExternalDNS(ctx context.Context) (result *GlobalExternalDNSRuntime, err error) {
	hashedName := helper.GetHashedName("externaldnsruntimes.global.tsm.tanzu.vmware.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Global().GetExternalDNSRuntimeByName(ctx, hashedName)
}

// AddExternalDNS calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *runtimeGlobalTsmV1Chainer) AddExternalDNS(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ExternalDNSRuntime) (result *GlobalExternalDNSRuntime, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("externaldnsruntimes.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateExternalDNSRuntimeByName(ctx, objToCreate)
}

// DeleteExternalDNS calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *runtimeGlobalTsmV1Chainer) DeleteExternalDNS(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("externaldnsruntimes.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteExternalDNSRuntimeByName(ctx, hashedName)
}

func (c *runtimeGlobalTsmV1Chainer) SloFolder(name string) *slofolderGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["slofolders.global.tsm.tanzu.vmware.com"] = name
	return &slofolderGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetSloFolder calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *runtimeGlobalTsmV1Chainer) GetSloFolder(ctx context.Context, displayName string) (result *GlobalSLOFolder, err error) {
	hashedName := helper.GetHashedName("slofolders.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetSLOFolderByName(ctx, hashedName)
}

// AddSloFolder calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *runtimeGlobalTsmV1Chainer) AddSloFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SLOFolder) (result *GlobalSLOFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("slofolders.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateSLOFolderByName(ctx, objToCreate)
}

// DeleteSloFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *runtimeGlobalTsmV1Chainer) DeleteSloFolder(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("slofolders.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteSLOFolderByName(ctx, hashedName)
}

func (c *runtimeGlobalTsmV1Chainer) ServiceDirectoryRT() *servicedirectoryrtGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["servicedirectoryrts.global.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &servicedirectoryrtGlobalTsmV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetServiceDirectoryRT calculates hashed name of the object based on it's parents and returns the object
func (c *runtimeGlobalTsmV1Chainer) GetServiceDirectoryRT(ctx context.Context) (result *GlobalServiceDirectoryRT, err error) {
	hashedName := helper.GetHashedName("servicedirectoryrts.global.tsm.tanzu.vmware.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Global().GetServiceDirectoryRTByName(ctx, hashedName)
}

// AddServiceDirectoryRT calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *runtimeGlobalTsmV1Chainer) AddServiceDirectoryRT(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryRT) (result *GlobalServiceDirectoryRT, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("servicedirectoryrts.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceDirectoryRTByName(ctx, objToCreate)
}

// DeleteServiceDirectoryRT calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *runtimeGlobalTsmV1Chainer) DeleteServiceDirectoryRT(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("servicedirectoryrts.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceDirectoryRTByName(ctx, hashedName)
}

// GetSchemaViolationDiscoveryRTByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetSchemaViolationDiscoveryRTByName(ctx context.Context, hashedName string) (*GlobalSchemaViolationDiscoveryRT, error) {
	key := "schemaviolationdiscoveryrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.SchemaViolationDiscoveryRT)
		return &GlobalSchemaViolationDiscoveryRT{
			client:                     group.client,
			SchemaViolationDiscoveryRT: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			SchemaViolationDiscoveryRTs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalSchemaViolationDiscoveryRT{
			client:                     group.client,
			SchemaViolationDiscoveryRT: result,
		}, nil
	}
}

// DeleteSchemaViolationDiscoveryRTByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteSchemaViolationDiscoveryRTByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SchemaViolationDiscoveryRTs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		SchemaViolationDiscoveryRTs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gnsSchemaViolationDiscoveryGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateSchemaViolationDiscoveryRTByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateSchemaViolationDiscoveryRTByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SchemaViolationDiscoveryRT) (*GlobalSchemaViolationDiscoveryRT, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SchemaViolationDiscoveryRTs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"gnsSchemaViolationDiscoveryGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"SchemaViolationDiscoveryRT\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalSchemaViolationDiscoveryRT{
		client:                     group.client,
		SchemaViolationDiscoveryRT: result,
	}, nil
}

// UpdateSchemaViolationDiscoveryRTByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateSchemaViolationDiscoveryRTByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.SchemaViolationDiscoveryRT) (*GlobalSchemaViolationDiscoveryRT, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			SchemaViolationDiscoveryRTs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueGnsid :=
		objToUpdate.Spec.Gnsid
	patchOpGnsid := PatchOp{
		Op:    "replace",
		Path:  "/spec/gnsid",
		Value: patchValueGnsid,
	}
	patch = append(patch, patchOpGnsid)

	patchValueSelectors :=
		objToUpdate.Spec.Selectors
	patchOpSelectors := PatchOp{
		Op:    "replace",
		Path:  "/spec/selectors",
		Value: patchValueSelectors,
	}
	patch = append(patch, patchOpSelectors)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		SchemaViolationDiscoveryRTs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalSchemaViolationDiscoveryRT{
		client:                     group.client,
		SchemaViolationDiscoveryRT: result,
	}, nil
}

// ListSchemaViolationDiscoveryRTs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListSchemaViolationDiscoveryRTs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalSchemaViolationDiscoveryRT, err error) {
	key := "schemaviolationdiscoveryrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalSchemaViolationDiscoveryRT, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.SchemaViolationDiscoveryRT)
			result[k] = &GlobalSchemaViolationDiscoveryRT{
				client:                     group.client,
				SchemaViolationDiscoveryRT: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			SchemaViolationDiscoveryRTs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalSchemaViolationDiscoveryRT, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalSchemaViolationDiscoveryRT{
				client:                     group.client,
				SchemaViolationDiscoveryRT: &item,
			}
		}
	}
	return
}

type GlobalSchemaViolationDiscoveryRT struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.SchemaViolationDiscoveryRT
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalSchemaViolationDiscoveryRT) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteSchemaViolationDiscoveryRTByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.SchemaViolationDiscoveryRT = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalSchemaViolationDiscoveryRT) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateSchemaViolationDiscoveryRTByName(ctx, obj.SchemaViolationDiscoveryRT)
	if err != nil {
		return err
	}
	obj.SchemaViolationDiscoveryRT = result.SchemaViolationDiscoveryRT
	return nil
}

func (obj *GlobalSchemaViolationDiscoveryRT) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

type schemaviolationdiscoveryrtGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *schemaviolationdiscoveryrtGlobalTsmV1Chainer) Subscribe() {
	key := "schemaviolationdiscoveryrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSchemaViolationDiscoveryRTInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *schemaviolationdiscoveryrtGlobalTsmV1Chainer) Unsubscribe() {
	key := "schemaviolationdiscoveryrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *schemaviolationdiscoveryrtGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "schemaviolationdiscoveryrts.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetGnsSchemaViolationDiscoveryByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetGnsSchemaViolationDiscoveryByName(ctx context.Context, hashedName string) (*GlobalGnsSchemaViolationDiscovery, error) {
	key := "gnsschemaviolationdiscoveries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.GnsSchemaViolationDiscovery)
		return &GlobalGnsSchemaViolationDiscovery{
			client:                      group.client,
			GnsSchemaViolationDiscovery: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			GnsSchemaViolationDiscoveries().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalGnsSchemaViolationDiscovery{
			client:                      group.client,
			GnsSchemaViolationDiscovery: result,
		}, nil
	}
}

// DeleteGnsSchemaViolationDiscoveryByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteGnsSchemaViolationDiscoveryByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsSchemaViolationDiscoveries().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		GnsSchemaViolationDiscoveries().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gnsSchemaViolationDiscoveryGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGnsSchemaViolationDiscoveryByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateGnsSchemaViolationDiscoveryByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.GnsSchemaViolationDiscovery) (*GlobalGnsSchemaViolationDiscovery, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsSchemaViolationDiscoveries().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"gnsSchemaViolationDiscoveryGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"GnsSchemaViolationDiscovery\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalGnsSchemaViolationDiscovery{
		client:                      group.client,
		GnsSchemaViolationDiscovery: result,
	}, nil
}

// UpdateGnsSchemaViolationDiscoveryByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateGnsSchemaViolationDiscoveryByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.GnsSchemaViolationDiscovery) (*GlobalGnsSchemaViolationDiscovery, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			GnsSchemaViolationDiscoveries().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		GnsSchemaViolationDiscoveries().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalGnsSchemaViolationDiscovery{
		client:                      group.client,
		GnsSchemaViolationDiscovery: result,
	}, nil
}

// ListGnsSchemaViolationDiscoveries returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListGnsSchemaViolationDiscoveries(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalGnsSchemaViolationDiscovery, err error) {
	key := "gnsschemaviolationdiscoveries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalGnsSchemaViolationDiscovery, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.GnsSchemaViolationDiscovery)
			result[k] = &GlobalGnsSchemaViolationDiscovery{
				client:                      group.client,
				GnsSchemaViolationDiscovery: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			GnsSchemaViolationDiscoveries().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalGnsSchemaViolationDiscovery, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalGnsSchemaViolationDiscovery{
				client:                      group.client,
				GnsSchemaViolationDiscovery: &item,
			}
		}
	}
	return
}

type GlobalGnsSchemaViolationDiscovery struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.GnsSchemaViolationDiscovery
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalGnsSchemaViolationDiscovery) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteGnsSchemaViolationDiscoveryByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.GnsSchemaViolationDiscovery = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalGnsSchemaViolationDiscovery) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateGnsSchemaViolationDiscoveryByName(ctx, obj.GnsSchemaViolationDiscovery)
	if err != nil {
		return err
	}
	obj.GnsSchemaViolationDiscovery = result.GnsSchemaViolationDiscovery
	return nil
}

func (obj *GlobalGnsSchemaViolationDiscovery) GetParent(ctx context.Context) (result *GlobalGNS, err error) {
	hashedName := helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnss.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGNSByName(ctx, hashedName)
}

type gnsschemaviolationdiscoveryGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *gnsschemaviolationdiscoveryGlobalTsmV1Chainer) Subscribe() {
	key := "gnsschemaviolationdiscoveries.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewGnsSchemaViolationDiscoveryInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *gnsschemaviolationdiscoveryGlobalTsmV1Chainer) Unsubscribe() {
	key := "gnsschemaviolationdiscoveries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *gnsschemaviolationdiscoveryGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "gnsschemaviolationdiscoveries.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetSecretRTConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetSecretRTConfigByName(ctx context.Context, hashedName string) (*GlobalSecretRTConfig, error) {
	key := "secretrtconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.SecretRTConfig)
		return &GlobalSecretRTConfig{
			client:         group.client,
			SecretRTConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			SecretRTConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalSecretRTConfig{
			client:         group.client,
			SecretRTConfig: result,
		}, nil
	}
}

// DeleteSecretRTConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteSecretRTConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SecretRTConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		SecretRTConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/secretsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateSecretRTConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateSecretRTConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SecretRTConfig) (*GlobalSecretRTConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SecretRTConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"secretsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"SecretRTConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalSecretRTConfig{
		client:         group.client,
		SecretRTConfig: result,
	}, nil
}

// UpdateSecretRTConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateSecretRTConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.SecretRTConfig) (*GlobalSecretRTConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			SecretRTConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueType :=
		objToUpdate.Spec.Type
	patchOpType := PatchOp{
		Op:    "replace",
		Path:  "/spec/type",
		Value: patchValueType,
	}
	patch = append(patch, patchOpType)

	patchValueData :=
		objToUpdate.Spec.Data
	patchOpData := PatchOp{
		Op:    "replace",
		Path:  "/spec/data",
		Value: patchValueData,
	}
	patch = append(patch, patchOpData)

	patchValueIsBase64Encoded :=
		objToUpdate.Spec.IsBase64Encoded
	patchOpIsBase64Encoded := PatchOp{
		Op:    "replace",
		Path:  "/spec/isBase64Encoded",
		Value: patchValueIsBase64Encoded,
	}
	patch = append(patch, patchOpIsBase64Encoded)

	patchValueOwnedBy :=
		objToUpdate.Spec.OwnedBy
	patchOpOwnedBy := PatchOp{
		Op:    "replace",
		Path:  "/spec/ownedBy",
		Value: patchValueOwnedBy,
	}
	patch = append(patch, patchOpOwnedBy)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		SecretRTConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalSecretRTConfig{
		client:         group.client,
		SecretRTConfig: result,
	}, nil
}

// ListSecretRTConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListSecretRTConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalSecretRTConfig, err error) {
	key := "secretrtconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalSecretRTConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.SecretRTConfig)
			result[k] = &GlobalSecretRTConfig{
				client:         group.client,
				SecretRTConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			SecretRTConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalSecretRTConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalSecretRTConfig{
				client:         group.client,
				SecretRTConfig: &item,
			}
		}
	}
	return
}

type GlobalSecretRTConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.SecretRTConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalSecretRTConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteSecretRTConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.SecretRTConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalSecretRTConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateSecretRTConfigByName(ctx, obj.SecretRTConfig)
	if err != nil {
		return err
	}
	obj.SecretRTConfig = result.SecretRTConfig
	return nil
}

func (obj *GlobalSecretRTConfig) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

type secretrtconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *secretrtconfigGlobalTsmV1Chainer) Subscribe() {
	key := "secretrtconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSecretRTConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *secretrtconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "secretrtconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *secretrtconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "secretrtconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetSecretHashByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetSecretHashByName(ctx context.Context, hashedName string) (*GlobalSecretHash, error) {
	key := "secrethashes.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.SecretHash)
		return &GlobalSecretHash{
			client:     group.client,
			SecretHash: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			SecretHashes().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalSecretHash{
			client:     group.client,
			SecretHash: result,
		}, nil
	}
}

// DeleteSecretHashByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteSecretHashByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SecretHashes().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		SecretHashes().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/secretHashesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateSecretHashByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateSecretHashByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SecretHash) (*GlobalSecretHash, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SecretHashes().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"secretHashesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"SecretHash\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalSecretHash{
		client:     group.client,
		SecretHash: result,
	}, nil
}

// UpdateSecretHashByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateSecretHashByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.SecretHash) (*GlobalSecretHash, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			SecretHashes().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueType :=
		objToUpdate.Spec.Type
	patchOpType := PatchOp{
		Op:    "replace",
		Path:  "/spec/type",
		Value: patchValueType,
	}
	patch = append(patch, patchOpType)

	patchValueMetadata :=
		objToUpdate.Spec.Metadata
	patchOpMetadata := PatchOp{
		Op:    "replace",
		Path:  "/spec/metadata",
		Value: patchValueMetadata,
	}
	patch = append(patch, patchOpMetadata)

	patchValueDataHash :=
		objToUpdate.Spec.DataHash
	patchOpDataHash := PatchOp{
		Op:    "replace",
		Path:  "/spec/dataHash",
		Value: patchValueDataHash,
	}
	patch = append(patch, patchOpDataHash)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		SecretHashes().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalSecretHash{
		client:     group.client,
		SecretHash: result,
	}, nil
}

// ListSecretHashes returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListSecretHashes(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalSecretHash, err error) {
	key := "secrethashes.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalSecretHash, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.SecretHash)
			result[k] = &GlobalSecretHash{
				client:     group.client,
				SecretHash: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			SecretHashes().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalSecretHash, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalSecretHash{
				client:     group.client,
				SecretHash: &item,
			}
		}
	}
	return
}

type GlobalSecretHash struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.SecretHash
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalSecretHash) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteSecretHashByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.SecretHash = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalSecretHash) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateSecretHashByName(ctx, obj.SecretHash)
	if err != nil {
		return err
	}
	obj.SecretHash = result.SecretHash
	return nil
}

func (obj *GlobalSecretHash) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

type secrethashGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *secrethashGlobalTsmV1Chainer) Subscribe() {
	key := "secrethashes.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSecretHashInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *secrethashGlobalTsmV1Chainer) Unsubscribe() {
	key := "secrethashes.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *secrethashGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "secrethashes.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetSecurityContextConstraintsConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetSecurityContextConstraintsConfigByName(ctx context.Context, hashedName string) (*GlobalSecurityContextConstraintsConfig, error) {
	key := "securitycontextconstraintsconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.SecurityContextConstraintsConfig)
		return &GlobalSecurityContextConstraintsConfig{
			client:                           group.client,
			SecurityContextConstraintsConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			SecurityContextConstraintsConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalSecurityContextConstraintsConfig{
			client:                           group.client,
			SecurityContextConstraintsConfig: result,
		}, nil
	}
}

// DeleteSecurityContextConstraintsConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteSecurityContextConstraintsConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SecurityContextConstraintsConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		SecurityContextConstraintsConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/securityContextConstraintsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["clusterconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateSecurityContextConstraintsConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateSecurityContextConstraintsConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SecurityContextConstraintsConfig) (*GlobalSecurityContextConstraintsConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SecurityContextConstraintsConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["clusterconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"securityContextConstraintsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"SecurityContextConstraintsConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ClusterConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalSecurityContextConstraintsConfig{
		client:                           group.client,
		SecurityContextConstraintsConfig: result,
	}, nil
}

// UpdateSecurityContextConstraintsConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateSecurityContextConstraintsConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.SecurityContextConstraintsConfig) (*GlobalSecurityContextConstraintsConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			SecurityContextConstraintsConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueMetadata :=
		objToUpdate.Spec.Metadata
	patchOpMetadata := PatchOp{
		Op:    "replace",
		Path:  "/spec/metadata",
		Value: patchValueMetadata,
	}
	patch = append(patch, patchOpMetadata)

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	if objToUpdate.Spec.Groups != nil {
		patchValueGroups :=
			objToUpdate.Spec.Groups
		patchOpGroups := PatchOp{
			Op:    "replace",
			Path:  "/spec/groups",
			Value: patchValueGroups,
		}
		patch = append(patch, patchOpGroups)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		SecurityContextConstraintsConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalSecurityContextConstraintsConfig{
		client:                           group.client,
		SecurityContextConstraintsConfig: result,
	}, nil
}

// ListSecurityContextConstraintsConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListSecurityContextConstraintsConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalSecurityContextConstraintsConfig, err error) {
	key := "securitycontextconstraintsconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalSecurityContextConstraintsConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.SecurityContextConstraintsConfig)
			result[k] = &GlobalSecurityContextConstraintsConfig{
				client:                           group.client,
				SecurityContextConstraintsConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			SecurityContextConstraintsConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalSecurityContextConstraintsConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalSecurityContextConstraintsConfig{
				client:                           group.client,
				SecurityContextConstraintsConfig: &item,
			}
		}
	}
	return
}

type GlobalSecurityContextConstraintsConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.SecurityContextConstraintsConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalSecurityContextConstraintsConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteSecurityContextConstraintsConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.SecurityContextConstraintsConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalSecurityContextConstraintsConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateSecurityContextConstraintsConfigByName(ctx, obj.SecurityContextConstraintsConfig)
	if err != nil {
		return err
	}
	obj.SecurityContextConstraintsConfig = result.SecurityContextConstraintsConfig
	return nil
}

func (obj *GlobalSecurityContextConstraintsConfig) GetParent(ctx context.Context) (result *GlobalClusterConfig, err error) {
	hashedName := helper.GetHashedName("clusterconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["clusterconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetClusterConfigByName(ctx, hashedName)
}

type securitycontextconstraintsconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *securitycontextconstraintsconfigGlobalTsmV1Chainer) Subscribe() {
	key := "securitycontextconstraintsconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSecurityContextConstraintsConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *securitycontextconstraintsconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "securitycontextconstraintsconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *securitycontextconstraintsconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "securitycontextconstraintsconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetSecurityContextConstraintsByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetSecurityContextConstraintsByName(ctx context.Context, hashedName string) (*GlobalSecurityContextConstraints, error) {
	key := "securitycontextconstraintses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.SecurityContextConstraints)
		return &GlobalSecurityContextConstraints{
			client:                     group.client,
			SecurityContextConstraints: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			SecurityContextConstraintses().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalSecurityContextConstraints{
			client:                     group.client,
			SecurityContextConstraints: result,
		}, nil
	}
}

// DeleteSecurityContextConstraintsByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteSecurityContextConstraintsByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SecurityContextConstraintses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		SecurityContextConstraintses().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/securityContextConstraintsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["clusters.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusters.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Clusters().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateSecurityContextConstraintsByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateSecurityContextConstraintsByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SecurityContextConstraints) (*GlobalSecurityContextConstraints, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SecurityContextConstraintses().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["clusters.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("clusters.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"securityContextConstraintsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"SecurityContextConstraints\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Clusters().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalSecurityContextConstraints{
		client:                     group.client,
		SecurityContextConstraints: result,
	}, nil
}

// UpdateSecurityContextConstraintsByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateSecurityContextConstraintsByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.SecurityContextConstraints) (*GlobalSecurityContextConstraints, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			SecurityContextConstraintses().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueMetadata :=
		objToUpdate.Spec.Metadata
	patchOpMetadata := PatchOp{
		Op:    "replace",
		Path:  "/spec/metadata",
		Value: patchValueMetadata,
	}
	patch = append(patch, patchOpMetadata)

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	if objToUpdate.Spec.Groups != nil {
		patchValueGroups :=
			objToUpdate.Spec.Groups
		patchOpGroups := PatchOp{
			Op:    "replace",
			Path:  "/spec/groups",
			Value: patchValueGroups,
		}
		patch = append(patch, patchOpGroups)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		SecurityContextConstraintses().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalSecurityContextConstraints{
		client:                     group.client,
		SecurityContextConstraints: result,
	}, nil
}

// ListSecurityContextConstraintses returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListSecurityContextConstraintses(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalSecurityContextConstraints, err error) {
	key := "securitycontextconstraintses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalSecurityContextConstraints, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.SecurityContextConstraints)
			result[k] = &GlobalSecurityContextConstraints{
				client:                     group.client,
				SecurityContextConstraints: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			SecurityContextConstraintses().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalSecurityContextConstraints, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalSecurityContextConstraints{
				client:                     group.client,
				SecurityContextConstraints: &item,
			}
		}
	}
	return
}

type GlobalSecurityContextConstraints struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.SecurityContextConstraints
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalSecurityContextConstraints) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteSecurityContextConstraintsByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.SecurityContextConstraints = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalSecurityContextConstraints) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateSecurityContextConstraintsByName(ctx, obj.SecurityContextConstraints)
	if err != nil {
		return err
	}
	obj.SecurityContextConstraints = result.SecurityContextConstraints
	return nil
}

func (obj *GlobalSecurityContextConstraints) GetParent(ctx context.Context) (result *GlobalCluster, err error) {
	hashedName := helper.GetHashedName("clusters.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["clusters.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetClusterByName(ctx, hashedName)
}

type securitycontextconstraintsGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *securitycontextconstraintsGlobalTsmV1Chainer) Subscribe() {
	key := "securitycontextconstraintses.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSecurityContextConstraintsInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *securitycontextconstraintsGlobalTsmV1Chainer) Unsubscribe() {
	key := "securitycontextconstraintses.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *securitycontextconstraintsGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "securitycontextconstraintses.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetServiceConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceConfigByName(ctx context.Context, hashedName string) (*GlobalServiceConfig, error) {
	key := "serviceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceConfig)
		return &GlobalServiceConfig{
			client:        group.client,
			ServiceConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceConfig{
			client:        group.client,
			ServiceConfig: result,
		}, nil
	}
}

// DeleteServiceConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.ServiceVersionGvk {
		err := group.client.
			Global().DeleteServiceVersionConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/servicesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceConfig) (*GlobalServiceConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ServiceVersionGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"servicesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ServiceConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceConfig{
		client:        group.client,
		ServiceConfig: result,
	}, nil
}

// UpdateServiceConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceConfig) (*GlobalServiceConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueOwnedBy :=
		objToUpdate.Spec.OwnedBy
	patchOpOwnedBy := PatchOp{
		Op:    "replace",
		Path:  "/spec/ownedBy",
		Value: patchValueOwnedBy,
	}
	patch = append(patch, patchOpOwnedBy)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceConfig{
		client:        group.client,
		ServiceConfig: result,
	}, nil
}

// ListServiceConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceConfig, err error) {
	key := "serviceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceConfig)
			result[k] = &GlobalServiceConfig{
				client:        group.client,
				ServiceConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceConfig{
				client:        group.client,
				ServiceConfig: &item,
			}
		}
	}
	return
}

type GlobalServiceConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceConfigByName(ctx, obj.ServiceConfig)
	if err != nil {
		return err
	}
	obj.ServiceConfig = result.ServiceConfig
	return nil
}

func (obj *GlobalServiceConfig) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

// GetAllServiceVersion returns all children of given type
func (obj *GlobalServiceConfig) GetAllServiceVersion(ctx context.Context) (
	result []*GlobalServiceVersionConfig, err error) {
	result = make([]*GlobalServiceVersionConfig, 0, len(obj.Spec.ServiceVersionGvk))
	for _, v := range obj.Spec.ServiceVersionGvk {
		l, err := obj.client.Global().GetServiceVersionConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceVersion returns child which has given displayName
func (obj *GlobalServiceConfig) GetServiceVersion(ctx context.Context,
	displayName string) (result *GlobalServiceVersionConfig, err error) {
	l, ok := obj.Spec.ServiceVersionGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ServiceConfig", "ServiceVersion", displayName)
	}
	result, err = obj.client.Global().GetServiceVersionConfigByName(ctx, l.Name)
	return
}

// AddServiceVersion calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalServiceConfig) AddServiceVersion(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceVersionConfig) (result *GlobalServiceVersionConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["serviceconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["serviceconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceVersionConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetServiceConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ServiceConfig = updatedObj.ServiceConfig
	}
	return
}

// DeleteServiceVersion calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalServiceConfig) DeleteServiceVersion(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ServiceVersionGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ServiceConfig", "ServiceVersion", displayName)
	}
	err = obj.client.Global().DeleteServiceVersionConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetServiceConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.ServiceConfig = updatedObj.ServiceConfig
	}
	return
}

type serviceconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *serviceconfigGlobalTsmV1Chainer) Subscribe() {
	key := "serviceconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *serviceconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "serviceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *serviceconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "serviceconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *serviceconfigGlobalTsmV1Chainer) ServiceVersion(name string) *serviceversionconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["serviceversionconfigs.global.tsm.tanzu.vmware.com"] = name
	return &serviceversionconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetServiceVersion calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *serviceconfigGlobalTsmV1Chainer) GetServiceVersion(ctx context.Context, displayName string) (result *GlobalServiceVersionConfig, err error) {
	hashedName := helper.GetHashedName("serviceversionconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceVersionConfigByName(ctx, hashedName)
}

// AddServiceVersion calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *serviceconfigGlobalTsmV1Chainer) AddServiceVersion(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceVersionConfig) (result *GlobalServiceVersionConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("serviceversionconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceVersionConfigByName(ctx, objToCreate)
}

// DeleteServiceVersion calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *serviceconfigGlobalTsmV1Chainer) DeleteServiceVersion(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("serviceversionconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceVersionConfigByName(ctx, hashedName)
}

// GetServiceCronJobByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceCronJobByName(ctx context.Context, hashedName string) (*GlobalServiceCronJob, error) {
	key := "servicecronjobs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceCronJob)
		return &GlobalServiceCronJob{
			client:         group.client,
			ServiceCronJob: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceCronJobs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceCronJob{
			client:         group.client,
			ServiceCronJob: result,
		}, nil
	}
}

// DeleteServiceCronJobByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceCronJobByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceCronJobs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceCronJobs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceCronJobsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceCronJobByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceCronJobByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceCronJob) (*GlobalServiceCronJob, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ServiceInstancesGvk = nil
	objToCreate.Spec.ServiceJobsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceCronJobs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"serviceCronJobsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ServiceCronJob\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceCronJob{
		client:         group.client,
		ServiceCronJob: result,
	}, nil
}

// UpdateServiceCronJobByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceCronJobByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceCronJob) (*GlobalServiceCronJob, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceCronJobs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueMetadata :=
		objToUpdate.Spec.Metadata
	patchOpMetadata := PatchOp{
		Op:    "replace",
		Path:  "/spec/metadata",
		Value: patchValueMetadata,
	}
	patch = append(patch, patchOpMetadata)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	patchValueStatus :=
		objToUpdate.Spec.Status
	patchOpStatus := PatchOp{
		Op:    "replace",
		Path:  "/spec/status",
		Value: patchValueStatus,
	}
	patch = append(patch, patchOpStatus)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceCronJobs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceCronJob{
		client:         group.client,
		ServiceCronJob: result,
	}, nil
}

// ListServiceCronJobs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceCronJobs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceCronJob, err error) {
	key := "servicecronjobs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceCronJob, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceCronJob)
			result[k] = &GlobalServiceCronJob{
				client:         group.client,
				ServiceCronJob: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceCronJobs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceCronJob, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceCronJob{
				client:         group.client,
				ServiceCronJob: &item,
			}
		}
	}
	return
}

type GlobalServiceCronJob struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceCronJob
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceCronJob) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceCronJobByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceCronJob = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceCronJob) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceCronJobByName(ctx, obj.ServiceCronJob)
	if err != nil {
		return err
	}
	obj.ServiceCronJob = result.ServiceCronJob
	return nil
}

func (obj *GlobalServiceCronJob) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

// GetAllServiceInstances returns all links of given type
func (obj *GlobalServiceCronJob) GetAllServiceInstances(ctx context.Context) (
	result []*GlobalServiceInstance, err error) {
	result = make([]*GlobalServiceInstance, 0, len(obj.Spec.ServiceInstancesGvk))
	for _, v := range obj.Spec.ServiceInstancesGvk {
		l, err := obj.client.Global().GetServiceInstanceByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceInstances returns link which has given displayName
func (obj *GlobalServiceCronJob) GetServiceInstances(ctx context.Context,
	displayName string) (result *GlobalServiceInstance, err error) {
	l, ok := obj.Spec.ServiceInstancesGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ServiceCronJob", "ServiceInstances", displayName)
	}
	result, err = obj.client.Global().GetServiceInstanceByName(ctx, l.Name)
	return
}

// LinkServiceInstances links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalServiceCronJob) LinkServiceInstances(ctx context.Context,
	linkToAdd *GlobalServiceInstance) error {

	payload := "{\"spec\": {\"serviceInstancesGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceInstance\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceCronJobs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ServiceCronJob = result
	return nil
}

// UnlinkServiceInstances unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalServiceCronJob) UnlinkServiceInstances(ctx context.Context,
	linkToRemove *GlobalServiceInstance) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceInstancesGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceCronJobs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ServiceCronJob = result
	return nil

}

// GetAllServiceJobs returns all links of given type
func (obj *GlobalServiceCronJob) GetAllServiceJobs(ctx context.Context) (
	result []*GlobalServiceJob, err error) {
	result = make([]*GlobalServiceJob, 0, len(obj.Spec.ServiceJobsGvk))
	for _, v := range obj.Spec.ServiceJobsGvk {
		l, err := obj.client.Global().GetServiceJobByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceJobs returns link which has given displayName
func (obj *GlobalServiceCronJob) GetServiceJobs(ctx context.Context,
	displayName string) (result *GlobalServiceJob, err error) {
	l, ok := obj.Spec.ServiceJobsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ServiceCronJob", "ServiceJobs", displayName)
	}
	result, err = obj.client.Global().GetServiceJobByName(ctx, l.Name)
	return
}

// LinkServiceJobs links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalServiceCronJob) LinkServiceJobs(ctx context.Context,
	linkToAdd *GlobalServiceJob) error {

	payload := "{\"spec\": {\"serviceJobsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceJob\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceCronJobs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ServiceCronJob = result
	return nil
}

// UnlinkServiceJobs unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalServiceCronJob) UnlinkServiceJobs(ctx context.Context,
	linkToRemove *GlobalServiceJob) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceJobsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceCronJobs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ServiceCronJob = result
	return nil

}

type servicecronjobGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *servicecronjobGlobalTsmV1Chainer) Subscribe() {
	key := "servicecronjobs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceCronJobInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *servicecronjobGlobalTsmV1Chainer) Unsubscribe() {
	key := "servicecronjobs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *servicecronjobGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "servicecronjobs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetServiceDaemonSetByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceDaemonSetByName(ctx context.Context, hashedName string) (*GlobalServiceDaemonSet, error) {
	key := "servicedaemonsets.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceDaemonSet)
		return &GlobalServiceDaemonSet{
			client:           group.client,
			ServiceDaemonSet: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceDaemonSets().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceDaemonSet{
			client:           group.client,
			ServiceDaemonSet: result,
		}, nil
	}
}

// DeleteServiceDaemonSetByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceDaemonSetByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDaemonSets().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceDaemonSets().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceDaemonSetsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceDaemonSetByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceDaemonSetByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDaemonSet) (*GlobalServiceDaemonSet, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ServiceInstancesGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDaemonSets().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"serviceDaemonSetsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ServiceDaemonSet\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceDaemonSet{
		client:           group.client,
		ServiceDaemonSet: result,
	}, nil
}

// UpdateServiceDaemonSetByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceDaemonSetByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceDaemonSet) (*GlobalServiceDaemonSet, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceDaemonSets().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueMetadata :=
		objToUpdate.Spec.Metadata
	patchOpMetadata := PatchOp{
		Op:    "replace",
		Path:  "/spec/metadata",
		Value: patchValueMetadata,
	}
	patch = append(patch, patchOpMetadata)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	patchValueStatus :=
		objToUpdate.Spec.Status
	patchOpStatus := PatchOp{
		Op:    "replace",
		Path:  "/spec/status",
		Value: patchValueStatus,
	}
	patch = append(patch, patchOpStatus)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDaemonSets().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceDaemonSet{
		client:           group.client,
		ServiceDaemonSet: result,
	}, nil
}

// ListServiceDaemonSets returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceDaemonSets(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceDaemonSet, err error) {
	key := "servicedaemonsets.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceDaemonSet, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceDaemonSet)
			result[k] = &GlobalServiceDaemonSet{
				client:           group.client,
				ServiceDaemonSet: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceDaemonSets().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceDaemonSet, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceDaemonSet{
				client:           group.client,
				ServiceDaemonSet: &item,
			}
		}
	}
	return
}

type GlobalServiceDaemonSet struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceDaemonSet
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceDaemonSet) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceDaemonSetByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceDaemonSet = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceDaemonSet) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceDaemonSetByName(ctx, obj.ServiceDaemonSet)
	if err != nil {
		return err
	}
	obj.ServiceDaemonSet = result.ServiceDaemonSet
	return nil
}

func (obj *GlobalServiceDaemonSet) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

// GetAllServiceInstances returns all links of given type
func (obj *GlobalServiceDaemonSet) GetAllServiceInstances(ctx context.Context) (
	result []*GlobalServiceInstance, err error) {
	result = make([]*GlobalServiceInstance, 0, len(obj.Spec.ServiceInstancesGvk))
	for _, v := range obj.Spec.ServiceInstancesGvk {
		l, err := obj.client.Global().GetServiceInstanceByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceInstances returns link which has given displayName
func (obj *GlobalServiceDaemonSet) GetServiceInstances(ctx context.Context,
	displayName string) (result *GlobalServiceInstance, err error) {
	l, ok := obj.Spec.ServiceInstancesGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ServiceDaemonSet", "ServiceInstances", displayName)
	}
	result, err = obj.client.Global().GetServiceInstanceByName(ctx, l.Name)
	return
}

// LinkServiceInstances links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalServiceDaemonSet) LinkServiceInstances(ctx context.Context,
	linkToAdd *GlobalServiceInstance) error {

	payload := "{\"spec\": {\"serviceInstancesGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceInstance\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceDaemonSets().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ServiceDaemonSet = result
	return nil
}

// UnlinkServiceInstances unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalServiceDaemonSet) UnlinkServiceInstances(ctx context.Context,
	linkToRemove *GlobalServiceInstance) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceInstancesGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceDaemonSets().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ServiceDaemonSet = result
	return nil

}

type servicedaemonsetGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *servicedaemonsetGlobalTsmV1Chainer) Subscribe() {
	key := "servicedaemonsets.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceDaemonSetInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *servicedaemonsetGlobalTsmV1Chainer) Unsubscribe() {
	key := "servicedaemonsets.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *servicedaemonsetGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "servicedaemonsets.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetServiceDeploymentContainerByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceDeploymentContainerByName(ctx context.Context, hashedName string) (*GlobalServiceDeploymentContainer, error) {
	key := "servicedeploymentcontainers.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceDeploymentContainer)
		return &GlobalServiceDeploymentContainer{
			client:                     group.client,
			ServiceDeploymentContainer: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceDeploymentContainers().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceDeploymentContainer{
			client:                     group.client,
			ServiceDeploymentContainer: result,
		}, nil
	}
}

// DeleteServiceDeploymentContainerByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceDeploymentContainerByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDeploymentContainers().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceDeploymentContainers().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/containersGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["servicedeployments.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("servicedeployments.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ServiceDeployments().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceDeploymentContainerByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceDeploymentContainerByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDeploymentContainer) (*GlobalServiceDeploymentContainer, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDeploymentContainers().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["servicedeployments.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("servicedeployments.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"containersGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ServiceDeploymentContainer\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ServiceDeployments().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceDeploymentContainer{
		client:                     group.client,
		ServiceDeploymentContainer: result,
	}, nil
}

// UpdateServiceDeploymentContainerByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceDeploymentContainerByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceDeploymentContainer) (*GlobalServiceDeploymentContainer, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceDeploymentContainers().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueImage :=
		objToUpdate.Spec.Image
	patchOpImage := PatchOp{
		Op:    "replace",
		Path:  "/spec/image",
		Value: patchValueImage,
	}
	patch = append(patch, patchOpImage)

	patchValueImagePullPolicy :=
		objToUpdate.Spec.ImagePullPolicy
	patchOpImagePullPolicy := PatchOp{
		Op:    "replace",
		Path:  "/spec/imagePullPolicy",
		Value: patchValueImagePullPolicy,
	}
	patch = append(patch, patchOpImagePullPolicy)

	patchValueTerminationMessagePath :=
		objToUpdate.Spec.TerminationMessagePath
	patchOpTerminationMessagePath := PatchOp{
		Op:    "replace",
		Path:  "/spec/terminationMessagePath",
		Value: patchValueTerminationMessagePath,
	}
	patch = append(patch, patchOpTerminationMessagePath)

	patchValueTerminationMessagePolicy :=
		objToUpdate.Spec.TerminationMessagePolicy
	patchOpTerminationMessagePolicy := PatchOp{
		Op:    "replace",
		Path:  "/spec/terminationMessagePolicy",
		Value: patchValueTerminationMessagePolicy,
	}
	patch = append(patch, patchOpTerminationMessagePolicy)

	patchValueArgs :=
		objToUpdate.Spec.Args
	patchOpArgs := PatchOp{
		Op:    "replace",
		Path:  "/spec/args",
		Value: patchValueArgs,
	}
	patch = append(patch, patchOpArgs)

	patchValueEnv :=
		objToUpdate.Spec.Env
	patchOpEnv := PatchOp{
		Op:    "replace",
		Path:  "/spec/env",
		Value: patchValueEnv,
	}
	patch = append(patch, patchOpEnv)

	patchValueLivenessProbe :=
		objToUpdate.Spec.LivenessProbe
	patchOpLivenessProbe := PatchOp{
		Op:    "replace",
		Path:  "/spec/livenessProbe",
		Value: patchValueLivenessProbe,
	}
	patch = append(patch, patchOpLivenessProbe)

	patchValueReadinessProbe :=
		objToUpdate.Spec.ReadinessProbe
	patchOpReadinessProbe := PatchOp{
		Op:    "replace",
		Path:  "/spec/readinessProbe",
		Value: patchValueReadinessProbe,
	}
	patch = append(patch, patchOpReadinessProbe)

	patchValuePorts :=
		objToUpdate.Spec.Ports
	patchOpPorts := PatchOp{
		Op:    "replace",
		Path:  "/spec/ports",
		Value: patchValuePorts,
	}
	patch = append(patch, patchOpPorts)

	patchValueResources :=
		objToUpdate.Spec.Resources
	patchOpResources := PatchOp{
		Op:    "replace",
		Path:  "/spec/resources",
		Value: patchValueResources,
	}
	patch = append(patch, patchOpResources)

	patchValueVolumeMounts :=
		objToUpdate.Spec.VolumeMounts
	patchOpVolumeMounts := PatchOp{
		Op:    "replace",
		Path:  "/spec/volumeMounts",
		Value: patchValueVolumeMounts,
	}
	patch = append(patch, patchOpVolumeMounts)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDeploymentContainers().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceDeploymentContainer{
		client:                     group.client,
		ServiceDeploymentContainer: result,
	}, nil
}

// ListServiceDeploymentContainers returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceDeploymentContainers(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceDeploymentContainer, err error) {
	key := "servicedeploymentcontainers.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceDeploymentContainer, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceDeploymentContainer)
			result[k] = &GlobalServiceDeploymentContainer{
				client:                     group.client,
				ServiceDeploymentContainer: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceDeploymentContainers().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceDeploymentContainer, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceDeploymentContainer{
				client:                     group.client,
				ServiceDeploymentContainer: &item,
			}
		}
	}
	return
}

type GlobalServiceDeploymentContainer struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceDeploymentContainer
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceDeploymentContainer) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceDeploymentContainerByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceDeploymentContainer = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceDeploymentContainer) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceDeploymentContainerByName(ctx, obj.ServiceDeploymentContainer)
	if err != nil {
		return err
	}
	obj.ServiceDeploymentContainer = result.ServiceDeploymentContainer
	return nil
}

func (obj *GlobalServiceDeploymentContainer) GetParent(ctx context.Context) (result *GlobalServiceDeployment, err error) {
	hashedName := helper.GetHashedName("servicedeployments.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["servicedeployments.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetServiceDeploymentByName(ctx, hashedName)
}

type servicedeploymentcontainerGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *servicedeploymentcontainerGlobalTsmV1Chainer) Subscribe() {
	key := "servicedeploymentcontainers.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceDeploymentContainerInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *servicedeploymentcontainerGlobalTsmV1Chainer) Unsubscribe() {
	key := "servicedeploymentcontainers.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *servicedeploymentcontainerGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "servicedeploymentcontainers.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetServiceDeploymentByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceDeploymentByName(ctx context.Context, hashedName string) (*GlobalServiceDeployment, error) {
	key := "servicedeployments.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceDeployment)
		return &GlobalServiceDeployment{
			client:            group.client,
			ServiceDeployment: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceDeployments().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceDeployment{
			client:            group.client,
			ServiceDeployment: result,
		}, nil
	}
}

// DeleteServiceDeploymentByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceDeploymentByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDeployments().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.ContainersGvk {
		err := group.client.
			Global().DeleteServiceDeploymentContainerByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceDeployments().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceDeploymentsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceDeploymentByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceDeploymentByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDeployment) (*GlobalServiceDeployment, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ContainersGvk = nil
	objToCreate.Spec.ServiceInstancesGvk = nil
	objToCreate.Spec.ServiceReplicaSetGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDeployments().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"serviceDeploymentsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ServiceDeployment\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceDeployment{
		client:            group.client,
		ServiceDeployment: result,
	}, nil
}

// UpdateServiceDeploymentByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceDeploymentByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceDeployment) (*GlobalServiceDeployment, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceDeployments().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueMetadata :=
		objToUpdate.Spec.Metadata
	patchOpMetadata := PatchOp{
		Op:    "replace",
		Path:  "/spec/metadata",
		Value: patchValueMetadata,
	}
	patch = append(patch, patchOpMetadata)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	patchValueStatus :=
		objToUpdate.Spec.Status
	patchOpStatus := PatchOp{
		Op:    "replace",
		Path:  "/spec/status",
		Value: patchValueStatus,
	}
	patch = append(patch, patchOpStatus)

	patchValueNamespace :=
		objToUpdate.Spec.Namespace
	patchOpNamespace := PatchOp{
		Op:    "replace",
		Path:  "/spec/namespace",
		Value: patchValueNamespace,
	}
	patch = append(patch, patchOpNamespace)

	patchValueAnnotations :=
		objToUpdate.Spec.Annotations
	patchOpAnnotations := PatchOp{
		Op:    "replace",
		Path:  "/spec/annotations",
		Value: patchValueAnnotations,
	}
	patch = append(patch, patchOpAnnotations)

	patchValueCreationTimestamp :=
		objToUpdate.Spec.CreationTimestamp
	patchOpCreationTimestamp := PatchOp{
		Op:    "replace",
		Path:  "/spec/creationTimestamp",
		Value: patchValueCreationTimestamp,
	}
	patch = append(patch, patchOpCreationTimestamp)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueApiLink :=
		objToUpdate.Spec.ApiLink
	patchOpApiLink := PatchOp{
		Op:    "replace",
		Path:  "/spec/apiLink",
		Value: patchValueApiLink,
	}
	patch = append(patch, patchOpApiLink)

	patchValueUid :=
		objToUpdate.Spec.Uid
	patchOpUid := PatchOp{
		Op:    "replace",
		Path:  "/spec/uid",
		Value: patchValueUid,
	}
	patch = append(patch, patchOpUid)

	patchValueGeneration :=
		objToUpdate.Spec.Generation
	patchOpGeneration := PatchOp{
		Op:    "replace",
		Path:  "/spec/generation",
		Value: patchValueGeneration,
	}
	patch = append(patch, patchOpGeneration)

	patchValueSelector :=
		objToUpdate.Spec.Selector
	patchOpSelector := PatchOp{
		Op:    "replace",
		Path:  "/spec/selector",
		Value: patchValueSelector,
	}
	patch = append(patch, patchOpSelector)

	patchValueReplicas :=
		objToUpdate.Spec.Replicas
	patchOpReplicas := PatchOp{
		Op:    "replace",
		Path:  "/spec/replicas",
		Value: patchValueReplicas,
	}
	patch = append(patch, patchOpReplicas)

	patchValueDnsPolicy :=
		objToUpdate.Spec.DnsPolicy
	patchOpDnsPolicy := PatchOp{
		Op:    "replace",
		Path:  "/spec/dnsPolicy",
		Value: patchValueDnsPolicy,
	}
	patch = append(patch, patchOpDnsPolicy)

	patchValueRestartPolicy :=
		objToUpdate.Spec.RestartPolicy
	patchOpRestartPolicy := PatchOp{
		Op:    "replace",
		Path:  "/spec/restartPolicy",
		Value: patchValueRestartPolicy,
	}
	patch = append(patch, patchOpRestartPolicy)

	patchValueSchedulerName :=
		objToUpdate.Spec.SchedulerName
	patchOpSchedulerName := PatchOp{
		Op:    "replace",
		Path:  "/spec/schedulerName",
		Value: patchValueSchedulerName,
	}
	patch = append(patch, patchOpSchedulerName)

	patchValueSecurityContext :=
		objToUpdate.Spec.SecurityContext
	patchOpSecurityContext := PatchOp{
		Op:    "replace",
		Path:  "/spec/securityContext",
		Value: patchValueSecurityContext,
	}
	patch = append(patch, patchOpSecurityContext)

	patchValueServiceAccount :=
		objToUpdate.Spec.ServiceAccount
	patchOpServiceAccount := PatchOp{
		Op:    "replace",
		Path:  "/spec/serviceAccount",
		Value: patchValueServiceAccount,
	}
	patch = append(patch, patchOpServiceAccount)

	patchValueServiceAccountName :=
		objToUpdate.Spec.ServiceAccountName
	patchOpServiceAccountName := PatchOp{
		Op:    "replace",
		Path:  "/spec/serviceAccountName",
		Value: patchValueServiceAccountName,
	}
	patch = append(patch, patchOpServiceAccountName)

	patchValueTerminationGracePeriodSeconds :=
		objToUpdate.Spec.TerminationGracePeriodSeconds
	patchOpTerminationGracePeriodSeconds := PatchOp{
		Op:    "replace",
		Path:  "/spec/terminationGracePeriodSeconds",
		Value: patchValueTerminationGracePeriodSeconds,
	}
	patch = append(patch, patchOpTerminationGracePeriodSeconds)

	patchValueVolumes :=
		objToUpdate.Spec.Volumes
	patchOpVolumes := PatchOp{
		Op:    "replace",
		Path:  "/spec/volumes",
		Value: patchValueVolumes,
	}
	patch = append(patch, patchOpVolumes)

	patchValueTemplateLabels :=
		objToUpdate.Spec.TemplateLabels
	patchOpTemplateLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/templateLabels",
		Value: patchValueTemplateLabels,
	}
	patch = append(patch, patchOpTemplateLabels)

	patchValueStatusReplicas :=
		objToUpdate.Spec.StatusReplicas
	patchOpStatusReplicas := PatchOp{
		Op:    "replace",
		Path:  "/spec/statusReplicas",
		Value: patchValueStatusReplicas,
	}
	patch = append(patch, patchOpStatusReplicas)

	patchValueAvailableReplicas :=
		objToUpdate.Spec.AvailableReplicas
	patchOpAvailableReplicas := PatchOp{
		Op:    "replace",
		Path:  "/spec/availableReplicas",
		Value: patchValueAvailableReplicas,
	}
	patch = append(patch, patchOpAvailableReplicas)

	patchValueUpdatedReplicas :=
		objToUpdate.Spec.UpdatedReplicas
	patchOpUpdatedReplicas := PatchOp{
		Op:    "replace",
		Path:  "/spec/updatedReplicas",
		Value: patchValueUpdatedReplicas,
	}
	patch = append(patch, patchOpUpdatedReplicas)

	patchValueReadyReplicas :=
		objToUpdate.Spec.ReadyReplicas
	patchOpReadyReplicas := PatchOp{
		Op:    "replace",
		Path:  "/spec/readyReplicas",
		Value: patchValueReadyReplicas,
	}
	patch = append(patch, patchOpReadyReplicas)

	patchValueObservedGeneration :=
		objToUpdate.Spec.ObservedGeneration
	patchOpObservedGeneration := PatchOp{
		Op:    "replace",
		Path:  "/spec/observedGeneration",
		Value: patchValueObservedGeneration,
	}
	patch = append(patch, patchOpObservedGeneration)

	patchValueConditions :=
		objToUpdate.Spec.Conditions
	patchOpConditions := PatchOp{
		Op:    "replace",
		Path:  "/spec/conditions",
		Value: patchValueConditions,
	}
	patch = append(patch, patchOpConditions)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDeployments().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceDeployment{
		client:            group.client,
		ServiceDeployment: result,
	}, nil
}

// ListServiceDeployments returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceDeployments(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceDeployment, err error) {
	key := "servicedeployments.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceDeployment, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceDeployment)
			result[k] = &GlobalServiceDeployment{
				client:            group.client,
				ServiceDeployment: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceDeployments().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceDeployment, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceDeployment{
				client:            group.client,
				ServiceDeployment: &item,
			}
		}
	}
	return
}

type GlobalServiceDeployment struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceDeployment
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceDeployment) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceDeploymentByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceDeployment = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceDeployment) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceDeploymentByName(ctx, obj.ServiceDeployment)
	if err != nil {
		return err
	}
	obj.ServiceDeployment = result.ServiceDeployment
	return nil
}

func (obj *GlobalServiceDeployment) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

// GetAllContainers returns all children of given type
func (obj *GlobalServiceDeployment) GetAllContainers(ctx context.Context) (
	result []*GlobalServiceDeploymentContainer, err error) {
	result = make([]*GlobalServiceDeploymentContainer, 0, len(obj.Spec.ContainersGvk))
	for _, v := range obj.Spec.ContainersGvk {
		l, err := obj.client.Global().GetServiceDeploymentContainerByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetContainers returns child which has given displayName
func (obj *GlobalServiceDeployment) GetContainers(ctx context.Context,
	displayName string) (result *GlobalServiceDeploymentContainer, err error) {
	l, ok := obj.Spec.ContainersGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ServiceDeployment", "Containers", displayName)
	}
	result, err = obj.client.Global().GetServiceDeploymentContainerByName(ctx, l.Name)
	return
}

// AddContainers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalServiceDeployment) AddContainers(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDeploymentContainer) (result *GlobalServiceDeploymentContainer, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["servicedeployments.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["servicedeployments.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceDeploymentContainerByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetServiceDeploymentByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ServiceDeployment = updatedObj.ServiceDeployment
	}
	return
}

// DeleteContainers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalServiceDeployment) DeleteContainers(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ContainersGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ServiceDeployment", "Containers", displayName)
	}
	err = obj.client.Global().DeleteServiceDeploymentContainerByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetServiceDeploymentByName(ctx, obj.GetName())
	if err == nil {
		obj.ServiceDeployment = updatedObj.ServiceDeployment
	}
	return
}

// GetAllServiceInstances returns all links of given type
func (obj *GlobalServiceDeployment) GetAllServiceInstances(ctx context.Context) (
	result []*GlobalServiceInstance, err error) {
	result = make([]*GlobalServiceInstance, 0, len(obj.Spec.ServiceInstancesGvk))
	for _, v := range obj.Spec.ServiceInstancesGvk {
		l, err := obj.client.Global().GetServiceInstanceByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceInstances returns link which has given displayName
func (obj *GlobalServiceDeployment) GetServiceInstances(ctx context.Context,
	displayName string) (result *GlobalServiceInstance, err error) {
	l, ok := obj.Spec.ServiceInstancesGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ServiceDeployment", "ServiceInstances", displayName)
	}
	result, err = obj.client.Global().GetServiceInstanceByName(ctx, l.Name)
	return
}

// LinkServiceInstances links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalServiceDeployment) LinkServiceInstances(ctx context.Context,
	linkToAdd *GlobalServiceInstance) error {

	payload := "{\"spec\": {\"serviceInstancesGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceInstance\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceDeployments().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ServiceDeployment = result
	return nil
}

// UnlinkServiceInstances unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalServiceDeployment) UnlinkServiceInstances(ctx context.Context,
	linkToRemove *GlobalServiceInstance) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceInstancesGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceDeployments().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ServiceDeployment = result
	return nil

}

// GetAllServiceReplicaSet returns all links of given type
func (obj *GlobalServiceDeployment) GetAllServiceReplicaSet(ctx context.Context) (
	result []*GlobalServiceReplicaSet, err error) {
	result = make([]*GlobalServiceReplicaSet, 0, len(obj.Spec.ServiceReplicaSetGvk))
	for _, v := range obj.Spec.ServiceReplicaSetGvk {
		l, err := obj.client.Global().GetServiceReplicaSetByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceReplicaSet returns link which has given displayName
func (obj *GlobalServiceDeployment) GetServiceReplicaSet(ctx context.Context,
	displayName string) (result *GlobalServiceReplicaSet, err error) {
	l, ok := obj.Spec.ServiceReplicaSetGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ServiceDeployment", "ServiceReplicaSet", displayName)
	}
	result, err = obj.client.Global().GetServiceReplicaSetByName(ctx, l.Name)
	return
}

// LinkServiceReplicaSet links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalServiceDeployment) LinkServiceReplicaSet(ctx context.Context,
	linkToAdd *GlobalServiceReplicaSet) error {

	payload := "{\"spec\": {\"serviceReplicaSetGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceReplicaSet\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceDeployments().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ServiceDeployment = result
	return nil
}

// UnlinkServiceReplicaSet unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalServiceDeployment) UnlinkServiceReplicaSet(ctx context.Context,
	linkToRemove *GlobalServiceReplicaSet) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceReplicaSetGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceDeployments().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ServiceDeployment = result
	return nil

}

type servicedeploymentGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *servicedeploymentGlobalTsmV1Chainer) Subscribe() {
	key := "servicedeployments.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceDeploymentInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *servicedeploymentGlobalTsmV1Chainer) Unsubscribe() {
	key := "servicedeployments.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *servicedeploymentGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "servicedeployments.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *servicedeploymentGlobalTsmV1Chainer) Containers(name string) *servicedeploymentcontainerGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["servicedeploymentcontainers.global.tsm.tanzu.vmware.com"] = name
	return &servicedeploymentcontainerGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetContainers calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *servicedeploymentGlobalTsmV1Chainer) GetContainers(ctx context.Context, displayName string) (result *GlobalServiceDeploymentContainer, err error) {
	hashedName := helper.GetHashedName("servicedeploymentcontainers.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceDeploymentContainerByName(ctx, hashedName)
}

// AddContainers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *servicedeploymentGlobalTsmV1Chainer) AddContainers(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDeploymentContainer) (result *GlobalServiceDeploymentContainer, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("servicedeploymentcontainers.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceDeploymentContainerByName(ctx, objToCreate)
}

// DeleteContainers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *servicedeploymentGlobalTsmV1Chainer) DeleteContainers(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("servicedeploymentcontainers.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceDeploymentContainerByName(ctx, hashedName)
}

// GetServiceDirectoryEntryConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceDirectoryEntryConfigByName(ctx context.Context, hashedName string) (*GlobalServiceDirectoryEntryConfig, error) {
	key := "servicedirectoryentryconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryEntryConfig)
		return &GlobalServiceDirectoryEntryConfig{
			client:                      group.client,
			ServiceDirectoryEntryConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceDirectoryEntryConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceDirectoryEntryConfig{
			client:                      group.client,
			ServiceDirectoryEntryConfig: result,
		}, nil
	}
}

// DeleteServiceDirectoryEntryConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceDirectoryEntryConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryEntryConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryEntryConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/entriesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["servicedirectoryns.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("servicedirectoryns.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryNs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceDirectoryEntryConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceDirectoryEntryConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryEntryConfig) (*GlobalServiceDirectoryEntryConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryEntryConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["servicedirectoryns.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("servicedirectoryns.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"entriesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ServiceDirectoryEntryConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryNs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceDirectoryEntryConfig{
		client:                      group.client,
		ServiceDirectoryEntryConfig: result,
	}, nil
}

// UpdateServiceDirectoryEntryConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceDirectoryEntryConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryEntryConfig) (*GlobalServiceDirectoryEntryConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceDirectoryEntryConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryEntryConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceDirectoryEntryConfig{
		client:                      group.client,
		ServiceDirectoryEntryConfig: result,
	}, nil
}

// ListServiceDirectoryEntryConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceDirectoryEntryConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceDirectoryEntryConfig, err error) {
	key := "servicedirectoryentryconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceDirectoryEntryConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryEntryConfig)
			result[k] = &GlobalServiceDirectoryEntryConfig{
				client:                      group.client,
				ServiceDirectoryEntryConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceDirectoryEntryConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceDirectoryEntryConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceDirectoryEntryConfig{
				client:                      group.client,
				ServiceDirectoryEntryConfig: &item,
			}
		}
	}
	return
}

type GlobalServiceDirectoryEntryConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryEntryConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceDirectoryEntryConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceDirectoryEntryConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceDirectoryEntryConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceDirectoryEntryConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceDirectoryEntryConfigByName(ctx, obj.ServiceDirectoryEntryConfig)
	if err != nil {
		return err
	}
	obj.ServiceDirectoryEntryConfig = result.ServiceDirectoryEntryConfig
	return nil
}

func (obj *GlobalServiceDirectoryEntryConfig) GetParent(ctx context.Context) (result *GlobalServiceDirectoryN, err error) {
	hashedName := helper.GetHashedName("servicedirectoryns.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["servicedirectoryns.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetServiceDirectoryNByName(ctx, hashedName)
}

type servicedirectoryentryconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *servicedirectoryentryconfigGlobalTsmV1Chainer) Subscribe() {
	key := "servicedirectoryentryconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceDirectoryEntryConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *servicedirectoryentryconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "servicedirectoryentryconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *servicedirectoryentryconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "servicedirectoryentryconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetServiceDirectoryRTFolderEntryByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceDirectoryRTFolderEntryByName(ctx context.Context, hashedName string) (*GlobalServiceDirectoryRTFolderEntry, error) {
	key := "servicedirectoryrtfolderentries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryRTFolderEntry)
		return &GlobalServiceDirectoryRTFolderEntry{
			client:                        group.client,
			ServiceDirectoryRTFolderEntry: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceDirectoryRTFolderEntries().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceDirectoryRTFolderEntry{
			client:                        group.client,
			ServiceDirectoryRTFolderEntry: result,
		}, nil
	}
}

// DeleteServiceDirectoryRTFolderEntryByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceDirectoryRTFolderEntryByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryRTFolderEntries().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryRTFolderEntries().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceDirectoryRTFolderEntryGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["servicedirectoryrtfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("servicedirectoryrtfolders.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryRTFolders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceDirectoryRTFolderEntryByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceDirectoryRTFolderEntryByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryRTFolderEntry) (*GlobalServiceDirectoryRTFolderEntry, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryRTFolderEntries().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["servicedirectoryrtfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("servicedirectoryrtfolders.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"serviceDirectoryRTFolderEntryGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ServiceDirectoryRTFolderEntry\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryRTFolders().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceDirectoryRTFolderEntry{
		client:                        group.client,
		ServiceDirectoryRTFolderEntry: result,
	}, nil
}

// UpdateServiceDirectoryRTFolderEntryByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceDirectoryRTFolderEntryByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryRTFolderEntry) (*GlobalServiceDirectoryRTFolderEntry, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceDirectoryRTFolderEntries().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	patchValueSpec_type :=
		objToUpdate.Spec.Spec_type
	patchOpSpec_type := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec_type",
		Value: patchValueSpec_type,
	}
	patch = append(patch, patchOpSpec_type)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryRTFolderEntries().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceDirectoryRTFolderEntry{
		client:                        group.client,
		ServiceDirectoryRTFolderEntry: result,
	}, nil
}

// ListServiceDirectoryRTFolderEntries returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceDirectoryRTFolderEntries(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceDirectoryRTFolderEntry, err error) {
	key := "servicedirectoryrtfolderentries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceDirectoryRTFolderEntry, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryRTFolderEntry)
			result[k] = &GlobalServiceDirectoryRTFolderEntry{
				client:                        group.client,
				ServiceDirectoryRTFolderEntry: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceDirectoryRTFolderEntries().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceDirectoryRTFolderEntry, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceDirectoryRTFolderEntry{
				client:                        group.client,
				ServiceDirectoryRTFolderEntry: &item,
			}
		}
	}
	return
}

type GlobalServiceDirectoryRTFolderEntry struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryRTFolderEntry
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceDirectoryRTFolderEntry) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceDirectoryRTFolderEntryByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceDirectoryRTFolderEntry = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceDirectoryRTFolderEntry) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceDirectoryRTFolderEntryByName(ctx, obj.ServiceDirectoryRTFolderEntry)
	if err != nil {
		return err
	}
	obj.ServiceDirectoryRTFolderEntry = result.ServiceDirectoryRTFolderEntry
	return nil
}

func (obj *GlobalServiceDirectoryRTFolderEntry) GetParent(ctx context.Context) (result *GlobalServiceDirectoryRTFolder, err error) {
	hashedName := helper.GetHashedName("servicedirectoryrtfolders.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["servicedirectoryrtfolders.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetServiceDirectoryRTFolderByName(ctx, hashedName)
}

type servicedirectoryrtfolderentryGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *servicedirectoryrtfolderentryGlobalTsmV1Chainer) Subscribe() {
	key := "servicedirectoryrtfolderentries.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceDirectoryRTFolderEntryInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *servicedirectoryrtfolderentryGlobalTsmV1Chainer) Unsubscribe() {
	key := "servicedirectoryrtfolderentries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *servicedirectoryrtfolderentryGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "servicedirectoryrtfolderentries.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetServiceDirectoryRTFolderByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceDirectoryRTFolderByName(ctx context.Context, hashedName string) (*GlobalServiceDirectoryRTFolder, error) {
	key := "servicedirectoryrtfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryRTFolder)
		return &GlobalServiceDirectoryRTFolder{
			client:                   group.client,
			ServiceDirectoryRTFolder: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceDirectoryRTFolders().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceDirectoryRTFolder{
			client:                   group.client,
			ServiceDirectoryRTFolder: result,
		}, nil
	}
}

// DeleteServiceDirectoryRTFolderByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceDirectoryRTFolderByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryRTFolders().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.ServiceDirectoryRTFolderEntryGvk {
		err := group.client.
			Global().DeleteServiceDirectoryRTFolderEntryByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryRTFolders().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceDirectoryRTFolderGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["servicedirectoryrts.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("servicedirectoryrts.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryRTs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceDirectoryRTFolderByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceDirectoryRTFolderByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryRTFolder) (*GlobalServiceDirectoryRTFolder, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ServiceDirectoryRTFolderEntryGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryRTFolders().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["servicedirectoryrts.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("servicedirectoryrts.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"serviceDirectoryRTFolderGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ServiceDirectoryRTFolder\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryRTs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceDirectoryRTFolder{
		client:                   group.client,
		ServiceDirectoryRTFolder: result,
	}, nil
}

// UpdateServiceDirectoryRTFolderByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceDirectoryRTFolderByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryRTFolder) (*GlobalServiceDirectoryRTFolder, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceDirectoryRTFolders().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryRTFolders().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceDirectoryRTFolder{
		client:                   group.client,
		ServiceDirectoryRTFolder: result,
	}, nil
}

// ListServiceDirectoryRTFolders returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceDirectoryRTFolders(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceDirectoryRTFolder, err error) {
	key := "servicedirectoryrtfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceDirectoryRTFolder, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryRTFolder)
			result[k] = &GlobalServiceDirectoryRTFolder{
				client:                   group.client,
				ServiceDirectoryRTFolder: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceDirectoryRTFolders().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceDirectoryRTFolder, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceDirectoryRTFolder{
				client:                   group.client,
				ServiceDirectoryRTFolder: &item,
			}
		}
	}
	return
}

type GlobalServiceDirectoryRTFolder struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryRTFolder
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceDirectoryRTFolder) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceDirectoryRTFolderByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceDirectoryRTFolder = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceDirectoryRTFolder) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceDirectoryRTFolderByName(ctx, obj.ServiceDirectoryRTFolder)
	if err != nil {
		return err
	}
	obj.ServiceDirectoryRTFolder = result.ServiceDirectoryRTFolder
	return nil
}

func (obj *GlobalServiceDirectoryRTFolder) GetParent(ctx context.Context) (result *GlobalServiceDirectoryRT, err error) {
	hashedName := helper.GetHashedName("servicedirectoryrts.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["servicedirectoryrts.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetServiceDirectoryRTByName(ctx, hashedName)
}

// GetAllServiceDirectoryRTFolderEntry returns all children of given type
func (obj *GlobalServiceDirectoryRTFolder) GetAllServiceDirectoryRTFolderEntry(ctx context.Context) (
	result []*GlobalServiceDirectoryRTFolderEntry, err error) {
	result = make([]*GlobalServiceDirectoryRTFolderEntry, 0, len(obj.Spec.ServiceDirectoryRTFolderEntryGvk))
	for _, v := range obj.Spec.ServiceDirectoryRTFolderEntryGvk {
		l, err := obj.client.Global().GetServiceDirectoryRTFolderEntryByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceDirectoryRTFolderEntry returns child which has given displayName
func (obj *GlobalServiceDirectoryRTFolder) GetServiceDirectoryRTFolderEntry(ctx context.Context,
	displayName string) (result *GlobalServiceDirectoryRTFolderEntry, err error) {
	l, ok := obj.Spec.ServiceDirectoryRTFolderEntryGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ServiceDirectoryRTFolder", "ServiceDirectoryRTFolderEntry", displayName)
	}
	result, err = obj.client.Global().GetServiceDirectoryRTFolderEntryByName(ctx, l.Name)
	return
}

// AddServiceDirectoryRTFolderEntry calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalServiceDirectoryRTFolder) AddServiceDirectoryRTFolderEntry(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryRTFolderEntry) (result *GlobalServiceDirectoryRTFolderEntry, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["servicedirectoryrtfolders.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["servicedirectoryrtfolders.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceDirectoryRTFolderEntryByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetServiceDirectoryRTFolderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ServiceDirectoryRTFolder = updatedObj.ServiceDirectoryRTFolder
	}
	return
}

// DeleteServiceDirectoryRTFolderEntry calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalServiceDirectoryRTFolder) DeleteServiceDirectoryRTFolderEntry(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ServiceDirectoryRTFolderEntryGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ServiceDirectoryRTFolder", "ServiceDirectoryRTFolderEntry", displayName)
	}
	err = obj.client.Global().DeleteServiceDirectoryRTFolderEntryByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetServiceDirectoryRTFolderByName(ctx, obj.GetName())
	if err == nil {
		obj.ServiceDirectoryRTFolder = updatedObj.ServiceDirectoryRTFolder
	}
	return
}

type servicedirectoryrtfolderGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *servicedirectoryrtfolderGlobalTsmV1Chainer) Subscribe() {
	key := "servicedirectoryrtfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceDirectoryRTFolderInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *servicedirectoryrtfolderGlobalTsmV1Chainer) Unsubscribe() {
	key := "servicedirectoryrtfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *servicedirectoryrtfolderGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "servicedirectoryrtfolders.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *servicedirectoryrtfolderGlobalTsmV1Chainer) ServiceDirectoryRTFolderEntry(name string) *servicedirectoryrtfolderentryGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["servicedirectoryrtfolderentries.global.tsm.tanzu.vmware.com"] = name
	return &servicedirectoryrtfolderentryGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetServiceDirectoryRTFolderEntry calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *servicedirectoryrtfolderGlobalTsmV1Chainer) GetServiceDirectoryRTFolderEntry(ctx context.Context, displayName string) (result *GlobalServiceDirectoryRTFolderEntry, err error) {
	hashedName := helper.GetHashedName("servicedirectoryrtfolderentries.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceDirectoryRTFolderEntryByName(ctx, hashedName)
}

// AddServiceDirectoryRTFolderEntry calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *servicedirectoryrtfolderGlobalTsmV1Chainer) AddServiceDirectoryRTFolderEntry(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryRTFolderEntry) (result *GlobalServiceDirectoryRTFolderEntry, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("servicedirectoryrtfolderentries.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceDirectoryRTFolderEntryByName(ctx, objToCreate)
}

// DeleteServiceDirectoryRTFolderEntry calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *servicedirectoryrtfolderGlobalTsmV1Chainer) DeleteServiceDirectoryRTFolderEntry(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("servicedirectoryrtfolderentries.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceDirectoryRTFolderEntryByName(ctx, hashedName)
}

// GetServiceDirectoryRTByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceDirectoryRTByName(ctx context.Context, hashedName string) (*GlobalServiceDirectoryRT, error) {
	key := "servicedirectoryrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryRT)
		return &GlobalServiceDirectoryRT{
			client:             group.client,
			ServiceDirectoryRT: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceDirectoryRTs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceDirectoryRT{
			client:             group.client,
			ServiceDirectoryRT: result,
		}, nil
	}
}

// DeleteServiceDirectoryRTByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceDirectoryRTByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryRTs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.ServiceDirectoryRTFolderGvk {
		err := group.client.
			Global().DeleteServiceDirectoryRTFolderByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryRTs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceDirectoryRTGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["runtimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceDirectoryRTByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceDirectoryRTByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryRT) (*GlobalServiceDirectoryRT, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.ServiceDirectoryRTFolderGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryRTs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["runtimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/serviceDirectoryRTGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "ServiceDirectoryRT",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceDirectoryRT{
		client:             group.client,
		ServiceDirectoryRT: result,
	}, nil
}

// UpdateServiceDirectoryRTByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceDirectoryRTByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryRT) (*GlobalServiceDirectoryRT, error) {
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceDirectoryRTs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryRTs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceDirectoryRT{
		client:             group.client,
		ServiceDirectoryRT: result,
	}, nil
}

// ListServiceDirectoryRTs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceDirectoryRTs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceDirectoryRT, err error) {
	key := "servicedirectoryrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceDirectoryRT, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryRT)
			result[k] = &GlobalServiceDirectoryRT{
				client:             group.client,
				ServiceDirectoryRT: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceDirectoryRTs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceDirectoryRT, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceDirectoryRT{
				client:             group.client,
				ServiceDirectoryRT: &item,
			}
		}
	}
	return
}

type GlobalServiceDirectoryRT struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryRT
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceDirectoryRT) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceDirectoryRTByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceDirectoryRT = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceDirectoryRT) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceDirectoryRTByName(ctx, obj.ServiceDirectoryRT)
	if err != nil {
		return err
	}
	obj.ServiceDirectoryRT = result.ServiceDirectoryRT
	return nil
}

func (obj *GlobalServiceDirectoryRT) GetParent(ctx context.Context) (result *GlobalRuntime, err error) {
	hashedName := helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["runtimes.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetRuntimeByName(ctx, hashedName)
}

// GetAllServiceDirectoryRTFolder returns all children of given type
func (obj *GlobalServiceDirectoryRT) GetAllServiceDirectoryRTFolder(ctx context.Context) (
	result []*GlobalServiceDirectoryRTFolder, err error) {
	result = make([]*GlobalServiceDirectoryRTFolder, 0, len(obj.Spec.ServiceDirectoryRTFolderGvk))
	for _, v := range obj.Spec.ServiceDirectoryRTFolderGvk {
		l, err := obj.client.Global().GetServiceDirectoryRTFolderByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceDirectoryRTFolder returns child which has given displayName
func (obj *GlobalServiceDirectoryRT) GetServiceDirectoryRTFolder(ctx context.Context,
	displayName string) (result *GlobalServiceDirectoryRTFolder, err error) {
	l, ok := obj.Spec.ServiceDirectoryRTFolderGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ServiceDirectoryRT", "ServiceDirectoryRTFolder", displayName)
	}
	result, err = obj.client.Global().GetServiceDirectoryRTFolderByName(ctx, l.Name)
	return
}

// AddServiceDirectoryRTFolder calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalServiceDirectoryRT) AddServiceDirectoryRTFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryRTFolder) (result *GlobalServiceDirectoryRTFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["servicedirectoryrts.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["servicedirectoryrts.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceDirectoryRTFolderByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetServiceDirectoryRTByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ServiceDirectoryRT = updatedObj.ServiceDirectoryRT
	}
	return
}

// DeleteServiceDirectoryRTFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalServiceDirectoryRT) DeleteServiceDirectoryRTFolder(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ServiceDirectoryRTFolderGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ServiceDirectoryRT", "ServiceDirectoryRTFolder", displayName)
	}
	err = obj.client.Global().DeleteServiceDirectoryRTFolderByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetServiceDirectoryRTByName(ctx, obj.GetName())
	if err == nil {
		obj.ServiceDirectoryRT = updatedObj.ServiceDirectoryRT
	}
	return
}

type servicedirectoryrtGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *servicedirectoryrtGlobalTsmV1Chainer) Subscribe() {
	key := "servicedirectoryrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceDirectoryRTInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *servicedirectoryrtGlobalTsmV1Chainer) Unsubscribe() {
	key := "servicedirectoryrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *servicedirectoryrtGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "servicedirectoryrts.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *servicedirectoryrtGlobalTsmV1Chainer) ServiceDirectoryRTFolder(name string) *servicedirectoryrtfolderGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["servicedirectoryrtfolders.global.tsm.tanzu.vmware.com"] = name
	return &servicedirectoryrtfolderGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetServiceDirectoryRTFolder calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *servicedirectoryrtGlobalTsmV1Chainer) GetServiceDirectoryRTFolder(ctx context.Context, displayName string) (result *GlobalServiceDirectoryRTFolder, err error) {
	hashedName := helper.GetHashedName("servicedirectoryrtfolders.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceDirectoryRTFolderByName(ctx, hashedName)
}

// AddServiceDirectoryRTFolder calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *servicedirectoryrtGlobalTsmV1Chainer) AddServiceDirectoryRTFolder(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryRTFolder) (result *GlobalServiceDirectoryRTFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("servicedirectoryrtfolders.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceDirectoryRTFolderByName(ctx, objToCreate)
}

// DeleteServiceDirectoryRTFolder calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *servicedirectoryrtGlobalTsmV1Chainer) DeleteServiceDirectoryRTFolder(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("servicedirectoryrtfolders.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceDirectoryRTFolderByName(ctx, hashedName)
}

// GetServiceDirectoryNByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceDirectoryNByName(ctx context.Context, hashedName string) (*GlobalServiceDirectoryN, error) {
	key := "servicedirectoryns.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryN)
		return &GlobalServiceDirectoryN{
			client:            group.client,
			ServiceDirectoryN: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceDirectoryNs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceDirectoryN{
			client:            group.client,
			ServiceDirectoryN: result,
		}, nil
	}
}

// DeleteServiceDirectoryNByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceDirectoryNByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryNs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.EntriesGvk {
		err := group.client.
			Global().DeleteServiceDirectoryEntryConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryNs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceDirectoryGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceDirectoryNByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceDirectoryNByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryN) (*GlobalServiceDirectoryN, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.EntriesGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryNs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"serviceDirectoryGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ServiceDirectoryN\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceDirectoryN{
		client:            group.client,
		ServiceDirectoryN: result,
	}, nil
}

// UpdateServiceDirectoryNByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceDirectoryNByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryN) (*GlobalServiceDirectoryN, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceDirectoryNs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceDirectoryNs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceDirectoryN{
		client:            group.client,
		ServiceDirectoryN: result,
	}, nil
}

// ListServiceDirectoryNs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceDirectoryNs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceDirectoryN, err error) {
	key := "servicedirectoryns.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceDirectoryN, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryN)
			result[k] = &GlobalServiceDirectoryN{
				client:            group.client,
				ServiceDirectoryN: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceDirectoryNs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceDirectoryN, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceDirectoryN{
				client:            group.client,
				ServiceDirectoryN: &item,
			}
		}
	}
	return
}

type GlobalServiceDirectoryN struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryN
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceDirectoryN) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceDirectoryNByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceDirectoryN = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceDirectoryN) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceDirectoryNByName(ctx, obj.ServiceDirectoryN)
	if err != nil {
		return err
	}
	obj.ServiceDirectoryN = result.ServiceDirectoryN
	return nil
}

func (obj *GlobalServiceDirectoryN) GetParent(ctx context.Context) (result *GlobalConfig, err error) {
	hashedName := helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetConfigByName(ctx, hashedName)
}

// GetAllEntries returns all children of given type
func (obj *GlobalServiceDirectoryN) GetAllEntries(ctx context.Context) (
	result []*GlobalServiceDirectoryEntryConfig, err error) {
	result = make([]*GlobalServiceDirectoryEntryConfig, 0, len(obj.Spec.EntriesGvk))
	for _, v := range obj.Spec.EntriesGvk {
		l, err := obj.client.Global().GetServiceDirectoryEntryConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetEntries returns child which has given displayName
func (obj *GlobalServiceDirectoryN) GetEntries(ctx context.Context,
	displayName string) (result *GlobalServiceDirectoryEntryConfig, err error) {
	l, ok := obj.Spec.EntriesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ServiceDirectoryN", "Entries", displayName)
	}
	result, err = obj.client.Global().GetServiceDirectoryEntryConfigByName(ctx, l.Name)
	return
}

// AddEntries calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalServiceDirectoryN) AddEntries(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryEntryConfig) (result *GlobalServiceDirectoryEntryConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["servicedirectoryns.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["servicedirectoryns.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceDirectoryEntryConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetServiceDirectoryNByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ServiceDirectoryN = updatedObj.ServiceDirectoryN
	}
	return
}

// DeleteEntries calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalServiceDirectoryN) DeleteEntries(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.EntriesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ServiceDirectoryN", "Entries", displayName)
	}
	err = obj.client.Global().DeleteServiceDirectoryEntryConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetServiceDirectoryNByName(ctx, obj.GetName())
	if err == nil {
		obj.ServiceDirectoryN = updatedObj.ServiceDirectoryN
	}
	return
}

type servicedirectorynGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *servicedirectorynGlobalTsmV1Chainer) Subscribe() {
	key := "servicedirectoryns.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceDirectoryNInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *servicedirectorynGlobalTsmV1Chainer) Unsubscribe() {
	key := "servicedirectoryns.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *servicedirectorynGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "servicedirectoryns.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *servicedirectorynGlobalTsmV1Chainer) Entries(name string) *servicedirectoryentryconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["servicedirectoryentryconfigs.global.tsm.tanzu.vmware.com"] = name
	return &servicedirectoryentryconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetEntries calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *servicedirectorynGlobalTsmV1Chainer) GetEntries(ctx context.Context, displayName string) (result *GlobalServiceDirectoryEntryConfig, err error) {
	hashedName := helper.GetHashedName("servicedirectoryentryconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceDirectoryEntryConfigByName(ctx, hashedName)
}

// AddEntries calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *servicedirectorynGlobalTsmV1Chainer) AddEntries(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceDirectoryEntryConfig) (result *GlobalServiceDirectoryEntryConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("servicedirectoryentryconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceDirectoryEntryConfigByName(ctx, objToCreate)
}

// DeleteEntries calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *servicedirectorynGlobalTsmV1Chainer) DeleteEntries(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("servicedirectoryentryconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceDirectoryEntryConfigByName(ctx, hashedName)
}

// GetServiceEntryConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceEntryConfigByName(ctx context.Context, hashedName string) (*GlobalServiceEntryConfig, error) {
	key := "serviceentryconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceEntryConfig)
		return &GlobalServiceEntryConfig{
			client:             group.client,
			ServiceEntryConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceEntryConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceEntryConfig{
			client:             group.client,
			ServiceEntryConfig: result,
		}, nil
	}
}

// DeleteServiceEntryConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceEntryConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceEntryConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceEntryConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceEntriesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceEntryConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceEntryConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceEntryConfig) (*GlobalServiceEntryConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceEntryConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"serviceEntriesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ServiceEntryConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceEntryConfig{
		client:             group.client,
		ServiceEntryConfig: result,
	}, nil
}

// UpdateServiceEntryConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceEntryConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceEntryConfig) (*GlobalServiceEntryConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceEntryConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueOwnedBy :=
		objToUpdate.Spec.OwnedBy
	patchOpOwnedBy := PatchOp{
		Op:    "replace",
		Path:  "/spec/ownedBy",
		Value: patchValueOwnedBy,
	}
	patch = append(patch, patchOpOwnedBy)

	patchValueService :=
		objToUpdate.Spec.Service
	patchOpService := PatchOp{
		Op:    "replace",
		Path:  "/spec/service",
		Value: patchValueService,
	}
	patch = append(patch, patchOpService)

	patchValueServiceFQDN :=
		objToUpdate.Spec.ServiceFQDN
	patchOpServiceFQDN := PatchOp{
		Op:    "replace",
		Path:  "/spec/serviceFQDN",
		Value: patchValueServiceFQDN,
	}
	patch = append(patch, patchOpServiceFQDN)

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueServicePortList :=
		objToUpdate.Spec.ServicePortList
	patchOpServicePortList := PatchOp{
		Op:    "replace",
		Path:  "/spec/servicePortList",
		Value: patchValueServicePortList,
	}
	patch = append(patch, patchOpServicePortList)

	if objToUpdate.Spec.Tags != nil {
		patchValueTags :=
			objToUpdate.Spec.Tags
		patchOpTags := PatchOp{
			Op:    "replace",
			Path:  "/spec/tags",
			Value: patchValueTags,
		}
		patch = append(patch, patchOpTags)
	}

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	if objToUpdate.Spec.Endpoints != nil {
		patchValueEndpoints :=
			objToUpdate.Spec.Endpoints
		patchOpEndpoints := PatchOp{
			Op:    "replace",
			Path:  "/spec/endpoints",
			Value: patchValueEndpoints,
		}
		patch = append(patch, patchOpEndpoints)
	}

	patchValueEndpointList :=
		objToUpdate.Spec.EndpointList
	patchOpEndpointList := PatchOp{
		Op:    "replace",
		Path:  "/spec/endpointList",
		Value: patchValueEndpointList,
	}
	patch = append(patch, patchOpEndpointList)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceEntryConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceEntryConfig{
		client:             group.client,
		ServiceEntryConfig: result,
	}, nil
}

// ListServiceEntryConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceEntryConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceEntryConfig, err error) {
	key := "serviceentryconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceEntryConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceEntryConfig)
			result[k] = &GlobalServiceEntryConfig{
				client:             group.client,
				ServiceEntryConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceEntryConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceEntryConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceEntryConfig{
				client:             group.client,
				ServiceEntryConfig: &item,
			}
		}
	}
	return
}

type GlobalServiceEntryConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceEntryConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceEntryConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceEntryConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceEntryConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceEntryConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceEntryConfigByName(ctx, obj.ServiceEntryConfig)
	if err != nil {
		return err
	}
	obj.ServiceEntryConfig = result.ServiceEntryConfig
	return nil
}

func (obj *GlobalServiceEntryConfig) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

type serviceentryconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *serviceentryconfigGlobalTsmV1Chainer) Subscribe() {
	key := "serviceentryconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceEntryConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *serviceentryconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "serviceentryconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *serviceentryconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "serviceentryconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetServiceEntryByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceEntryByName(ctx context.Context, hashedName string) (*GlobalServiceEntry, error) {
	key := "serviceentries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceEntry)
		return &GlobalServiceEntry{
			client:       group.client,
			ServiceEntry: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceEntries().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceEntry{
			client:       group.client,
			ServiceEntry: result,
		}, nil
	}
}

// DeleteServiceEntryByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceEntryByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceEntries().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceEntries().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceEntryGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceEntryByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceEntryByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceEntry) (*GlobalServiceEntry, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceEntries().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"serviceEntryGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ServiceEntry\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceEntry{
		client:       group.client,
		ServiceEntry: result,
	}, nil
}

// UpdateServiceEntryByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceEntryByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceEntry) (*GlobalServiceEntry, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceEntries().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueAnnotations :=
		objToUpdate.Spec.Annotations
	patchOpAnnotations := PatchOp{
		Op:    "replace",
		Path:  "/spec/annotations",
		Value: patchValueAnnotations,
	}
	patch = append(patch, patchOpAnnotations)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueCreationTimestamp :=
		objToUpdate.Spec.CreationTimestamp
	patchOpCreationTimestamp := PatchOp{
		Op:    "replace",
		Path:  "/spec/creationTimestamp",
		Value: patchValueCreationTimestamp,
	}
	patch = append(patch, patchOpCreationTimestamp)

	patchValueApiLink :=
		objToUpdate.Spec.ApiLink
	patchOpApiLink := PatchOp{
		Op:    "replace",
		Path:  "/spec/apiLink",
		Value: patchValueApiLink,
	}
	patch = append(patch, patchOpApiLink)

	patchValueUid :=
		objToUpdate.Spec.Uid
	patchOpUid := PatchOp{
		Op:    "replace",
		Path:  "/spec/uid",
		Value: patchValueUid,
	}
	patch = append(patch, patchOpUid)

	patchValueHosts :=
		objToUpdate.Spec.Hosts
	patchOpHosts := PatchOp{
		Op:    "replace",
		Path:  "/spec/hosts",
		Value: patchValueHosts,
	}
	patch = append(patch, patchOpHosts)

	patchValueAddresses :=
		objToUpdate.Spec.Addresses
	patchOpAddresses := PatchOp{
		Op:    "replace",
		Path:  "/spec/addresses",
		Value: patchValueAddresses,
	}
	patch = append(patch, patchOpAddresses)

	patchValuePorts :=
		objToUpdate.Spec.Ports
	patchOpPorts := PatchOp{
		Op:    "replace",
		Path:  "/spec/ports",
		Value: patchValuePorts,
	}
	patch = append(patch, patchOpPorts)

	patchValueLocation :=
		objToUpdate.Spec.Location
	patchOpLocation := PatchOp{
		Op:    "replace",
		Path:  "/spec/location",
		Value: patchValueLocation,
	}
	patch = append(patch, patchOpLocation)

	patchValueResolution :=
		objToUpdate.Spec.Resolution
	patchOpResolution := PatchOp{
		Op:    "replace",
		Path:  "/spec/resolution",
		Value: patchValueResolution,
	}
	patch = append(patch, patchOpResolution)

	patchValueEndpoints :=
		objToUpdate.Spec.Endpoints
	patchOpEndpoints := PatchOp{
		Op:    "replace",
		Path:  "/spec/endpoints",
		Value: patchValueEndpoints,
	}
	patch = append(patch, patchOpEndpoints)

	if objToUpdate.Spec.ExportTo != nil {
		patchValueExportTo :=
			objToUpdate.Spec.ExportTo
		patchOpExportTo := PatchOp{
			Op:    "replace",
			Path:  "/spec/exportTo",
			Value: patchValueExportTo,
		}
		patch = append(patch, patchOpExportTo)
	}

	patchValueWorkloadSelectorLabels :=
		objToUpdate.Spec.WorkloadSelectorLabels
	patchOpWorkloadSelectorLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/workloadSelectorLabels",
		Value: patchValueWorkloadSelectorLabels,
	}
	patch = append(patch, patchOpWorkloadSelectorLabels)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceEntries().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceEntry{
		client:       group.client,
		ServiceEntry: result,
	}, nil
}

// ListServiceEntries returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceEntries(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceEntry, err error) {
	key := "serviceentries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceEntry, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceEntry)
			result[k] = &GlobalServiceEntry{
				client:       group.client,
				ServiceEntry: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceEntries().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceEntry, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceEntry{
				client:       group.client,
				ServiceEntry: &item,
			}
		}
	}
	return
}

type GlobalServiceEntry struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceEntry
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceEntry) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceEntryByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceEntry = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceEntry) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceEntryByName(ctx, obj.ServiceEntry)
	if err != nil {
		return err
	}
	obj.ServiceEntry = result.ServiceEntry
	return nil
}

func (obj *GlobalServiceEntry) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

type serviceentryGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *serviceentryGlobalTsmV1Chainer) Subscribe() {
	key := "serviceentries.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceEntryInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *serviceentryGlobalTsmV1Chainer) Unsubscribe() {
	key := "serviceentries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *serviceentryGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "serviceentries.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetSvcGroupRTByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetSvcGroupRTByName(ctx context.Context, hashedName string) (*GlobalSvcGroupRT, error) {
	key := "svcgrouprts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.SvcGroupRT)
		return &GlobalSvcGroupRT{
			client:     group.client,
			SvcGroupRT: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			SvcGroupRTs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalSvcGroupRT{
			client:     group.client,
			SvcGroupRT: result,
		}, nil
	}
}

// DeleteSvcGroupRTByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteSvcGroupRTByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SvcGroupRTs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		SvcGroupRTs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/svcGroupRTGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["resourcegrouprts.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("resourcegrouprts.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ResourceGroupRTs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateSvcGroupRTByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateSvcGroupRTByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SvcGroupRT) (*GlobalSvcGroupRT, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SvcGroupRTs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["resourcegrouprts.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("resourcegrouprts.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"svcGroupRTGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"SvcGroupRT\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ResourceGroupRTs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalSvcGroupRT{
		client:     group.client,
		SvcGroupRT: result,
	}, nil
}

// UpdateSvcGroupRTByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateSvcGroupRTByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.SvcGroupRT) (*GlobalSvcGroupRT, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			SvcGroupRTs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueDisplayName :=
		objToUpdate.Spec.DisplayName
	patchOpDisplayName := PatchOp{
		Op:    "replace",
		Path:  "/spec/displayName",
		Value: patchValueDisplayName,
	}
	patch = append(patch, patchOpDisplayName)

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueServices :=
		objToUpdate.Spec.Services
	patchOpServices := PatchOp{
		Op:    "replace",
		Path:  "/spec/services",
		Value: patchValueServices,
	}
	patch = append(patch, patchOpServices)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		SvcGroupRTs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalSvcGroupRT{
		client:     group.client,
		SvcGroupRT: result,
	}, nil
}

// ListSvcGroupRTs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListSvcGroupRTs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalSvcGroupRT, err error) {
	key := "svcgrouprts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalSvcGroupRT, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.SvcGroupRT)
			result[k] = &GlobalSvcGroupRT{
				client:     group.client,
				SvcGroupRT: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			SvcGroupRTs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalSvcGroupRT, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalSvcGroupRT{
				client:     group.client,
				SvcGroupRT: &item,
			}
		}
	}
	return
}

type GlobalSvcGroupRT struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.SvcGroupRT
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalSvcGroupRT) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteSvcGroupRTByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.SvcGroupRT = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalSvcGroupRT) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateSvcGroupRTByName(ctx, obj.SvcGroupRT)
	if err != nil {
		return err
	}
	obj.SvcGroupRT = result.SvcGroupRT
	return nil
}

func (obj *GlobalSvcGroupRT) GetParent(ctx context.Context) (result *GlobalResourceGroupRT, err error) {
	hashedName := helper.GetHashedName("resourcegrouprts.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["resourcegrouprts.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetResourceGroupRTByName(ctx, hashedName)
}

type svcgrouprtGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *svcgrouprtGlobalTsmV1Chainer) Subscribe() {
	key := "svcgrouprts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSvcGroupRTInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *svcgrouprtGlobalTsmV1Chainer) Unsubscribe() {
	key := "svcgrouprts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *svcgrouprtGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "svcgrouprts.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetServiceInstanceContainerByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceInstanceContainerByName(ctx context.Context, hashedName string) (*GlobalServiceInstanceContainer, error) {
	key := "serviceinstancecontainers.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceInstanceContainer)
		return &GlobalServiceInstanceContainer{
			client:                   group.client,
			ServiceInstanceContainer: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceInstanceContainers().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceInstanceContainer{
			client:                   group.client,
			ServiceInstanceContainer: result,
		}, nil
	}
}

// DeleteServiceInstanceContainerByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceInstanceContainerByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceInstanceContainers().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceInstanceContainers().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/containersGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["serviceinstances.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("serviceinstances.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ServiceInstances().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceInstanceContainerByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceInstanceContainerByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceInstanceContainer) (*GlobalServiceInstanceContainer, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceInstanceContainers().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["serviceinstances.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("serviceinstances.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"containersGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ServiceInstanceContainer\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ServiceInstances().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceInstanceContainer{
		client:                   group.client,
		ServiceInstanceContainer: result,
	}, nil
}

// UpdateServiceInstanceContainerByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceInstanceContainerByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceInstanceContainer) (*GlobalServiceInstanceContainer, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceInstanceContainers().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueImage :=
		objToUpdate.Spec.Image
	patchOpImage := PatchOp{
		Op:    "replace",
		Path:  "/spec/image",
		Value: patchValueImage,
	}
	patch = append(patch, patchOpImage)

	patchValueImagePullPolicy :=
		objToUpdate.Spec.ImagePullPolicy
	patchOpImagePullPolicy := PatchOp{
		Op:    "replace",
		Path:  "/spec/imagePullPolicy",
		Value: patchValueImagePullPolicy,
	}
	patch = append(patch, patchOpImagePullPolicy)

	patchValueTerminationMessagePath :=
		objToUpdate.Spec.TerminationMessagePath
	patchOpTerminationMessagePath := PatchOp{
		Op:    "replace",
		Path:  "/spec/terminationMessagePath",
		Value: patchValueTerminationMessagePath,
	}
	patch = append(patch, patchOpTerminationMessagePath)

	patchValueTerminationMessagePolicy :=
		objToUpdate.Spec.TerminationMessagePolicy
	patchOpTerminationMessagePolicy := PatchOp{
		Op:    "replace",
		Path:  "/spec/terminationMessagePolicy",
		Value: patchValueTerminationMessagePolicy,
	}
	patch = append(patch, patchOpTerminationMessagePolicy)

	patchValueResources :=
		objToUpdate.Spec.Resources
	patchOpResources := PatchOp{
		Op:    "replace",
		Path:  "/spec/resources",
		Value: patchValueResources,
	}
	patch = append(patch, patchOpResources)

	patchValueVolumeMounts :=
		objToUpdate.Spec.VolumeMounts
	patchOpVolumeMounts := PatchOp{
		Op:    "replace",
		Path:  "/spec/volumeMounts",
		Value: patchValueVolumeMounts,
	}
	patch = append(patch, patchOpVolumeMounts)

	patchValueCommand :=
		objToUpdate.Spec.Command
	patchOpCommand := PatchOp{
		Op:    "replace",
		Path:  "/spec/command",
		Value: patchValueCommand,
	}
	patch = append(patch, patchOpCommand)

	patchValueSecurityContext :=
		objToUpdate.Spec.SecurityContext
	patchOpSecurityContext := PatchOp{
		Op:    "replace",
		Path:  "/spec/securityContext",
		Value: patchValueSecurityContext,
	}
	patch = append(patch, patchOpSecurityContext)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceInstanceContainers().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceInstanceContainer{
		client:                   group.client,
		ServiceInstanceContainer: result,
	}, nil
}

// ListServiceInstanceContainers returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceInstanceContainers(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceInstanceContainer, err error) {
	key := "serviceinstancecontainers.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceInstanceContainer, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceInstanceContainer)
			result[k] = &GlobalServiceInstanceContainer{
				client:                   group.client,
				ServiceInstanceContainer: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceInstanceContainers().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceInstanceContainer, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceInstanceContainer{
				client:                   group.client,
				ServiceInstanceContainer: &item,
			}
		}
	}
	return
}

type GlobalServiceInstanceContainer struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceInstanceContainer
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceInstanceContainer) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceInstanceContainerByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceInstanceContainer = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceInstanceContainer) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceInstanceContainerByName(ctx, obj.ServiceInstanceContainer)
	if err != nil {
		return err
	}
	obj.ServiceInstanceContainer = result.ServiceInstanceContainer
	return nil
}

func (obj *GlobalServiceInstanceContainer) GetParent(ctx context.Context) (result *GlobalServiceInstance, err error) {
	hashedName := helper.GetHashedName("serviceinstances.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["serviceinstances.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetServiceInstanceByName(ctx, hashedName)
}

type serviceinstancecontainerGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *serviceinstancecontainerGlobalTsmV1Chainer) Subscribe() {
	key := "serviceinstancecontainers.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceInstanceContainerInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *serviceinstancecontainerGlobalTsmV1Chainer) Unsubscribe() {
	key := "serviceinstancecontainers.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *serviceinstancecontainerGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "serviceinstancecontainers.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetServiceInstanceByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceInstanceByName(ctx context.Context, hashedName string) (*GlobalServiceInstance, error) {
	key := "serviceinstances.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceInstance)
		return &GlobalServiceInstance{
			client:          group.client,
			ServiceInstance: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceInstances().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceInstance{
			client:          group.client,
			ServiceInstance: result,
		}, nil
	}
}

// DeleteServiceInstanceByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceInstanceByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceInstances().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.ContainersGvk {
		err := group.client.
			Global().DeleteServiceInstanceContainerByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceInstances().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceInstancesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceInstanceByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceInstanceByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceInstance) (*GlobalServiceInstance, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ContainersGvk = nil
	objToCreate.Spec.NodeGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceInstances().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"serviceInstancesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ServiceInstance\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceInstance{
		client:          group.client,
		ServiceInstance: result,
	}, nil
}

// UpdateServiceInstanceByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceInstanceByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceInstance) (*GlobalServiceInstance, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceInstances().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueMetadata :=
		objToUpdate.Spec.Metadata
	patchOpMetadata := PatchOp{
		Op:    "replace",
		Path:  "/spec/metadata",
		Value: patchValueMetadata,
	}
	patch = append(patch, patchOpMetadata)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	patchValueStatus :=
		objToUpdate.Spec.Status
	patchOpStatus := PatchOp{
		Op:    "replace",
		Path:  "/spec/status",
		Value: patchValueStatus,
	}
	patch = append(patch, patchOpStatus)

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueNamespace :=
		objToUpdate.Spec.Namespace
	patchOpNamespace := PatchOp{
		Op:    "replace",
		Path:  "/spec/namespace",
		Value: patchValueNamespace,
	}
	patch = append(patch, patchOpNamespace)

	patchValueAnnotations :=
		objToUpdate.Spec.Annotations
	patchOpAnnotations := PatchOp{
		Op:    "replace",
		Path:  "/spec/annotations",
		Value: patchValueAnnotations,
	}
	patch = append(patch, patchOpAnnotations)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueApiLink :=
		objToUpdate.Spec.ApiLink
	patchOpApiLink := PatchOp{
		Op:    "replace",
		Path:  "/spec/apiLink",
		Value: patchValueApiLink,
	}
	patch = append(patch, patchOpApiLink)

	patchValueUid :=
		objToUpdate.Spec.Uid
	patchOpUid := PatchOp{
		Op:    "replace",
		Path:  "/spec/uid",
		Value: patchValueUid,
	}
	patch = append(patch, patchOpUid)

	patchValueRestartPolicy :=
		objToUpdate.Spec.RestartPolicy
	patchOpRestartPolicy := PatchOp{
		Op:    "replace",
		Path:  "/spec/restartPolicy",
		Value: patchValueRestartPolicy,
	}
	patch = append(patch, patchOpRestartPolicy)

	patchValueDnsPolicy :=
		objToUpdate.Spec.DnsPolicy
	patchOpDnsPolicy := PatchOp{
		Op:    "replace",
		Path:  "/spec/dnsPolicy",
		Value: patchValueDnsPolicy,
	}
	patch = append(patch, patchOpDnsPolicy)

	patchValueHostNetwork :=
		objToUpdate.Spec.HostNetwork
	patchOpHostNetwork := PatchOp{
		Op:    "replace",
		Path:  "/spec/hostNetwork",
		Value: patchValueHostNetwork,
	}
	patch = append(patch, patchOpHostNetwork)

	patchValueSecurityContext :=
		objToUpdate.Spec.SecurityContext
	patchOpSecurityContext := PatchOp{
		Op:    "replace",
		Path:  "/spec/securityContext",
		Value: patchValueSecurityContext,
	}
	patch = append(patch, patchOpSecurityContext)

	patchValueTerminationGracePeriodSeconds :=
		objToUpdate.Spec.TerminationGracePeriodSeconds
	patchOpTerminationGracePeriodSeconds := PatchOp{
		Op:    "replace",
		Path:  "/spec/terminationGracePeriodSeconds",
		Value: patchValueTerminationGracePeriodSeconds,
	}
	patch = append(patch, patchOpTerminationGracePeriodSeconds)

	patchValueTolerations :=
		objToUpdate.Spec.Tolerations
	patchOpTolerations := PatchOp{
		Op:    "replace",
		Path:  "/spec/tolerations",
		Value: patchValueTolerations,
	}
	patch = append(patch, patchOpTolerations)

	patchValueStatusConditions :=
		objToUpdate.Spec.StatusConditions
	patchOpStatusConditions := PatchOp{
		Op:    "replace",
		Path:  "/spec/statusConditions",
		Value: patchValueStatusConditions,
	}
	patch = append(patch, patchOpStatusConditions)

	patchValueStatusContainer :=
		objToUpdate.Spec.StatusContainer
	patchOpStatusContainer := PatchOp{
		Op:    "replace",
		Path:  "/spec/statusContainer",
		Value: patchValueStatusContainer,
	}
	patch = append(patch, patchOpStatusContainer)

	patchValuePodIP :=
		objToUpdate.Spec.PodIP
	patchOpPodIP := PatchOp{
		Op:    "replace",
		Path:  "/spec/podIP",
		Value: patchValuePodIP,
	}
	patch = append(patch, patchOpPodIP)

	patchValueQosClass :=
		objToUpdate.Spec.QosClass
	patchOpQosClass := PatchOp{
		Op:    "replace",
		Path:  "/spec/qosClass",
		Value: patchValueQosClass,
	}
	patch = append(patch, patchOpQosClass)

	patchValuePhase :=
		objToUpdate.Spec.Phase
	patchOpPhase := PatchOp{
		Op:    "replace",
		Path:  "/spec/phase",
		Value: patchValuePhase,
	}
	patch = append(patch, patchOpPhase)

	patchValueStartTime :=
		objToUpdate.Spec.StartTime
	patchOpStartTime := PatchOp{
		Op:    "replace",
		Path:  "/spec/startTime",
		Value: patchValueStartTime,
	}
	patch = append(patch, patchOpStartTime)

	patchValueNodeName :=
		objToUpdate.Spec.NodeName
	patchOpNodeName := PatchOp{
		Op:    "replace",
		Path:  "/spec/nodeName",
		Value: patchValueNodeName,
	}
	patch = append(patch, patchOpNodeName)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceInstances().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceInstance{
		client:          group.client,
		ServiceInstance: result,
	}, nil
}

// ListServiceInstances returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceInstances(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceInstance, err error) {
	key := "serviceinstances.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceInstance, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceInstance)
			result[k] = &GlobalServiceInstance{
				client:          group.client,
				ServiceInstance: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceInstances().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceInstance, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceInstance{
				client:          group.client,
				ServiceInstance: &item,
			}
		}
	}
	return
}

type GlobalServiceInstance struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceInstance
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceInstance) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceInstanceByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceInstance = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceInstance) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceInstanceByName(ctx, obj.ServiceInstance)
	if err != nil {
		return err
	}
	obj.ServiceInstance = result.ServiceInstance
	return nil
}

func (obj *GlobalServiceInstance) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

// GetAllContainers returns all children of given type
func (obj *GlobalServiceInstance) GetAllContainers(ctx context.Context) (
	result []*GlobalServiceInstanceContainer, err error) {
	result = make([]*GlobalServiceInstanceContainer, 0, len(obj.Spec.ContainersGvk))
	for _, v := range obj.Spec.ContainersGvk {
		l, err := obj.client.Global().GetServiceInstanceContainerByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetContainers returns child which has given displayName
func (obj *GlobalServiceInstance) GetContainers(ctx context.Context,
	displayName string) (result *GlobalServiceInstanceContainer, err error) {
	l, ok := obj.Spec.ContainersGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ServiceInstance", "Containers", displayName)
	}
	result, err = obj.client.Global().GetServiceInstanceContainerByName(ctx, l.Name)
	return
}

// AddContainers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalServiceInstance) AddContainers(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceInstanceContainer) (result *GlobalServiceInstanceContainer, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["serviceinstances.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["serviceinstances.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceInstanceContainerByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetServiceInstanceByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ServiceInstance = updatedObj.ServiceInstance
	}
	return
}

// DeleteContainers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalServiceInstance) DeleteContainers(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ContainersGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ServiceInstance", "Containers", displayName)
	}
	err = obj.client.Global().DeleteServiceInstanceContainerByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetServiceInstanceByName(ctx, obj.GetName())
	if err == nil {
		obj.ServiceInstance = updatedObj.ServiceInstance
	}
	return
}

// GetNode returns link of given type
func (obj *GlobalServiceInstance) GetNode(ctx context.Context) (
	result *GlobalNode, err error) {
	if obj.Spec.NodeGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ServiceInstance", "Node")
	}
	return obj.client.Global().GetNodeByName(ctx, obj.Spec.NodeGvk.Name)
}

// LinkNode links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalServiceInstance) LinkNode(ctx context.Context,
	linkToAdd *GlobalNode) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/nodeGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "Node",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceInstances().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ServiceInstance = result
	return nil
}

// UnlinkNode unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalServiceInstance) UnlinkNode(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/nodeGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceInstances().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ServiceInstance = result
	return nil

}

type serviceinstanceGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *serviceinstanceGlobalTsmV1Chainer) Subscribe() {
	key := "serviceinstances.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceInstanceInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *serviceinstanceGlobalTsmV1Chainer) Unsubscribe() {
	key := "serviceinstances.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *serviceinstanceGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "serviceinstances.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *serviceinstanceGlobalTsmV1Chainer) Containers(name string) *serviceinstancecontainerGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["serviceinstancecontainers.global.tsm.tanzu.vmware.com"] = name
	return &serviceinstancecontainerGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetContainers calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *serviceinstanceGlobalTsmV1Chainer) GetContainers(ctx context.Context, displayName string) (result *GlobalServiceInstanceContainer, err error) {
	hashedName := helper.GetHashedName("serviceinstancecontainers.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceInstanceContainerByName(ctx, hashedName)
}

// AddContainers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *serviceinstanceGlobalTsmV1Chainer) AddContainers(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceInstanceContainer) (result *GlobalServiceInstanceContainer, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("serviceinstancecontainers.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceInstanceContainerByName(ctx, objToCreate)
}

// DeleteContainers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *serviceinstanceGlobalTsmV1Chainer) DeleteContainers(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("serviceinstancecontainers.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceInstanceContainerByName(ctx, hashedName)
}

// GetServiceJobByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceJobByName(ctx context.Context, hashedName string) (*GlobalServiceJob, error) {
	key := "servicejobs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceJob)
		return &GlobalServiceJob{
			client:     group.client,
			ServiceJob: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceJobs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceJob{
			client:     group.client,
			ServiceJob: result,
		}, nil
	}
}

// DeleteServiceJobByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceJobByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceJobs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceJobs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceJobsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceJobByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceJobByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceJob) (*GlobalServiceJob, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ServiceInstancesGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceJobs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"serviceJobsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ServiceJob\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceJob{
		client:     group.client,
		ServiceJob: result,
	}, nil
}

// UpdateServiceJobByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceJobByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceJob) (*GlobalServiceJob, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceJobs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueMetadata :=
		objToUpdate.Spec.Metadata
	patchOpMetadata := PatchOp{
		Op:    "replace",
		Path:  "/spec/metadata",
		Value: patchValueMetadata,
	}
	patch = append(patch, patchOpMetadata)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	patchValueStatus :=
		objToUpdate.Spec.Status
	patchOpStatus := PatchOp{
		Op:    "replace",
		Path:  "/spec/status",
		Value: patchValueStatus,
	}
	patch = append(patch, patchOpStatus)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceJobs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceJob{
		client:     group.client,
		ServiceJob: result,
	}, nil
}

// ListServiceJobs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceJobs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceJob, err error) {
	key := "servicejobs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceJob, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceJob)
			result[k] = &GlobalServiceJob{
				client:     group.client,
				ServiceJob: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceJobs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceJob, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceJob{
				client:     group.client,
				ServiceJob: &item,
			}
		}
	}
	return
}

type GlobalServiceJob struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceJob
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceJob) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceJobByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceJob = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceJob) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceJobByName(ctx, obj.ServiceJob)
	if err != nil {
		return err
	}
	obj.ServiceJob = result.ServiceJob
	return nil
}

func (obj *GlobalServiceJob) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

// GetAllServiceInstances returns all links of given type
func (obj *GlobalServiceJob) GetAllServiceInstances(ctx context.Context) (
	result []*GlobalServiceInstance, err error) {
	result = make([]*GlobalServiceInstance, 0, len(obj.Spec.ServiceInstancesGvk))
	for _, v := range obj.Spec.ServiceInstancesGvk {
		l, err := obj.client.Global().GetServiceInstanceByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceInstances returns link which has given displayName
func (obj *GlobalServiceJob) GetServiceInstances(ctx context.Context,
	displayName string) (result *GlobalServiceInstance, err error) {
	l, ok := obj.Spec.ServiceInstancesGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ServiceJob", "ServiceInstances", displayName)
	}
	result, err = obj.client.Global().GetServiceInstanceByName(ctx, l.Name)
	return
}

// LinkServiceInstances links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalServiceJob) LinkServiceInstances(ctx context.Context,
	linkToAdd *GlobalServiceInstance) error {

	payload := "{\"spec\": {\"serviceInstancesGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceInstance\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceJobs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ServiceJob = result
	return nil
}

// UnlinkServiceInstances unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalServiceJob) UnlinkServiceInstances(ctx context.Context,
	linkToRemove *GlobalServiceInstance) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceInstancesGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceJobs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ServiceJob = result
	return nil

}

type servicejobGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *servicejobGlobalTsmV1Chainer) Subscribe() {
	key := "servicejobs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceJobInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *servicejobGlobalTsmV1Chainer) Unsubscribe() {
	key := "servicejobs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *servicejobGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "servicejobs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetServiceLevelObjectiveFolderByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceLevelObjectiveFolderByName(ctx context.Context, hashedName string) (*GlobalServiceLevelObjectiveFolder, error) {
	key := "servicelevelobjectivefolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceLevelObjectiveFolder)
		return &GlobalServiceLevelObjectiveFolder{
			client:                      group.client,
			ServiceLevelObjectiveFolder: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceLevelObjectiveFolders().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceLevelObjectiveFolder{
			client:                      group.client,
			ServiceLevelObjectiveFolder: result,
		}, nil
	}
}

// DeleteServiceLevelObjectiveFolderByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceLevelObjectiveFolderByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceLevelObjectiveFolders().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.ServiceLevelObjectivesGvk {
		err := group.client.
			Global().DeleteServiceLevelObjectiveByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceLevelObjectiveFolders().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceLevelObjectiveGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceLevelObjectiveFolderByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceLevelObjectiveFolderByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceLevelObjectiveFolder) (*GlobalServiceLevelObjectiveFolder, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ServiceLevelObjectivesGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceLevelObjectiveFolders().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/serviceLevelObjectiveGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "ServiceLevelObjectiveFolder",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceLevelObjectiveFolder{
		client:                      group.client,
		ServiceLevelObjectiveFolder: result,
	}, nil
}

// UpdateServiceLevelObjectiveFolderByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceLevelObjectiveFolderByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceLevelObjectiveFolder) (*GlobalServiceLevelObjectiveFolder, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceLevelObjectiveFolders().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceLevelObjectiveFolders().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceLevelObjectiveFolder{
		client:                      group.client,
		ServiceLevelObjectiveFolder: result,
	}, nil
}

// ListServiceLevelObjectiveFolders returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceLevelObjectiveFolders(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceLevelObjectiveFolder, err error) {
	key := "servicelevelobjectivefolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceLevelObjectiveFolder, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceLevelObjectiveFolder)
			result[k] = &GlobalServiceLevelObjectiveFolder{
				client:                      group.client,
				ServiceLevelObjectiveFolder: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceLevelObjectiveFolders().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceLevelObjectiveFolder, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceLevelObjectiveFolder{
				client:                      group.client,
				ServiceLevelObjectiveFolder: &item,
			}
		}
	}
	return
}

type GlobalServiceLevelObjectiveFolder struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceLevelObjectiveFolder
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceLevelObjectiveFolder) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceLevelObjectiveFolderByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceLevelObjectiveFolder = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceLevelObjectiveFolder) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceLevelObjectiveFolderByName(ctx, obj.ServiceLevelObjectiveFolder)
	if err != nil {
		return err
	}
	obj.ServiceLevelObjectiveFolder = result.ServiceLevelObjectiveFolder
	return nil
}

func (obj *GlobalServiceLevelObjectiveFolder) GetParent(ctx context.Context) (result *GlobalConfig, err error) {
	hashedName := helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetConfigByName(ctx, hashedName)
}

// GetAllServiceLevelObjectives returns all children of given type
func (obj *GlobalServiceLevelObjectiveFolder) GetAllServiceLevelObjectives(ctx context.Context) (
	result []*GlobalServiceLevelObjective, err error) {
	result = make([]*GlobalServiceLevelObjective, 0, len(obj.Spec.ServiceLevelObjectivesGvk))
	for _, v := range obj.Spec.ServiceLevelObjectivesGvk {
		l, err := obj.client.Global().GetServiceLevelObjectiveByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceLevelObjectives returns child which has given displayName
func (obj *GlobalServiceLevelObjectiveFolder) GetServiceLevelObjectives(ctx context.Context,
	displayName string) (result *GlobalServiceLevelObjective, err error) {
	l, ok := obj.Spec.ServiceLevelObjectivesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ServiceLevelObjectiveFolder", "ServiceLevelObjectives", displayName)
	}
	result, err = obj.client.Global().GetServiceLevelObjectiveByName(ctx, l.Name)
	return
}

// AddServiceLevelObjectives calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalServiceLevelObjectiveFolder) AddServiceLevelObjectives(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceLevelObjective) (result *GlobalServiceLevelObjective, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["servicelevelobjectivefolders.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["servicelevelobjectivefolders.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceLevelObjectiveByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetServiceLevelObjectiveFolderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ServiceLevelObjectiveFolder = updatedObj.ServiceLevelObjectiveFolder
	}
	return
}

// DeleteServiceLevelObjectives calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalServiceLevelObjectiveFolder) DeleteServiceLevelObjectives(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ServiceLevelObjectivesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ServiceLevelObjectiveFolder", "ServiceLevelObjectives", displayName)
	}
	err = obj.client.Global().DeleteServiceLevelObjectiveByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetServiceLevelObjectiveFolderByName(ctx, obj.GetName())
	if err == nil {
		obj.ServiceLevelObjectiveFolder = updatedObj.ServiceLevelObjectiveFolder
	}
	return
}

type servicelevelobjectivefolderGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *servicelevelobjectivefolderGlobalTsmV1Chainer) Subscribe() {
	key := "servicelevelobjectivefolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceLevelObjectiveFolderInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *servicelevelobjectivefolderGlobalTsmV1Chainer) Unsubscribe() {
	key := "servicelevelobjectivefolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *servicelevelobjectivefolderGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "servicelevelobjectivefolders.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *servicelevelobjectivefolderGlobalTsmV1Chainer) ServiceLevelObjectives(name string) *servicelevelobjectiveGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["servicelevelobjectives.global.tsm.tanzu.vmware.com"] = name
	return &servicelevelobjectiveGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetServiceLevelObjectives calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *servicelevelobjectivefolderGlobalTsmV1Chainer) GetServiceLevelObjectives(ctx context.Context, displayName string) (result *GlobalServiceLevelObjective, err error) {
	hashedName := helper.GetHashedName("servicelevelobjectives.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceLevelObjectiveByName(ctx, hashedName)
}

// AddServiceLevelObjectives calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *servicelevelobjectivefolderGlobalTsmV1Chainer) AddServiceLevelObjectives(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceLevelObjective) (result *GlobalServiceLevelObjective, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("servicelevelobjectives.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceLevelObjectiveByName(ctx, objToCreate)
}

// DeleteServiceLevelObjectives calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *servicelevelobjectivefolderGlobalTsmV1Chainer) DeleteServiceLevelObjectives(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("servicelevelobjectives.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceLevelObjectiveByName(ctx, hashedName)
}

// GetServiceLevelObjectiveByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceLevelObjectiveByName(ctx context.Context, hashedName string) (*GlobalServiceLevelObjective, error) {
	key := "servicelevelobjectives.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceLevelObjective)
		return &GlobalServiceLevelObjective{
			client:                group.client,
			ServiceLevelObjective: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceLevelObjectives().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceLevelObjective{
			client:                group.client,
			ServiceLevelObjective: result,
		}, nil
	}
}

// DeleteServiceLevelObjectiveByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceLevelObjectiveByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceLevelObjectives().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceLevelObjectives().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceLevelObjectivesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["servicelevelobjectivefolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("servicelevelobjectivefolders.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ServiceLevelObjectiveFolders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceLevelObjectiveByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceLevelObjectiveByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceLevelObjective) (*GlobalServiceLevelObjective, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceLevelObjectives().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["servicelevelobjectivefolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("servicelevelobjectivefolders.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"serviceLevelObjectivesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ServiceLevelObjective\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ServiceLevelObjectiveFolders().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceLevelObjective{
		client:                group.client,
		ServiceLevelObjective: result,
	}, nil
}

// UpdateServiceLevelObjectiveByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceLevelObjectiveByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceLevelObjective) (*GlobalServiceLevelObjective, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceLevelObjectives().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueProjectId :=
		objToUpdate.Spec.ProjectId
	patchOpProjectId := PatchOp{
		Op:    "replace",
		Path:  "/spec/projectId",
		Value: patchValueProjectId,
	}
	patch = append(patch, patchOpProjectId)

	patchValueDisabled :=
		objToUpdate.Spec.Disabled
	patchOpDisabled := PatchOp{
		Op:    "replace",
		Path:  "/spec/disabled",
		Value: patchValueDisabled,
	}
	patch = append(patch, patchOpDisabled)

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueSlis :=
		objToUpdate.Spec.Slis
	patchOpSlis := PatchOp{
		Op:    "replace",
		Path:  "/spec/slis",
		Value: patchValueSlis,
	}
	patch = append(patch, patchOpSlis)

	patchValueSloServices :=
		objToUpdate.Spec.SloServices
	patchOpSloServices := PatchOp{
		Op:    "replace",
		Path:  "/spec/sloServices",
		Value: patchValueSloServices,
	}
	patch = append(patch, patchOpSloServices)

	patchValueSloTargetValue :=
		objToUpdate.Spec.SloTargetValue
	patchOpSloTargetValue := PatchOp{
		Op:    "replace",
		Path:  "/spec/sloTargetValue",
		Value: patchValueSloTargetValue,
	}
	patch = append(patch, patchOpSloTargetValue)

	patchValueSloPeriod :=
		objToUpdate.Spec.SloPeriod
	patchOpSloPeriod := PatchOp{
		Op:    "replace",
		Path:  "/spec/sloPeriod",
		Value: patchValueSloPeriod,
	}
	patch = append(patch, patchOpSloPeriod)

	patchValueSloCreationTime :=
		objToUpdate.Spec.SloCreationTime
	patchOpSloCreationTime := PatchOp{
		Op:    "replace",
		Path:  "/spec/sloCreationTime",
		Value: patchValueSloCreationTime,
	}
	patch = append(patch, patchOpSloCreationTime)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceLevelObjectives().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceLevelObjective{
		client:                group.client,
		ServiceLevelObjective: result,
	}, nil
}

// ListServiceLevelObjectives returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceLevelObjectives(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceLevelObjective, err error) {
	key := "servicelevelobjectives.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceLevelObjective, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceLevelObjective)
			result[k] = &GlobalServiceLevelObjective{
				client:                group.client,
				ServiceLevelObjective: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceLevelObjectives().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceLevelObjective, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceLevelObjective{
				client:                group.client,
				ServiceLevelObjective: &item,
			}
		}
	}
	return
}

type GlobalServiceLevelObjective struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceLevelObjective
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceLevelObjective) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceLevelObjectiveByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceLevelObjective = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceLevelObjective) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceLevelObjectiveByName(ctx, obj.ServiceLevelObjective)
	if err != nil {
		return err
	}
	obj.ServiceLevelObjective = result.ServiceLevelObjective
	return nil
}

func (obj *GlobalServiceLevelObjective) GetParent(ctx context.Context) (result *GlobalServiceLevelObjectiveFolder, err error) {
	hashedName := helper.GetHashedName("servicelevelobjectivefolders.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["servicelevelobjectivefolders.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetServiceLevelObjectiveFolderByName(ctx, hashedName)
}

type servicelevelobjectiveGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *servicelevelobjectiveGlobalTsmV1Chainer) Subscribe() {
	key := "servicelevelobjectives.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceLevelObjectiveInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *servicelevelobjectiveGlobalTsmV1Chainer) Unsubscribe() {
	key := "servicelevelobjectives.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *servicelevelobjectiveGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "servicelevelobjectives.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetServiceReplicaSetByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceReplicaSetByName(ctx context.Context, hashedName string) (*GlobalServiceReplicaSet, error) {
	key := "servicereplicasets.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceReplicaSet)
		return &GlobalServiceReplicaSet{
			client:            group.client,
			ServiceReplicaSet: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceReplicaSets().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceReplicaSet{
			client:            group.client,
			ServiceReplicaSet: result,
		}, nil
	}
}

// DeleteServiceReplicaSetByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceReplicaSetByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceReplicaSets().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceReplicaSets().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceReplicaSetsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceReplicaSetByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceReplicaSetByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceReplicaSet) (*GlobalServiceReplicaSet, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ServiceInstancesGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceReplicaSets().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"serviceReplicaSetsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ServiceReplicaSet\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceReplicaSet{
		client:            group.client,
		ServiceReplicaSet: result,
	}, nil
}

// UpdateServiceReplicaSetByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceReplicaSetByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceReplicaSet) (*GlobalServiceReplicaSet, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceReplicaSets().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueMetadata :=
		objToUpdate.Spec.Metadata
	patchOpMetadata := PatchOp{
		Op:    "replace",
		Path:  "/spec/metadata",
		Value: patchValueMetadata,
	}
	patch = append(patch, patchOpMetadata)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	patchValueStatus :=
		objToUpdate.Spec.Status
	patchOpStatus := PatchOp{
		Op:    "replace",
		Path:  "/spec/status",
		Value: patchValueStatus,
	}
	patch = append(patch, patchOpStatus)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceReplicaSets().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceReplicaSet{
		client:            group.client,
		ServiceReplicaSet: result,
	}, nil
}

// ListServiceReplicaSets returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceReplicaSets(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceReplicaSet, err error) {
	key := "servicereplicasets.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceReplicaSet, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceReplicaSet)
			result[k] = &GlobalServiceReplicaSet{
				client:            group.client,
				ServiceReplicaSet: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceReplicaSets().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceReplicaSet, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceReplicaSet{
				client:            group.client,
				ServiceReplicaSet: &item,
			}
		}
	}
	return
}

type GlobalServiceReplicaSet struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceReplicaSet
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceReplicaSet) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceReplicaSetByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceReplicaSet = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceReplicaSet) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceReplicaSetByName(ctx, obj.ServiceReplicaSet)
	if err != nil {
		return err
	}
	obj.ServiceReplicaSet = result.ServiceReplicaSet
	return nil
}

func (obj *GlobalServiceReplicaSet) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

// GetAllServiceInstances returns all links of given type
func (obj *GlobalServiceReplicaSet) GetAllServiceInstances(ctx context.Context) (
	result []*GlobalServiceInstance, err error) {
	result = make([]*GlobalServiceInstance, 0, len(obj.Spec.ServiceInstancesGvk))
	for _, v := range obj.Spec.ServiceInstancesGvk {
		l, err := obj.client.Global().GetServiceInstanceByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceInstances returns link which has given displayName
func (obj *GlobalServiceReplicaSet) GetServiceInstances(ctx context.Context,
	displayName string) (result *GlobalServiceInstance, err error) {
	l, ok := obj.Spec.ServiceInstancesGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ServiceReplicaSet", "ServiceInstances", displayName)
	}
	result, err = obj.client.Global().GetServiceInstanceByName(ctx, l.Name)
	return
}

// LinkServiceInstances links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalServiceReplicaSet) LinkServiceInstances(ctx context.Context,
	linkToAdd *GlobalServiceInstance) error {

	payload := "{\"spec\": {\"serviceInstancesGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceInstance\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceReplicaSets().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ServiceReplicaSet = result
	return nil
}

// UnlinkServiceInstances unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalServiceReplicaSet) UnlinkServiceInstances(ctx context.Context,
	linkToRemove *GlobalServiceInstance) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceInstancesGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceReplicaSets().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ServiceReplicaSet = result
	return nil

}

type servicereplicasetGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *servicereplicasetGlobalTsmV1Chainer) Subscribe() {
	key := "servicereplicasets.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceReplicaSetInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *servicereplicasetGlobalTsmV1Chainer) Unsubscribe() {
	key := "servicereplicasets.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *servicereplicasetGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "servicereplicasets.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetServiceStatefulSetByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceStatefulSetByName(ctx context.Context, hashedName string) (*GlobalServiceStatefulSet, error) {
	key := "servicestatefulsets.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceStatefulSet)
		return &GlobalServiceStatefulSet{
			client:             group.client,
			ServiceStatefulSet: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceStatefulSets().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceStatefulSet{
			client:             group.client,
			ServiceStatefulSet: result,
		}, nil
	}
}

// DeleteServiceStatefulSetByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceStatefulSetByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceStatefulSets().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceStatefulSets().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceStatefulSetsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceStatefulSetByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceStatefulSetByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceStatefulSet) (*GlobalServiceStatefulSet, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ServiceInstancesGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceStatefulSets().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"serviceStatefulSetsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ServiceStatefulSet\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceStatefulSet{
		client:             group.client,
		ServiceStatefulSet: result,
	}, nil
}

// UpdateServiceStatefulSetByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceStatefulSetByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceStatefulSet) (*GlobalServiceStatefulSet, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceStatefulSets().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueMetadata :=
		objToUpdate.Spec.Metadata
	patchOpMetadata := PatchOp{
		Op:    "replace",
		Path:  "/spec/metadata",
		Value: patchValueMetadata,
	}
	patch = append(patch, patchOpMetadata)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	patchValueStatus :=
		objToUpdate.Spec.Status
	patchOpStatus := PatchOp{
		Op:    "replace",
		Path:  "/spec/status",
		Value: patchValueStatus,
	}
	patch = append(patch, patchOpStatus)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceStatefulSets().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceStatefulSet{
		client:             group.client,
		ServiceStatefulSet: result,
	}, nil
}

// ListServiceStatefulSets returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceStatefulSets(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceStatefulSet, err error) {
	key := "servicestatefulsets.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceStatefulSet, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceStatefulSet)
			result[k] = &GlobalServiceStatefulSet{
				client:             group.client,
				ServiceStatefulSet: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceStatefulSets().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceStatefulSet, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceStatefulSet{
				client:             group.client,
				ServiceStatefulSet: &item,
			}
		}
	}
	return
}

type GlobalServiceStatefulSet struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceStatefulSet
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceStatefulSet) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceStatefulSetByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceStatefulSet = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceStatefulSet) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceStatefulSetByName(ctx, obj.ServiceStatefulSet)
	if err != nil {
		return err
	}
	obj.ServiceStatefulSet = result.ServiceStatefulSet
	return nil
}

func (obj *GlobalServiceStatefulSet) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

// GetAllServiceInstances returns all links of given type
func (obj *GlobalServiceStatefulSet) GetAllServiceInstances(ctx context.Context) (
	result []*GlobalServiceInstance, err error) {
	result = make([]*GlobalServiceInstance, 0, len(obj.Spec.ServiceInstancesGvk))
	for _, v := range obj.Spec.ServiceInstancesGvk {
		l, err := obj.client.Global().GetServiceInstanceByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceInstances returns link which has given displayName
func (obj *GlobalServiceStatefulSet) GetServiceInstances(ctx context.Context,
	displayName string) (result *GlobalServiceInstance, err error) {
	l, ok := obj.Spec.ServiceInstancesGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ServiceStatefulSet", "ServiceInstances", displayName)
	}
	result, err = obj.client.Global().GetServiceInstanceByName(ctx, l.Name)
	return
}

// LinkServiceInstances links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalServiceStatefulSet) LinkServiceInstances(ctx context.Context,
	linkToAdd *GlobalServiceInstance) error {

	payload := "{\"spec\": {\"serviceInstancesGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceInstance\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceStatefulSets().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ServiceStatefulSet = result
	return nil
}

// UnlinkServiceInstances unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalServiceStatefulSet) UnlinkServiceInstances(ctx context.Context,
	linkToRemove *GlobalServiceInstance) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceInstancesGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceStatefulSets().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ServiceStatefulSet = result
	return nil

}

type servicestatefulsetGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *servicestatefulsetGlobalTsmV1Chainer) Subscribe() {
	key := "servicestatefulsets.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceStatefulSetInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *servicestatefulsetGlobalTsmV1Chainer) Unsubscribe() {
	key := "servicestatefulsets.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *servicestatefulsetGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "servicestatefulsets.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetServiceTemplateServiceDefinitionByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceTemplateServiceDefinitionByName(ctx context.Context, hashedName string) (*GlobalServiceTemplateServiceDefinition, error) {
	key := "servicetemplateservicedefinitions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceTemplateServiceDefinition)
		return &GlobalServiceTemplateServiceDefinition{
			client:                           group.client,
			ServiceTemplateServiceDefinition: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceTemplateServiceDefinitions().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceTemplateServiceDefinition{
			client:                           group.client,
			ServiceTemplateServiceDefinition: result,
		}, nil
	}
}

// DeleteServiceTemplateServiceDefinitionByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceTemplateServiceDefinitionByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceTemplateServiceDefinitions().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceTemplateServiceDefinitions().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceDefinitionsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["servicetemplates.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("servicetemplates.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ServiceTemplates().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceTemplateServiceDefinitionByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceTemplateServiceDefinitionByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceTemplateServiceDefinition) (*GlobalServiceTemplateServiceDefinition, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceTemplateServiceDefinitions().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["servicetemplates.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("servicetemplates.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"serviceDefinitionsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ServiceTemplateServiceDefinition\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ServiceTemplates().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceTemplateServiceDefinition{
		client:                           group.client,
		ServiceTemplateServiceDefinition: result,
	}, nil
}

// UpdateServiceTemplateServiceDefinitionByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceTemplateServiceDefinitionByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceTemplateServiceDefinition) (*GlobalServiceTemplateServiceDefinition, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceTemplateServiceDefinitions().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueType :=
		objToUpdate.Spec.Type
	patchOpType := PatchOp{
		Op:    "replace",
		Path:  "/spec/type",
		Value: patchValueType,
	}
	patch = append(patch, patchOpType)

	patchValueVersion :=
		objToUpdate.Spec.Version
	patchOpVersion := PatchOp{
		Op:    "replace",
		Path:  "/spec/version",
		Value: patchValueVersion,
	}
	patch = append(patch, patchOpVersion)

	patchValueTemplate :=
		objToUpdate.Spec.Template
	patchOpTemplate := PatchOp{
		Op:    "replace",
		Path:  "/spec/template",
		Value: patchValueTemplate,
	}
	patch = append(patch, patchOpTemplate)

	if objToUpdate.Spec.TemplateArgs != nil {
		patchValueTemplateArgs :=
			objToUpdate.Spec.TemplateArgs
		patchOpTemplateArgs := PatchOp{
			Op:    "replace",
			Path:  "/spec/templateArgs",
			Value: patchValueTemplateArgs,
		}
		patch = append(patch, patchOpTemplateArgs)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceTemplateServiceDefinitions().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceTemplateServiceDefinition{
		client:                           group.client,
		ServiceTemplateServiceDefinition: result,
	}, nil
}

// ListServiceTemplateServiceDefinitions returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceTemplateServiceDefinitions(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceTemplateServiceDefinition, err error) {
	key := "servicetemplateservicedefinitions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceTemplateServiceDefinition, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceTemplateServiceDefinition)
			result[k] = &GlobalServiceTemplateServiceDefinition{
				client:                           group.client,
				ServiceTemplateServiceDefinition: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceTemplateServiceDefinitions().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceTemplateServiceDefinition, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceTemplateServiceDefinition{
				client:                           group.client,
				ServiceTemplateServiceDefinition: &item,
			}
		}
	}
	return
}

type GlobalServiceTemplateServiceDefinition struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceTemplateServiceDefinition
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceTemplateServiceDefinition) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceTemplateServiceDefinitionByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceTemplateServiceDefinition = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceTemplateServiceDefinition) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceTemplateServiceDefinitionByName(ctx, obj.ServiceTemplateServiceDefinition)
	if err != nil {
		return err
	}
	obj.ServiceTemplateServiceDefinition = result.ServiceTemplateServiceDefinition
	return nil
}

func (obj *GlobalServiceTemplateServiceDefinition) GetParent(ctx context.Context) (result *GlobalServiceTemplate, err error) {
	hashedName := helper.GetHashedName("servicetemplates.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["servicetemplates.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetServiceTemplateByName(ctx, hashedName)
}

type servicetemplateservicedefinitionGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *servicetemplateservicedefinitionGlobalTsmV1Chainer) Subscribe() {
	key := "servicetemplateservicedefinitions.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceTemplateServiceDefinitionInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *servicetemplateservicedefinitionGlobalTsmV1Chainer) Unsubscribe() {
	key := "servicetemplateservicedefinitions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *servicetemplateservicedefinitionGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "servicetemplateservicedefinitions.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetServiceTemplateByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceTemplateByName(ctx context.Context, hashedName string) (*GlobalServiceTemplate, error) {
	key := "servicetemplates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceTemplate)
		return &GlobalServiceTemplate{
			client:          group.client,
			ServiceTemplate: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceTemplates().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceTemplate{
			client:          group.client,
			ServiceTemplate: result,
		}, nil
	}
}

// DeleteServiceTemplateByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceTemplateByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceTemplates().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.ServiceDefinitionsGvk {
		err := group.client.
			Global().DeleteServiceTemplateServiceDefinitionByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceTemplates().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceTemplatesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["templategroups.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("templategroups.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		TemplateGroups().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceTemplateByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceTemplateByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceTemplate) (*GlobalServiceTemplate, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ServiceDefinitionsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceTemplates().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["templategroups.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("templategroups.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"serviceTemplatesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ServiceTemplate\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		TemplateGroups().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceTemplate{
		client:          group.client,
		ServiceTemplate: result,
	}, nil
}

// UpdateServiceTemplateByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceTemplateByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceTemplate) (*GlobalServiceTemplate, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceTemplates().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueVersion :=
		objToUpdate.Spec.Version
	patchOpVersion := PatchOp{
		Op:    "replace",
		Path:  "/spec/version",
		Value: patchValueVersion,
	}
	patch = append(patch, patchOpVersion)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceTemplates().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceTemplate{
		client:          group.client,
		ServiceTemplate: result,
	}, nil
}

// ListServiceTemplates returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceTemplates(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceTemplate, err error) {
	key := "servicetemplates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceTemplate, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceTemplate)
			result[k] = &GlobalServiceTemplate{
				client:          group.client,
				ServiceTemplate: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceTemplates().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceTemplate, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceTemplate{
				client:          group.client,
				ServiceTemplate: &item,
			}
		}
	}
	return
}

type GlobalServiceTemplate struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceTemplate
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceTemplate) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceTemplateByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceTemplate = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceTemplate) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceTemplateByName(ctx, obj.ServiceTemplate)
	if err != nil {
		return err
	}
	obj.ServiceTemplate = result.ServiceTemplate
	return nil
}

func (obj *GlobalServiceTemplate) GetParent(ctx context.Context) (result *GlobalTemplateGroup, err error) {
	hashedName := helper.GetHashedName("templategroups.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["templategroups.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetTemplateGroupByName(ctx, hashedName)
}

// GetAllServiceDefinitions returns all children of given type
func (obj *GlobalServiceTemplate) GetAllServiceDefinitions(ctx context.Context) (
	result []*GlobalServiceTemplateServiceDefinition, err error) {
	result = make([]*GlobalServiceTemplateServiceDefinition, 0, len(obj.Spec.ServiceDefinitionsGvk))
	for _, v := range obj.Spec.ServiceDefinitionsGvk {
		l, err := obj.client.Global().GetServiceTemplateServiceDefinitionByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceDefinitions returns child which has given displayName
func (obj *GlobalServiceTemplate) GetServiceDefinitions(ctx context.Context,
	displayName string) (result *GlobalServiceTemplateServiceDefinition, err error) {
	l, ok := obj.Spec.ServiceDefinitionsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ServiceTemplate", "ServiceDefinitions", displayName)
	}
	result, err = obj.client.Global().GetServiceTemplateServiceDefinitionByName(ctx, l.Name)
	return
}

// AddServiceDefinitions calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalServiceTemplate) AddServiceDefinitions(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceTemplateServiceDefinition) (result *GlobalServiceTemplateServiceDefinition, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["servicetemplates.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["servicetemplates.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceTemplateServiceDefinitionByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetServiceTemplateByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ServiceTemplate = updatedObj.ServiceTemplate
	}
	return
}

// DeleteServiceDefinitions calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalServiceTemplate) DeleteServiceDefinitions(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ServiceDefinitionsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ServiceTemplate", "ServiceDefinitions", displayName)
	}
	err = obj.client.Global().DeleteServiceTemplateServiceDefinitionByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetServiceTemplateByName(ctx, obj.GetName())
	if err == nil {
		obj.ServiceTemplate = updatedObj.ServiceTemplate
	}
	return
}

type servicetemplateGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *servicetemplateGlobalTsmV1Chainer) Subscribe() {
	key := "servicetemplates.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceTemplateInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *servicetemplateGlobalTsmV1Chainer) Unsubscribe() {
	key := "servicetemplates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *servicetemplateGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "servicetemplates.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *servicetemplateGlobalTsmV1Chainer) ServiceDefinitions(name string) *servicetemplateservicedefinitionGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["servicetemplateservicedefinitions.global.tsm.tanzu.vmware.com"] = name
	return &servicetemplateservicedefinitionGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetServiceDefinitions calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *servicetemplateGlobalTsmV1Chainer) GetServiceDefinitions(ctx context.Context, displayName string) (result *GlobalServiceTemplateServiceDefinition, err error) {
	hashedName := helper.GetHashedName("servicetemplateservicedefinitions.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceTemplateServiceDefinitionByName(ctx, hashedName)
}

// AddServiceDefinitions calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *servicetemplateGlobalTsmV1Chainer) AddServiceDefinitions(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceTemplateServiceDefinition) (result *GlobalServiceTemplateServiceDefinition, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("servicetemplateservicedefinitions.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceTemplateServiceDefinitionByName(ctx, objToCreate)
}

// DeleteServiceDefinitions calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *servicetemplateGlobalTsmV1Chainer) DeleteServiceDefinitions(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("servicetemplateservicedefinitions.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceTemplateServiceDefinitionByName(ctx, hashedName)
}

// GetServiceVersionConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceVersionConfigByName(ctx context.Context, hashedName string) (*GlobalServiceVersionConfig, error) {
	key := "serviceversionconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceVersionConfig)
		return &GlobalServiceVersionConfig{
			client:               group.client,
			ServiceVersionConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceVersionConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceVersionConfig{
			client:               group.client,
			ServiceVersionConfig: result,
		}, nil
	}
}

// DeleteServiceVersionConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceVersionConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceVersionConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.MetricMonitorsGvk {
		err := group.client.
			Global().DeleteMetricMonitorByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceVersionConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceVersionGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["serviceconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("serviceconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ServiceConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceVersionConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceVersionConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceVersionConfig) (*GlobalServiceVersionConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.MetricMonitorsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceVersionConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["serviceconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("serviceconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"serviceVersionGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ServiceVersionConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ServiceConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceVersionConfig{
		client:               group.client,
		ServiceVersionConfig: result,
	}, nil
}

// UpdateServiceVersionConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceVersionConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceVersionConfig) (*GlobalServiceVersionConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceVersionConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueVersion :=
		objToUpdate.Spec.Version
	patchOpVersion := PatchOp{
		Op:    "replace",
		Path:  "/spec/version",
		Value: patchValueVersion,
	}
	patch = append(patch, patchOpVersion)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceVersionConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceVersionConfig{
		client:               group.client,
		ServiceVersionConfig: result,
	}, nil
}

// ListServiceVersionConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceVersionConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceVersionConfig, err error) {
	key := "serviceversionconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceVersionConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceVersionConfig)
			result[k] = &GlobalServiceVersionConfig{
				client:               group.client,
				ServiceVersionConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceVersionConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceVersionConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceVersionConfig{
				client:               group.client,
				ServiceVersionConfig: &item,
			}
		}
	}
	return
}

type GlobalServiceVersionConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceVersionConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceVersionConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceVersionConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceVersionConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceVersionConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceVersionConfigByName(ctx, obj.ServiceVersionConfig)
	if err != nil {
		return err
	}
	obj.ServiceVersionConfig = result.ServiceVersionConfig
	return nil
}

func (obj *GlobalServiceVersionConfig) GetParent(ctx context.Context) (result *GlobalServiceConfig, err error) {
	hashedName := helper.GetHashedName("serviceconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["serviceconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetServiceConfigByName(ctx, hashedName)
}

// GetAllMetricMonitors returns all children of given type
func (obj *GlobalServiceVersionConfig) GetAllMetricMonitors(ctx context.Context) (
	result []*GlobalMetricMonitor, err error) {
	result = make([]*GlobalMetricMonitor, 0, len(obj.Spec.MetricMonitorsGvk))
	for _, v := range obj.Spec.MetricMonitorsGvk {
		l, err := obj.client.Global().GetMetricMonitorByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetMetricMonitors returns child which has given displayName
func (obj *GlobalServiceVersionConfig) GetMetricMonitors(ctx context.Context,
	displayName string) (result *GlobalMetricMonitor, err error) {
	l, ok := obj.Spec.MetricMonitorsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.ServiceVersionConfig", "MetricMonitors", displayName)
	}
	result, err = obj.client.Global().GetMetricMonitorByName(ctx, l.Name)
	return
}

// AddMetricMonitors calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalServiceVersionConfig) AddMetricMonitors(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.MetricMonitor) (result *GlobalMetricMonitor, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["serviceversionconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["serviceversionconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateMetricMonitorByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetServiceVersionConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.ServiceVersionConfig = updatedObj.ServiceVersionConfig
	}
	return
}

// DeleteMetricMonitors calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalServiceVersionConfig) DeleteMetricMonitors(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.MetricMonitorsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.ServiceVersionConfig", "MetricMonitors", displayName)
	}
	err = obj.client.Global().DeleteMetricMonitorByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetServiceVersionConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.ServiceVersionConfig = updatedObj.ServiceVersionConfig
	}
	return
}

type serviceversionconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *serviceversionconfigGlobalTsmV1Chainer) Subscribe() {
	key := "serviceversionconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceVersionConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *serviceversionconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "serviceversionconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *serviceversionconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "serviceversionconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *serviceversionconfigGlobalTsmV1Chainer) MetricMonitors(name string) *metricmonitorGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["metricmonitors.global.tsm.tanzu.vmware.com"] = name
	return &metricmonitorGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetMetricMonitors calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *serviceversionconfigGlobalTsmV1Chainer) GetMetricMonitors(ctx context.Context, displayName string) (result *GlobalMetricMonitor, err error) {
	hashedName := helper.GetHashedName("metricmonitors.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetMetricMonitorByName(ctx, hashedName)
}

// AddMetricMonitors calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *serviceversionconfigGlobalTsmV1Chainer) AddMetricMonitors(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.MetricMonitor) (result *GlobalMetricMonitor, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("metricmonitors.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateMetricMonitorByName(ctx, objToCreate)
}

// DeleteMetricMonitors calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *serviceversionconfigGlobalTsmV1Chainer) DeleteMetricMonitors(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("metricmonitors.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteMetricMonitorByName(ctx, hashedName)
}

// GetMetricMonitorByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetMetricMonitorByName(ctx context.Context, hashedName string) (*GlobalMetricMonitor, error) {
	key := "metricmonitors.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.MetricMonitor)
		return &GlobalMetricMonitor{
			client:        group.client,
			MetricMonitor: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			MetricMonitors().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalMetricMonitor{
			client:        group.client,
			MetricMonitor: result,
		}, nil
	}
}

// DeleteMetricMonitorByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteMetricMonitorByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		MetricMonitors().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		MetricMonitors().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/metricMonitorsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["serviceversionconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("serviceversionconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ServiceVersionConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateMetricMonitorByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateMetricMonitorByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.MetricMonitor) (*GlobalMetricMonitor, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		MetricMonitors().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["serviceversionconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("serviceversionconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"metricMonitorsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"MetricMonitor\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ServiceVersionConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalMetricMonitor{
		client:        group.client,
		MetricMonitor: result,
	}, nil
}

// UpdateMetricMonitorByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateMetricMonitorByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.MetricMonitor) (*GlobalMetricMonitor, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			MetricMonitors().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueOwnedBy :=
		objToUpdate.Spec.OwnedBy
	patchOpOwnedBy := PatchOp{
		Op:    "replace",
		Path:  "/spec/ownedBy",
		Value: patchValueOwnedBy,
	}
	patch = append(patch, patchOpOwnedBy)

	patchValueSvcMetric :=
		objToUpdate.Spec.SvcMetric
	patchOpSvcMetric := PatchOp{
		Op:    "replace",
		Path:  "/spec/svcMetric",
		Value: patchValueSvcMetric,
	}
	patch = append(patch, patchOpSvcMetric)

	patchValueFunctionType :=
		objToUpdate.Spec.FunctionType
	patchOpFunctionType := PatchOp{
		Op:    "replace",
		Path:  "/spec/functionType",
		Value: patchValueFunctionType,
	}
	patch = append(patch, patchOpFunctionType)

	patchValueFunctionArgs :=
		objToUpdate.Spec.FunctionArgs
	patchOpFunctionArgs := PatchOp{
		Op:    "replace",
		Path:  "/spec/functionArgs",
		Value: patchValueFunctionArgs,
	}
	patch = append(patch, patchOpFunctionArgs)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		MetricMonitors().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalMetricMonitor{
		client:        group.client,
		MetricMonitor: result,
	}, nil
}

// ListMetricMonitors returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListMetricMonitors(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalMetricMonitor, err error) {
	key := "metricmonitors.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalMetricMonitor, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.MetricMonitor)
			result[k] = &GlobalMetricMonitor{
				client:        group.client,
				MetricMonitor: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			MetricMonitors().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalMetricMonitor, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalMetricMonitor{
				client:        group.client,
				MetricMonitor: &item,
			}
		}
	}
	return
}

type GlobalMetricMonitor struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.MetricMonitor
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalMetricMonitor) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteMetricMonitorByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.MetricMonitor = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalMetricMonitor) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateMetricMonitorByName(ctx, obj.MetricMonitor)
	if err != nil {
		return err
	}
	obj.MetricMonitor = result.MetricMonitor
	return nil
}

func (obj *GlobalMetricMonitor) GetParent(ctx context.Context) (result *GlobalServiceVersionConfig, err error) {
	hashedName := helper.GetHashedName("serviceversionconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["serviceversionconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetServiceVersionConfigByName(ctx, hashedName)
}

type metricmonitorGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *metricmonitorGlobalTsmV1Chainer) Subscribe() {
	key := "metricmonitors.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewMetricMonitorInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *metricmonitorGlobalTsmV1Chainer) Unsubscribe() {
	key := "metricmonitors.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *metricmonitorGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "metricmonitors.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetServiceVersionByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceVersionByName(ctx context.Context, hashedName string) (*GlobalServiceVersion, error) {
	key := "serviceversions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.ServiceVersion)
		return &GlobalServiceVersion{
			client:         group.client,
			ServiceVersion: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceVersions().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalServiceVersion{
			client:         group.client,
			ServiceVersion: result,
		}, nil
	}
}

// DeleteServiceVersionByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceVersionByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceVersions().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		ServiceVersions().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceVersionsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["services.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("services.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Services().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceVersionByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceVersionByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceVersion) (*GlobalServiceVersion, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ServiceDeploymentsGvk = nil
	objToCreate.Spec.ServiceDaemonSetsGvk = nil
	objToCreate.Spec.ServiceStatefulSetsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceVersions().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["services.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("services.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"serviceVersionsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ServiceVersion\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Services().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalServiceVersion{
		client:         group.client,
		ServiceVersion: result,
	}, nil
}

// UpdateServiceVersionByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceVersionByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.ServiceVersion) (*GlobalServiceVersion, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			ServiceVersions().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		ServiceVersions().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalServiceVersion{
		client:         group.client,
		ServiceVersion: result,
	}, nil
}

// ListServiceVersions returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServiceVersions(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalServiceVersion, err error) {
	key := "serviceversions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalServiceVersion, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.ServiceVersion)
			result[k] = &GlobalServiceVersion{
				client:         group.client,
				ServiceVersion: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			ServiceVersions().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalServiceVersion, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalServiceVersion{
				client:         group.client,
				ServiceVersion: &item,
			}
		}
	}
	return
}

type GlobalServiceVersion struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.ServiceVersion
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalServiceVersion) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceVersionByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ServiceVersion = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalServiceVersion) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceVersionByName(ctx, obj.ServiceVersion)
	if err != nil {
		return err
	}
	obj.ServiceVersion = result.ServiceVersion
	return nil
}

func (obj *GlobalServiceVersion) GetParent(ctx context.Context) (result *GlobalService, err error) {
	hashedName := helper.GetHashedName("services.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["services.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetServiceByName(ctx, hashedName)
}

// GetAllServiceDeployments returns all links of given type
func (obj *GlobalServiceVersion) GetAllServiceDeployments(ctx context.Context) (
	result []*GlobalServiceDeployment, err error) {
	result = make([]*GlobalServiceDeployment, 0, len(obj.Spec.ServiceDeploymentsGvk))
	for _, v := range obj.Spec.ServiceDeploymentsGvk {
		l, err := obj.client.Global().GetServiceDeploymentByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceDeployments returns link which has given displayName
func (obj *GlobalServiceVersion) GetServiceDeployments(ctx context.Context,
	displayName string) (result *GlobalServiceDeployment, err error) {
	l, ok := obj.Spec.ServiceDeploymentsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ServiceVersion", "ServiceDeployments", displayName)
	}
	result, err = obj.client.Global().GetServiceDeploymentByName(ctx, l.Name)
	return
}

// LinkServiceDeployments links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalServiceVersion) LinkServiceDeployments(ctx context.Context,
	linkToAdd *GlobalServiceDeployment) error {

	payload := "{\"spec\": {\"serviceDeploymentsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceDeployment\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceVersions().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ServiceVersion = result
	return nil
}

// UnlinkServiceDeployments unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalServiceVersion) UnlinkServiceDeployments(ctx context.Context,
	linkToRemove *GlobalServiceDeployment) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceDeploymentsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceVersions().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ServiceVersion = result
	return nil

}

// GetAllServiceDaemonSets returns all links of given type
func (obj *GlobalServiceVersion) GetAllServiceDaemonSets(ctx context.Context) (
	result []*GlobalServiceDaemonSet, err error) {
	result = make([]*GlobalServiceDaemonSet, 0, len(obj.Spec.ServiceDaemonSetsGvk))
	for _, v := range obj.Spec.ServiceDaemonSetsGvk {
		l, err := obj.client.Global().GetServiceDaemonSetByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceDaemonSets returns link which has given displayName
func (obj *GlobalServiceVersion) GetServiceDaemonSets(ctx context.Context,
	displayName string) (result *GlobalServiceDaemonSet, err error) {
	l, ok := obj.Spec.ServiceDaemonSetsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ServiceVersion", "ServiceDaemonSets", displayName)
	}
	result, err = obj.client.Global().GetServiceDaemonSetByName(ctx, l.Name)
	return
}

// LinkServiceDaemonSets links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalServiceVersion) LinkServiceDaemonSets(ctx context.Context,
	linkToAdd *GlobalServiceDaemonSet) error {

	payload := "{\"spec\": {\"serviceDaemonSetsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceDaemonSet\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceVersions().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ServiceVersion = result
	return nil
}

// UnlinkServiceDaemonSets unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalServiceVersion) UnlinkServiceDaemonSets(ctx context.Context,
	linkToRemove *GlobalServiceDaemonSet) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceDaemonSetsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceVersions().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ServiceVersion = result
	return nil

}

// GetAllServiceStatefulSets returns all links of given type
func (obj *GlobalServiceVersion) GetAllServiceStatefulSets(ctx context.Context) (
	result []*GlobalServiceStatefulSet, err error) {
	result = make([]*GlobalServiceStatefulSet, 0, len(obj.Spec.ServiceStatefulSetsGvk))
	for _, v := range obj.Spec.ServiceStatefulSetsGvk {
		l, err := obj.client.Global().GetServiceStatefulSetByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceStatefulSets returns link which has given displayName
func (obj *GlobalServiceVersion) GetServiceStatefulSets(ctx context.Context,
	displayName string) (result *GlobalServiceStatefulSet, err error) {
	l, ok := obj.Spec.ServiceStatefulSetsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.ServiceVersion", "ServiceStatefulSets", displayName)
	}
	result, err = obj.client.Global().GetServiceStatefulSetByName(ctx, l.Name)
	return
}

// LinkServiceStatefulSets links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalServiceVersion) LinkServiceStatefulSets(ctx context.Context,
	linkToAdd *GlobalServiceStatefulSet) error {

	payload := "{\"spec\": {\"serviceStatefulSetsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceStatefulSet\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceVersions().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ServiceVersion = result
	return nil
}

// UnlinkServiceStatefulSets unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalServiceVersion) UnlinkServiceStatefulSets(ctx context.Context,
	linkToRemove *GlobalServiceStatefulSet) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceStatefulSetsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().ServiceVersions().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ServiceVersion = result
	return nil

}

type serviceversionGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *serviceversionGlobalTsmV1Chainer) Subscribe() {
	key := "serviceversions.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceVersionInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *serviceversionGlobalTsmV1Chainer) Unsubscribe() {
	key := "serviceversions.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *serviceversionGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "serviceversions.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetServiceByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetServiceByName(ctx context.Context, hashedName string) (*GlobalService, error) {
	key := "services.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Service)
		return &GlobalService{
			client:  group.client,
			Service: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Services().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalService{
			client:  group.client,
			Service: result,
		}, nil
	}
}

// DeleteServiceByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteServiceByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Services().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.AdditionalAttributesGvk {
		err := group.client.
			Global().DeleteAdditionalAttributesByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ServiceVersionsGvk {
		err := group.client.
			Global().DeleteServiceVersionByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Services().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/servicesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateServiceByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateServiceByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Service) (*GlobalService, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.AdditionalAttributesGvk = nil
	objToCreate.Spec.ServiceVersionsGvk = nil
	objToCreate.Spec.ServiceDeploymentsGvk = nil
	objToCreate.Spec.ServiceStatefulSetsGvk = nil
	objToCreate.Spec.ServiceDaemonSetsGvk = nil
	objToCreate.Spec.EndpointsGvk = nil
	objToCreate.Spec.ServiceReplicaSetsGvk = nil
	objToCreate.Spec.ServiceJobsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Services().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"servicesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"Service\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalService{
		client:  group.client,
		Service: result,
	}, nil
}

// UpdateServiceByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateServiceByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Service) (*GlobalService, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Services().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueMetadata :=
		objToUpdate.Spec.Metadata
	patchOpMetadata := PatchOp{
		Op:    "replace",
		Path:  "/spec/metadata",
		Value: patchValueMetadata,
	}
	patch = append(patch, patchOpMetadata)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueNamespace :=
		objToUpdate.Spec.Namespace
	patchOpNamespace := PatchOp{
		Op:    "replace",
		Path:  "/spec/namespace",
		Value: patchValueNamespace,
	}
	patch = append(patch, patchOpNamespace)

	patchValueApiLink :=
		objToUpdate.Spec.ApiLink
	patchOpApiLink := PatchOp{
		Op:    "replace",
		Path:  "/spec/apiLink",
		Value: patchValueApiLink,
	}
	patch = append(patch, patchOpApiLink)

	patchValueIpAddress :=
		objToUpdate.Spec.IpAddress
	patchOpIpAddress := PatchOp{
		Op:    "replace",
		Path:  "/spec/ipAddress",
		Value: patchValueIpAddress,
	}
	patch = append(patch, patchOpIpAddress)

	patchValueAnnotations :=
		objToUpdate.Spec.Annotations
	patchOpAnnotations := PatchOp{
		Op:    "replace",
		Path:  "/spec/annotations",
		Value: patchValueAnnotations,
	}
	patch = append(patch, patchOpAnnotations)

	patchValueCreationTimestamp :=
		objToUpdate.Spec.CreationTimestamp
	patchOpCreationTimestamp := PatchOp{
		Op:    "replace",
		Path:  "/spec/creationTimestamp",
		Value: patchValueCreationTimestamp,
	}
	patch = append(patch, patchOpCreationTimestamp)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueUid :=
		objToUpdate.Spec.Uid
	patchOpUid := PatchOp{
		Op:    "replace",
		Path:  "/spec/uid",
		Value: patchValueUid,
	}
	patch = append(patch, patchOpUid)

	patchValuePorts :=
		objToUpdate.Spec.Ports
	patchOpPorts := PatchOp{
		Op:    "replace",
		Path:  "/spec/ports",
		Value: patchValuePorts,
	}
	patch = append(patch, patchOpPorts)

	patchValueSelector :=
		objToUpdate.Spec.Selector
	patchOpSelector := PatchOp{
		Op:    "replace",
		Path:  "/spec/selector",
		Value: patchValueSelector,
	}
	patch = append(patch, patchOpSelector)

	patchValueType :=
		objToUpdate.Spec.Type
	patchOpType := PatchOp{
		Op:    "replace",
		Path:  "/spec/type",
		Value: patchValueType,
	}
	patch = append(patch, patchOpType)

	patchValueStatus :=
		objToUpdate.Spec.Status
	patchOpStatus := PatchOp{
		Op:    "replace",
		Path:  "/spec/status",
		Value: patchValueStatus,
	}
	patch = append(patch, patchOpStatus)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Services().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalService{
		client:  group.client,
		Service: result,
	}, nil
}

// ListServices returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListServices(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalService, err error) {
	key := "services.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalService, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Service)
			result[k] = &GlobalService{
				client:  group.client,
				Service: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Services().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalService, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalService{
				client:  group.client,
				Service: &item,
			}
		}
	}
	return
}

type GlobalService struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Service
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalService) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteServiceByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Service = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalService) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateServiceByName(ctx, obj.Service)
	if err != nil {
		return err
	}
	obj.Service = result.Service
	return nil
}

func (obj *GlobalService) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

// GetAllAdditionalAttributes returns all children of given type
func (obj *GlobalService) GetAllAdditionalAttributes(ctx context.Context) (
	result []*GlobalAdditionalAttributes, err error) {
	result = make([]*GlobalAdditionalAttributes, 0, len(obj.Spec.AdditionalAttributesGvk))
	for _, v := range obj.Spec.AdditionalAttributesGvk {
		l, err := obj.client.Global().GetAdditionalAttributesByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetAdditionalAttributes returns child which has given displayName
func (obj *GlobalService) GetAdditionalAttributes(ctx context.Context,
	displayName string) (result *GlobalAdditionalAttributes, err error) {
	l, ok := obj.Spec.AdditionalAttributesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Service", "AdditionalAttributes", displayName)
	}
	result, err = obj.client.Global().GetAdditionalAttributesByName(ctx, l.Name)
	return
}

// AddAdditionalAttributes calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalService) AddAdditionalAttributes(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AdditionalAttributes) (result *GlobalAdditionalAttributes, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["services.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["services.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateAdditionalAttributesByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetServiceByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Service = updatedObj.Service
	}
	return
}

// DeleteAdditionalAttributes calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalService) DeleteAdditionalAttributes(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.AdditionalAttributesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Service", "AdditionalAttributes", displayName)
	}
	err = obj.client.Global().DeleteAdditionalAttributesByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetServiceByName(ctx, obj.GetName())
	if err == nil {
		obj.Service = updatedObj.Service
	}
	return
}

// GetAllServiceVersions returns all children of given type
func (obj *GlobalService) GetAllServiceVersions(ctx context.Context) (
	result []*GlobalServiceVersion, err error) {
	result = make([]*GlobalServiceVersion, 0, len(obj.Spec.ServiceVersionsGvk))
	for _, v := range obj.Spec.ServiceVersionsGvk {
		l, err := obj.client.Global().GetServiceVersionByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceVersions returns child which has given displayName
func (obj *GlobalService) GetServiceVersions(ctx context.Context,
	displayName string) (result *GlobalServiceVersion, err error) {
	l, ok := obj.Spec.ServiceVersionsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Service", "ServiceVersions", displayName)
	}
	result, err = obj.client.Global().GetServiceVersionByName(ctx, l.Name)
	return
}

// AddServiceVersions calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalService) AddServiceVersions(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceVersion) (result *GlobalServiceVersion, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["services.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["services.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceVersionByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetServiceByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Service = updatedObj.Service
	}
	return
}

// DeleteServiceVersions calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalService) DeleteServiceVersions(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ServiceVersionsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Service", "ServiceVersions", displayName)
	}
	err = obj.client.Global().DeleteServiceVersionByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetServiceByName(ctx, obj.GetName())
	if err == nil {
		obj.Service = updatedObj.Service
	}
	return
}

// GetAllServiceDeployments returns all links of given type
func (obj *GlobalService) GetAllServiceDeployments(ctx context.Context) (
	result []*GlobalServiceDeployment, err error) {
	result = make([]*GlobalServiceDeployment, 0, len(obj.Spec.ServiceDeploymentsGvk))
	for _, v := range obj.Spec.ServiceDeploymentsGvk {
		l, err := obj.client.Global().GetServiceDeploymentByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceDeployments returns link which has given displayName
func (obj *GlobalService) GetServiceDeployments(ctx context.Context,
	displayName string) (result *GlobalServiceDeployment, err error) {
	l, ok := obj.Spec.ServiceDeploymentsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.Service", "ServiceDeployments", displayName)
	}
	result, err = obj.client.Global().GetServiceDeploymentByName(ctx, l.Name)
	return
}

// LinkServiceDeployments links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalService) LinkServiceDeployments(ctx context.Context,
	linkToAdd *GlobalServiceDeployment) error {

	payload := "{\"spec\": {\"serviceDeploymentsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceDeployment\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().Services().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Service = result
	return nil
}

// UnlinkServiceDeployments unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalService) UnlinkServiceDeployments(ctx context.Context,
	linkToRemove *GlobalServiceDeployment) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceDeploymentsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Services().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Service = result
	return nil

}

// GetAllServiceStatefulSets returns all links of given type
func (obj *GlobalService) GetAllServiceStatefulSets(ctx context.Context) (
	result []*GlobalServiceStatefulSet, err error) {
	result = make([]*GlobalServiceStatefulSet, 0, len(obj.Spec.ServiceStatefulSetsGvk))
	for _, v := range obj.Spec.ServiceStatefulSetsGvk {
		l, err := obj.client.Global().GetServiceStatefulSetByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceStatefulSets returns link which has given displayName
func (obj *GlobalService) GetServiceStatefulSets(ctx context.Context,
	displayName string) (result *GlobalServiceStatefulSet, err error) {
	l, ok := obj.Spec.ServiceStatefulSetsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.Service", "ServiceStatefulSets", displayName)
	}
	result, err = obj.client.Global().GetServiceStatefulSetByName(ctx, l.Name)
	return
}

// LinkServiceStatefulSets links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalService) LinkServiceStatefulSets(ctx context.Context,
	linkToAdd *GlobalServiceStatefulSet) error {

	payload := "{\"spec\": {\"serviceStatefulSetsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceStatefulSet\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().Services().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Service = result
	return nil
}

// UnlinkServiceStatefulSets unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalService) UnlinkServiceStatefulSets(ctx context.Context,
	linkToRemove *GlobalServiceStatefulSet) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceStatefulSetsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Services().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Service = result
	return nil

}

// GetAllServiceDaemonSets returns all links of given type
func (obj *GlobalService) GetAllServiceDaemonSets(ctx context.Context) (
	result []*GlobalServiceDaemonSet, err error) {
	result = make([]*GlobalServiceDaemonSet, 0, len(obj.Spec.ServiceDaemonSetsGvk))
	for _, v := range obj.Spec.ServiceDaemonSetsGvk {
		l, err := obj.client.Global().GetServiceDaemonSetByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceDaemonSets returns link which has given displayName
func (obj *GlobalService) GetServiceDaemonSets(ctx context.Context,
	displayName string) (result *GlobalServiceDaemonSet, err error) {
	l, ok := obj.Spec.ServiceDaemonSetsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.Service", "ServiceDaemonSets", displayName)
	}
	result, err = obj.client.Global().GetServiceDaemonSetByName(ctx, l.Name)
	return
}

// LinkServiceDaemonSets links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalService) LinkServiceDaemonSets(ctx context.Context,
	linkToAdd *GlobalServiceDaemonSet) error {

	payload := "{\"spec\": {\"serviceDaemonSetsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceDaemonSet\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().Services().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Service = result
	return nil
}

// UnlinkServiceDaemonSets unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalService) UnlinkServiceDaemonSets(ctx context.Context,
	linkToRemove *GlobalServiceDaemonSet) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceDaemonSetsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Services().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Service = result
	return nil

}

// GetAllEndpoints returns all links of given type
func (obj *GlobalService) GetAllEndpoints(ctx context.Context) (
	result []*GlobalEndpoints, err error) {
	result = make([]*GlobalEndpoints, 0, len(obj.Spec.EndpointsGvk))
	for _, v := range obj.Spec.EndpointsGvk {
		l, err := obj.client.Global().GetEndpointsByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetEndpoints returns link which has given displayName
func (obj *GlobalService) GetEndpoints(ctx context.Context,
	displayName string) (result *GlobalEndpoints, err error) {
	l, ok := obj.Spec.EndpointsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.Service", "Endpoints", displayName)
	}
	result, err = obj.client.Global().GetEndpointsByName(ctx, l.Name)
	return
}

// LinkEndpoints links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalService) LinkEndpoints(ctx context.Context,
	linkToAdd *GlobalEndpoints) error {

	payload := "{\"spec\": {\"endpointsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"Endpoints\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().Services().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Service = result
	return nil
}

// UnlinkEndpoints unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalService) UnlinkEndpoints(ctx context.Context,
	linkToRemove *GlobalEndpoints) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/endpointsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Services().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Service = result
	return nil

}

// GetAllServiceReplicaSets returns all links of given type
func (obj *GlobalService) GetAllServiceReplicaSets(ctx context.Context) (
	result []*GlobalServiceReplicaSet, err error) {
	result = make([]*GlobalServiceReplicaSet, 0, len(obj.Spec.ServiceReplicaSetsGvk))
	for _, v := range obj.Spec.ServiceReplicaSetsGvk {
		l, err := obj.client.Global().GetServiceReplicaSetByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceReplicaSets returns link which has given displayName
func (obj *GlobalService) GetServiceReplicaSets(ctx context.Context,
	displayName string) (result *GlobalServiceReplicaSet, err error) {
	l, ok := obj.Spec.ServiceReplicaSetsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.Service", "ServiceReplicaSets", displayName)
	}
	result, err = obj.client.Global().GetServiceReplicaSetByName(ctx, l.Name)
	return
}

// LinkServiceReplicaSets links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalService) LinkServiceReplicaSets(ctx context.Context,
	linkToAdd *GlobalServiceReplicaSet) error {

	payload := "{\"spec\": {\"serviceReplicaSetsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceReplicaSet\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().Services().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Service = result
	return nil
}

// UnlinkServiceReplicaSets unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalService) UnlinkServiceReplicaSets(ctx context.Context,
	linkToRemove *GlobalServiceReplicaSet) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceReplicaSetsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Services().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Service = result
	return nil

}

// GetAllServiceJobs returns all links of given type
func (obj *GlobalService) GetAllServiceJobs(ctx context.Context) (
	result []*GlobalServiceJob, err error) {
	result = make([]*GlobalServiceJob, 0, len(obj.Spec.ServiceJobsGvk))
	for _, v := range obj.Spec.ServiceJobsGvk {
		l, err := obj.client.Global().GetServiceJobByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceJobs returns link which has given displayName
func (obj *GlobalService) GetServiceJobs(ctx context.Context,
	displayName string) (result *GlobalServiceJob, err error) {
	l, ok := obj.Spec.ServiceJobsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.Service", "ServiceJobs", displayName)
	}
	result, err = obj.client.Global().GetServiceJobByName(ctx, l.Name)
	return
}

// LinkServiceJobs links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalService) LinkServiceJobs(ctx context.Context,
	linkToAdd *GlobalServiceJob) error {

	payload := "{\"spec\": {\"serviceJobsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceJob\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().Services().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Service = result
	return nil
}

// UnlinkServiceJobs unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalService) UnlinkServiceJobs(ctx context.Context,
	linkToRemove *GlobalServiceJob) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/serviceJobsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Services().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Service = result
	return nil

}

type serviceGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *serviceGlobalTsmV1Chainer) Subscribe() {
	key := "services.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewServiceInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *serviceGlobalTsmV1Chainer) Unsubscribe() {
	key := "services.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *serviceGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "services.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *serviceGlobalTsmV1Chainer) AdditionalAttributes(name string) *additionalattributesGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["additionalattributeses.global.tsm.tanzu.vmware.com"] = name
	return &additionalattributesGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetAdditionalAttributes calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *serviceGlobalTsmV1Chainer) GetAdditionalAttributes(ctx context.Context, displayName string) (result *GlobalAdditionalAttributes, err error) {
	hashedName := helper.GetHashedName("additionalattributeses.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetAdditionalAttributesByName(ctx, hashedName)
}

// AddAdditionalAttributes calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *serviceGlobalTsmV1Chainer) AddAdditionalAttributes(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AdditionalAttributes) (result *GlobalAdditionalAttributes, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("additionalattributeses.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateAdditionalAttributesByName(ctx, objToCreate)
}

// DeleteAdditionalAttributes calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *serviceGlobalTsmV1Chainer) DeleteAdditionalAttributes(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("additionalattributeses.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteAdditionalAttributesByName(ctx, hashedName)
}

func (c *serviceGlobalTsmV1Chainer) ServiceVersions(name string) *serviceversionGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["serviceversions.global.tsm.tanzu.vmware.com"] = name
	return &serviceversionGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetServiceVersions calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *serviceGlobalTsmV1Chainer) GetServiceVersions(ctx context.Context, displayName string) (result *GlobalServiceVersion, err error) {
	hashedName := helper.GetHashedName("serviceversions.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceVersionByName(ctx, hashedName)
}

// AddServiceVersions calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *serviceGlobalTsmV1Chainer) AddServiceVersions(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceVersion) (result *GlobalServiceVersion, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("serviceversions.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceVersionByName(ctx, objToCreate)
}

// DeleteServiceVersions calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *serviceGlobalTsmV1Chainer) DeleteServiceVersions(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("serviceversions.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceVersionByName(ctx, hashedName)
}

// GetSloConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetSloConfigByName(ctx context.Context, hashedName string) (*GlobalSloConfig, error) {
	key := "sloconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.SloConfig)
		return &GlobalSloConfig{
			client:    group.client,
			SloConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			SloConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalSloConfig{
			client:    group.client,
			SloConfig: result,
		}, nil
	}
}

// DeleteSloConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteSloConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SloConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.SloServicesGvk {
		err := group.client.
			Global().DeleteSloServiceConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		SloConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/slosGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateSloConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateSloConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SloConfig) (*GlobalSloConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.SloServicesGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SloConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"slosGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"SloConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalSloConfig{
		client:    group.client,
		SloConfig: result,
	}, nil
}

// UpdateSloConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateSloConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.SloConfig) (*GlobalSloConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			SloConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		SloConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalSloConfig{
		client:    group.client,
		SloConfig: result,
	}, nil
}

// ListSloConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListSloConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalSloConfig, err error) {
	key := "sloconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalSloConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.SloConfig)
			result[k] = &GlobalSloConfig{
				client:    group.client,
				SloConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			SloConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalSloConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalSloConfig{
				client:    group.client,
				SloConfig: &item,
			}
		}
	}
	return
}

type GlobalSloConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.SloConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalSloConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteSloConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.SloConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalSloConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateSloConfigByName(ctx, obj.SloConfig)
	if err != nil {
		return err
	}
	obj.SloConfig = result.SloConfig
	return nil
}

func (obj *GlobalSloConfig) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

// GetAllSloServices returns all children of given type
func (obj *GlobalSloConfig) GetAllSloServices(ctx context.Context) (
	result []*GlobalSloServiceConfig, err error) {
	result = make([]*GlobalSloServiceConfig, 0, len(obj.Spec.SloServicesGvk))
	for _, v := range obj.Spec.SloServicesGvk {
		l, err := obj.client.Global().GetSloServiceConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetSloServices returns child which has given displayName
func (obj *GlobalSloConfig) GetSloServices(ctx context.Context,
	displayName string) (result *GlobalSloServiceConfig, err error) {
	l, ok := obj.Spec.SloServicesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.SloConfig", "SloServices", displayName)
	}
	result, err = obj.client.Global().GetSloServiceConfigByName(ctx, l.Name)
	return
}

// AddSloServices calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalSloConfig) AddSloServices(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SloServiceConfig) (result *GlobalSloServiceConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["sloconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["sloconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateSloServiceConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetSloConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.SloConfig = updatedObj.SloConfig
	}
	return
}

// DeleteSloServices calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalSloConfig) DeleteSloServices(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.SloServicesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.SloConfig", "SloServices", displayName)
	}
	err = obj.client.Global().DeleteSloServiceConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetSloConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.SloConfig = updatedObj.SloConfig
	}
	return
}

type sloconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *sloconfigGlobalTsmV1Chainer) Subscribe() {
	key := "sloconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSloConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *sloconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "sloconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *sloconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "sloconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *sloconfigGlobalTsmV1Chainer) SloServices(name string) *sloserviceconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["sloserviceconfigs.global.tsm.tanzu.vmware.com"] = name
	return &sloserviceconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetSloServices calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *sloconfigGlobalTsmV1Chainer) GetSloServices(ctx context.Context, displayName string) (result *GlobalSloServiceConfig, err error) {
	hashedName := helper.GetHashedName("sloserviceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetSloServiceConfigByName(ctx, hashedName)
}

// AddSloServices calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *sloconfigGlobalTsmV1Chainer) AddSloServices(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SloServiceConfig) (result *GlobalSloServiceConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("sloserviceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateSloServiceConfigByName(ctx, objToCreate)
}

// DeleteSloServices calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *sloconfigGlobalTsmV1Chainer) DeleteSloServices(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("sloserviceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteSloServiceConfigByName(ctx, hashedName)
}

// GetSloServiceConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetSloServiceConfigByName(ctx context.Context, hashedName string) (*GlobalSloServiceConfig, error) {
	key := "sloserviceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.SloServiceConfig)
		return &GlobalSloServiceConfig{
			client:           group.client,
			SloServiceConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			SloServiceConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalSloServiceConfig{
			client:           group.client,
			SloServiceConfig: result,
		}, nil
	}
}

// DeleteSloServiceConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteSloServiceConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SloServiceConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		SloServiceConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/sloServicesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["sloconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("sloconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		SloConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateSloServiceConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateSloServiceConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SloServiceConfig) (*GlobalSloServiceConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SloServiceConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["sloconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("sloconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"sloServicesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"SloServiceConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		SloConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalSloServiceConfig{
		client:           group.client,
		SloServiceConfig: result,
	}, nil
}

// UpdateSloServiceConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateSloServiceConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.SloServiceConfig) (*GlobalSloServiceConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			SloServiceConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueRemainingBudget :=
		objToUpdate.Spec.RemainingBudget
	patchOpRemainingBudget := PatchOp{
		Op:    "replace",
		Path:  "/spec/remainingBudget",
		Value: patchValueRemainingBudget,
	}
	patch = append(patch, patchOpRemainingBudget)

	patchValueLastUpdateTime :=
		objToUpdate.Spec.LastUpdateTime
	patchOpLastUpdateTime := PatchOp{
		Op:    "replace",
		Path:  "/spec/lastUpdateTime",
		Value: patchValueLastUpdateTime,
	}
	patch = append(patch, patchOpLastUpdateTime)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		SloServiceConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalSloServiceConfig{
		client:           group.client,
		SloServiceConfig: result,
	}, nil
}

// ListSloServiceConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListSloServiceConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalSloServiceConfig, err error) {
	key := "sloserviceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalSloServiceConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.SloServiceConfig)
			result[k] = &GlobalSloServiceConfig{
				client:           group.client,
				SloServiceConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			SloServiceConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalSloServiceConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalSloServiceConfig{
				client:           group.client,
				SloServiceConfig: &item,
			}
		}
	}
	return
}

type GlobalSloServiceConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.SloServiceConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalSloServiceConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteSloServiceConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.SloServiceConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalSloServiceConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateSloServiceConfigByName(ctx, obj.SloServiceConfig)
	if err != nil {
		return err
	}
	obj.SloServiceConfig = result.SloServiceConfig
	return nil
}

func (obj *GlobalSloServiceConfig) GetParent(ctx context.Context) (result *GlobalSloConfig, err error) {
	hashedName := helper.GetHashedName("sloconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["sloconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetSloConfigByName(ctx, hashedName)
}

type sloserviceconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *sloserviceconfigGlobalTsmV1Chainer) Subscribe() {
	key := "sloserviceconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSloServiceConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *sloserviceconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "sloserviceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *sloserviceconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "sloserviceconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetSLOFolderByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetSLOFolderByName(ctx context.Context, hashedName string) (*GlobalSLOFolder, error) {
	key := "slofolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.SLOFolder)
		return &GlobalSLOFolder{
			client:    group.client,
			SLOFolder: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			SLOFolders().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalSLOFolder{
			client:    group.client,
			SLOFolder: result,
		}, nil
	}
}

// DeleteSLOFolderByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteSLOFolderByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SLOFolders().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.SlosGvk {
		err := group.client.
			Global().DeleteFederatedSloConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		SLOFolders().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/sloFolderGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["runtimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateSLOFolderByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateSLOFolderByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SLOFolder) (*GlobalSLOFolder, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.SlosGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SLOFolders().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["runtimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/sloFolderGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "SLOFolder",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalSLOFolder{
		client:    group.client,
		SLOFolder: result,
	}, nil
}

// UpdateSLOFolderByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateSLOFolderByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.SLOFolder) (*GlobalSLOFolder, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			SLOFolders().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		SLOFolders().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalSLOFolder{
		client:    group.client,
		SLOFolder: result,
	}, nil
}

// ListSLOFolders returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListSLOFolders(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalSLOFolder, err error) {
	key := "slofolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalSLOFolder, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.SLOFolder)
			result[k] = &GlobalSLOFolder{
				client:    group.client,
				SLOFolder: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			SLOFolders().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalSLOFolder, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalSLOFolder{
				client:    group.client,
				SLOFolder: &item,
			}
		}
	}
	return
}

type GlobalSLOFolder struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.SLOFolder
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalSLOFolder) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteSLOFolderByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.SLOFolder = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalSLOFolder) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateSLOFolderByName(ctx, obj.SLOFolder)
	if err != nil {
		return err
	}
	obj.SLOFolder = result.SLOFolder
	return nil
}

func (obj *GlobalSLOFolder) GetParent(ctx context.Context) (result *GlobalRuntime, err error) {
	hashedName := helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["runtimes.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetRuntimeByName(ctx, hashedName)
}

// GetAllSlos returns all children of given type
func (obj *GlobalSLOFolder) GetAllSlos(ctx context.Context) (
	result []*GlobalFederatedSloConfig, err error) {
	result = make([]*GlobalFederatedSloConfig, 0, len(obj.Spec.SlosGvk))
	for _, v := range obj.Spec.SlosGvk {
		l, err := obj.client.Global().GetFederatedSloConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetSlos returns child which has given displayName
func (obj *GlobalSLOFolder) GetSlos(ctx context.Context,
	displayName string) (result *GlobalFederatedSloConfig, err error) {
	l, ok := obj.Spec.SlosGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.SLOFolder", "Slos", displayName)
	}
	result, err = obj.client.Global().GetFederatedSloConfigByName(ctx, l.Name)
	return
}

// AddSlos calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalSLOFolder) AddSlos(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.FederatedSloConfig) (result *GlobalFederatedSloConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["slofolders.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["slofolders.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateFederatedSloConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetSLOFolderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.SLOFolder = updatedObj.SLOFolder
	}
	return
}

// DeleteSlos calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalSLOFolder) DeleteSlos(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.SlosGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.SLOFolder", "Slos", displayName)
	}
	err = obj.client.Global().DeleteFederatedSloConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetSLOFolderByName(ctx, obj.GetName())
	if err == nil {
		obj.SLOFolder = updatedObj.SLOFolder
	}
	return
}

type slofolderGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *slofolderGlobalTsmV1Chainer) Subscribe() {
	key := "slofolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSLOFolderInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *slofolderGlobalTsmV1Chainer) Unsubscribe() {
	key := "slofolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *slofolderGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "slofolders.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *slofolderGlobalTsmV1Chainer) Slos(name string) *federatedsloconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["federatedsloconfigs.global.tsm.tanzu.vmware.com"] = name
	return &federatedsloconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetSlos calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *slofolderGlobalTsmV1Chainer) GetSlos(ctx context.Context, displayName string) (result *GlobalFederatedSloConfig, err error) {
	hashedName := helper.GetHashedName("federatedsloconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetFederatedSloConfigByName(ctx, hashedName)
}

// AddSlos calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *slofolderGlobalTsmV1Chainer) AddSlos(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.FederatedSloConfig) (result *GlobalFederatedSloConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("federatedsloconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateFederatedSloConfigByName(ctx, objToCreate)
}

// DeleteSlos calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *slofolderGlobalTsmV1Chainer) DeleteSlos(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("federatedsloconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteFederatedSloConfigByName(ctx, hashedName)
}

// GetFederatedSloConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetFederatedSloConfigByName(ctx context.Context, hashedName string) (*GlobalFederatedSloConfig, error) {
	key := "federatedsloconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.FederatedSloConfig)
		return &GlobalFederatedSloConfig{
			client:             group.client,
			FederatedSloConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			FederatedSloConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalFederatedSloConfig{
			client:             group.client,
			FederatedSloConfig: result,
		}, nil
	}
}

// DeleteFederatedSloConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteFederatedSloConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		FederatedSloConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.SloServicesGvk {
		err := group.client.
			Global().DeleteFederatedSloServiceConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		FederatedSloConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/slosGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["slofolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("slofolders.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		SLOFolders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateFederatedSloConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateFederatedSloConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.FederatedSloConfig) (*GlobalFederatedSloConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.SloServicesGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		FederatedSloConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["slofolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("slofolders.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"slosGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"FederatedSloConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		SLOFolders().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalFederatedSloConfig{
		client:             group.client,
		FederatedSloConfig: result,
	}, nil
}

// UpdateFederatedSloConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateFederatedSloConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.FederatedSloConfig) (*GlobalFederatedSloConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			FederatedSloConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		FederatedSloConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalFederatedSloConfig{
		client:             group.client,
		FederatedSloConfig: result,
	}, nil
}

// ListFederatedSloConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListFederatedSloConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalFederatedSloConfig, err error) {
	key := "federatedsloconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalFederatedSloConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.FederatedSloConfig)
			result[k] = &GlobalFederatedSloConfig{
				client:             group.client,
				FederatedSloConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			FederatedSloConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalFederatedSloConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalFederatedSloConfig{
				client:             group.client,
				FederatedSloConfig: &item,
			}
		}
	}
	return
}

type GlobalFederatedSloConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.FederatedSloConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalFederatedSloConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteFederatedSloConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.FederatedSloConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalFederatedSloConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateFederatedSloConfigByName(ctx, obj.FederatedSloConfig)
	if err != nil {
		return err
	}
	obj.FederatedSloConfig = result.FederatedSloConfig
	return nil
}

func (obj *GlobalFederatedSloConfig) GetParent(ctx context.Context) (result *GlobalSLOFolder, err error) {
	hashedName := helper.GetHashedName("slofolders.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["slofolders.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetSLOFolderByName(ctx, hashedName)
}

// GetAllSloServices returns all children of given type
func (obj *GlobalFederatedSloConfig) GetAllSloServices(ctx context.Context) (
	result []*GlobalFederatedSloServiceConfig, err error) {
	result = make([]*GlobalFederatedSloServiceConfig, 0, len(obj.Spec.SloServicesGvk))
	for _, v := range obj.Spec.SloServicesGvk {
		l, err := obj.client.Global().GetFederatedSloServiceConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetSloServices returns child which has given displayName
func (obj *GlobalFederatedSloConfig) GetSloServices(ctx context.Context,
	displayName string) (result *GlobalFederatedSloServiceConfig, err error) {
	l, ok := obj.Spec.SloServicesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.FederatedSloConfig", "SloServices", displayName)
	}
	result, err = obj.client.Global().GetFederatedSloServiceConfigByName(ctx, l.Name)
	return
}

// AddSloServices calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalFederatedSloConfig) AddSloServices(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.FederatedSloServiceConfig) (result *GlobalFederatedSloServiceConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["federatedsloconfigs.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["federatedsloconfigs.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateFederatedSloServiceConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetFederatedSloConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.FederatedSloConfig = updatedObj.FederatedSloConfig
	}
	return
}

// DeleteSloServices calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalFederatedSloConfig) DeleteSloServices(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.SloServicesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.FederatedSloConfig", "SloServices", displayName)
	}
	err = obj.client.Global().DeleteFederatedSloServiceConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetFederatedSloConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.FederatedSloConfig = updatedObj.FederatedSloConfig
	}
	return
}

type federatedsloconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *federatedsloconfigGlobalTsmV1Chainer) Subscribe() {
	key := "federatedsloconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewFederatedSloConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *federatedsloconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "federatedsloconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *federatedsloconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "federatedsloconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *federatedsloconfigGlobalTsmV1Chainer) SloServices(name string) *federatedsloserviceconfigGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["federatedsloserviceconfigs.global.tsm.tanzu.vmware.com"] = name
	return &federatedsloserviceconfigGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetSloServices calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *federatedsloconfigGlobalTsmV1Chainer) GetSloServices(ctx context.Context, displayName string) (result *GlobalFederatedSloServiceConfig, err error) {
	hashedName := helper.GetHashedName("federatedsloserviceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetFederatedSloServiceConfigByName(ctx, hashedName)
}

// AddSloServices calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *federatedsloconfigGlobalTsmV1Chainer) AddSloServices(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.FederatedSloServiceConfig) (result *GlobalFederatedSloServiceConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("federatedsloserviceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateFederatedSloServiceConfigByName(ctx, objToCreate)
}

// DeleteSloServices calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *federatedsloconfigGlobalTsmV1Chainer) DeleteSloServices(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("federatedsloserviceconfigs.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteFederatedSloServiceConfigByName(ctx, hashedName)
}

// GetFederatedSloServiceConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetFederatedSloServiceConfigByName(ctx context.Context, hashedName string) (*GlobalFederatedSloServiceConfig, error) {
	key := "federatedsloserviceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.FederatedSloServiceConfig)
		return &GlobalFederatedSloServiceConfig{
			client:                    group.client,
			FederatedSloServiceConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			FederatedSloServiceConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalFederatedSloServiceConfig{
			client:                    group.client,
			FederatedSloServiceConfig: result,
		}, nil
	}
}

// DeleteFederatedSloServiceConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteFederatedSloServiceConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		FederatedSloServiceConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		FederatedSloServiceConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/sloServicesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["federatedsloconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("federatedsloconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		FederatedSloConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateFederatedSloServiceConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateFederatedSloServiceConfigByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.FederatedSloServiceConfig) (*GlobalFederatedSloServiceConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		FederatedSloServiceConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["federatedsloconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("federatedsloconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"sloServicesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"FederatedSloServiceConfig\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		FederatedSloConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalFederatedSloServiceConfig{
		client:                    group.client,
		FederatedSloServiceConfig: result,
	}, nil
}

// UpdateFederatedSloServiceConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateFederatedSloServiceConfigByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.FederatedSloServiceConfig) (*GlobalFederatedSloServiceConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			FederatedSloServiceConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueRemainingBudget :=
		objToUpdate.Spec.RemainingBudget
	patchOpRemainingBudget := PatchOp{
		Op:    "replace",
		Path:  "/spec/remainingBudget",
		Value: patchValueRemainingBudget,
	}
	patch = append(patch, patchOpRemainingBudget)

	patchValueLastUpdateTime :=
		objToUpdate.Spec.LastUpdateTime
	patchOpLastUpdateTime := PatchOp{
		Op:    "replace",
		Path:  "/spec/lastUpdateTime",
		Value: patchValueLastUpdateTime,
	}
	patch = append(patch, patchOpLastUpdateTime)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		FederatedSloServiceConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalFederatedSloServiceConfig{
		client:                    group.client,
		FederatedSloServiceConfig: result,
	}, nil
}

// ListFederatedSloServiceConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListFederatedSloServiceConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalFederatedSloServiceConfig, err error) {
	key := "federatedsloserviceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalFederatedSloServiceConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.FederatedSloServiceConfig)
			result[k] = &GlobalFederatedSloServiceConfig{
				client:                    group.client,
				FederatedSloServiceConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			FederatedSloServiceConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalFederatedSloServiceConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalFederatedSloServiceConfig{
				client:                    group.client,
				FederatedSloServiceConfig: &item,
			}
		}
	}
	return
}

type GlobalFederatedSloServiceConfig struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.FederatedSloServiceConfig
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalFederatedSloServiceConfig) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteFederatedSloServiceConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.FederatedSloServiceConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalFederatedSloServiceConfig) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateFederatedSloServiceConfigByName(ctx, obj.FederatedSloServiceConfig)
	if err != nil {
		return err
	}
	obj.FederatedSloServiceConfig = result.FederatedSloServiceConfig
	return nil
}

func (obj *GlobalFederatedSloServiceConfig) GetParent(ctx context.Context) (result *GlobalFederatedSloConfig, err error) {
	hashedName := helper.GetHashedName("federatedsloconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["federatedsloconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetFederatedSloConfigByName(ctx, hashedName)
}

type federatedsloserviceconfigGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *federatedsloserviceconfigGlobalTsmV1Chainer) Subscribe() {
	key := "federatedsloserviceconfigs.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewFederatedSloServiceConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *federatedsloserviceconfigGlobalTsmV1Chainer) Unsubscribe() {
	key := "federatedsloserviceconfigs.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *federatedsloserviceconfigGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "federatedsloserviceconfigs.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetSLOPolicyByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetSLOPolicyByName(ctx context.Context, hashedName string) (*GlobalSLOPolicy, error) {
	key := "slopolicies.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.SLOPolicy)
		return &GlobalSLOPolicy{
			client:    group.client,
			SLOPolicy: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			SLOPolicies().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalSLOPolicy{
			client:    group.client,
			SLOPolicy: result,
		}, nil
	}
}

// DeleteSLOPolicyByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteSLOPolicyByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SLOPolicies().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		SLOPolicies().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/sloPoliciesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateSLOPolicyByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateSLOPolicyByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SLOPolicy) (*GlobalSLOPolicy, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SLOPolicies().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"sloPoliciesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"SLOPolicy\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalSLOPolicy{
		client:    group.client,
		SLOPolicy: result,
	}, nil
}

// UpdateSLOPolicyByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateSLOPolicyByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.SLOPolicy) (*GlobalSLOPolicy, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			SLOPolicies().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueDisabled :=
		objToUpdate.Spec.Disabled
	patchOpDisabled := PatchOp{
		Op:    "replace",
		Path:  "/spec/disabled",
		Value: patchValueDisabled,
	}
	patch = append(patch, patchOpDisabled)

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueSlis :=
		objToUpdate.Spec.Slis
	patchOpSlis := PatchOp{
		Op:    "replace",
		Path:  "/spec/slis",
		Value: patchValueSlis,
	}
	patch = append(patch, patchOpSlis)

	if objToUpdate.Spec.ServiceNames != nil {
		patchValueServiceNames :=
			objToUpdate.Spec.ServiceNames
		patchOpServiceNames := PatchOp{
			Op:    "replace",
			Path:  "/spec/serviceNames",
			Value: patchValueServiceNames,
		}
		patch = append(patch, patchOpServiceNames)
	}

	patchValueSloTargetValue :=
		objToUpdate.Spec.SloTargetValue
	patchOpSloTargetValue := PatchOp{
		Op:    "replace",
		Path:  "/spec/sloTargetValue",
		Value: patchValueSloTargetValue,
	}
	patch = append(patch, patchOpSloTargetValue)

	patchValueSloPeriod :=
		objToUpdate.Spec.SloPeriod
	patchOpSloPeriod := PatchOp{
		Op:    "replace",
		Path:  "/spec/sloPeriod",
		Value: patchValueSloPeriod,
	}
	patch = append(patch, patchOpSloPeriod)

	patchValueSloKind :=
		objToUpdate.Spec.SloKind
	patchOpSloKind := PatchOp{
		Op:    "replace",
		Path:  "/spec/sloKind",
		Value: patchValueSloKind,
	}
	patch = append(patch, patchOpSloKind)

	if objToUpdate.Spec.Actions != nil {
		patchValueActions :=
			objToUpdate.Spec.Actions
		patchOpActions := PatchOp{
			Op:    "replace",
			Path:  "/spec/actions",
			Value: patchValueActions,
		}
		patch = append(patch, patchOpActions)
	}

	patchValueSloCreationTime :=
		objToUpdate.Spec.SloCreationTime
	patchOpSloCreationTime := PatchOp{
		Op:    "replace",
		Path:  "/spec/sloCreationTime",
		Value: patchValueSloCreationTime,
	}
	patch = append(patch, patchOpSloCreationTime)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		SLOPolicies().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalSLOPolicy{
		client:    group.client,
		SLOPolicy: result,
	}, nil
}

// ListSLOPolicies returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListSLOPolicies(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalSLOPolicy, err error) {
	key := "slopolicies.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalSLOPolicy, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.SLOPolicy)
			result[k] = &GlobalSLOPolicy{
				client:    group.client,
				SLOPolicy: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			SLOPolicies().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalSLOPolicy, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalSLOPolicy{
				client:    group.client,
				SLOPolicy: &item,
			}
		}
	}
	return
}

type GlobalSLOPolicy struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.SLOPolicy
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalSLOPolicy) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteSLOPolicyByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.SLOPolicy = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalSLOPolicy) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateSLOPolicyByName(ctx, obj.SLOPolicy)
	if err != nil {
		return err
	}
	obj.SLOPolicy = result.SLOPolicy
	return nil
}

func (obj *GlobalSLOPolicy) GetParent(ctx context.Context) (result *GlobalGNS, err error) {
	hashedName := helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnss.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGNSByName(ctx, hashedName)
}

type slopolicyGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *slopolicyGlobalTsmV1Chainer) Subscribe() {
	key := "slopolicies.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSLOPolicyInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *slopolicyGlobalTsmV1Chainer) Unsubscribe() {
	key := "slopolicies.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *slopolicyGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "slopolicies.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetSvcGroupByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetSvcGroupByName(ctx context.Context, hashedName string) (*GlobalSvcGroup, error) {
	key := "svcgroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.SvcGroup)
		return &GlobalSvcGroup{
			client:   group.client,
			SvcGroup: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			SvcGroups().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalSvcGroup{
			client:   group.client,
			SvcGroup: result,
		}, nil
	}
}

// DeleteSvcGroupByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteSvcGroupByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SvcGroups().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		SvcGroups().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/svcGroupsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["resourcegroups.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("resourcegroups.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ResourceGroups().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateSvcGroupByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateSvcGroupByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.SvcGroup) (*GlobalSvcGroup, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ServicesGvk = nil
	objToCreate.Spec.DeploymentsGvk = nil
	objToCreate.Spec.DaemonsetsGvk = nil
	objToCreate.Spec.StatefulsetsGvk = nil
	objToCreate.Spec.JobsGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		SvcGroups().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["resourcegroups.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("resourcegroups.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"svcGroupsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"SvcGroup\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ResourceGroups().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalSvcGroup{
		client:   group.client,
		SvcGroup: result,
	}, nil
}

// UpdateSvcGroupByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateSvcGroupByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.SvcGroup) (*GlobalSvcGroup, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			SvcGroups().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDisplayName :=
		objToUpdate.Spec.DisplayName
	patchOpDisplayName := PatchOp{
		Op:    "replace",
		Path:  "/spec/displayName",
		Value: patchValueDisplayName,
	}
	patch = append(patch, patchOpDisplayName)

	patchValueInternalPredefinedGroup :=
		objToUpdate.Spec.InternalPredefinedGroup
	patchOpInternalPredefinedGroup := PatchOp{
		Op:    "replace",
		Path:  "/spec/internalPredefinedGroup",
		Value: patchValueInternalPredefinedGroup,
	}
	patch = append(patch, patchOpInternalPredefinedGroup)

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueColor :=
		objToUpdate.Spec.Color
	patchOpColor := PatchOp{
		Op:    "replace",
		Path:  "/spec/color",
		Value: patchValueColor,
	}
	patch = append(patch, patchOpColor)

	patchValueProjectId :=
		objToUpdate.Spec.ProjectId
	patchOpProjectId := PatchOp{
		Op:    "replace",
		Path:  "/spec/projectId",
		Value: patchValueProjectId,
	}
	patch = append(patch, patchOpProjectId)

	patchValueRules :=
		objToUpdate.Spec.Rules
	patchOpRules := PatchOp{
		Op:    "replace",
		Path:  "/spec/rules",
		Value: patchValueRules,
	}
	patch = append(patch, patchOpRules)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		SvcGroups().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalSvcGroup{
		client:   group.client,
		SvcGroup: result,
	}, nil
}

// ListSvcGroups returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListSvcGroups(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalSvcGroup, err error) {
	key := "svcgroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalSvcGroup, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.SvcGroup)
			result[k] = &GlobalSvcGroup{
				client:   group.client,
				SvcGroup: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			SvcGroups().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalSvcGroup, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalSvcGroup{
				client:   group.client,
				SvcGroup: &item,
			}
		}
	}
	return
}

type GlobalSvcGroup struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.SvcGroup
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalSvcGroup) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteSvcGroupByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.SvcGroup = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalSvcGroup) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateSvcGroupByName(ctx, obj.SvcGroup)
	if err != nil {
		return err
	}
	obj.SvcGroup = result.SvcGroup
	return nil
}

func (obj *GlobalSvcGroup) GetParent(ctx context.Context) (result *GlobalResourceGroup, err error) {
	hashedName := helper.GetHashedName("resourcegroups.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["resourcegroups.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetResourceGroupByName(ctx, hashedName)
}

// GetAllServices returns all links of given type
func (obj *GlobalSvcGroup) GetAllServices(ctx context.Context) (
	result []*GlobalService, err error) {
	result = make([]*GlobalService, 0, len(obj.Spec.ServicesGvk))
	for _, v := range obj.Spec.ServicesGvk {
		l, err := obj.client.Global().GetServiceByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServices returns link which has given displayName
func (obj *GlobalSvcGroup) GetServices(ctx context.Context,
	displayName string) (result *GlobalService, err error) {
	l, ok := obj.Spec.ServicesGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.SvcGroup", "Services", displayName)
	}
	result, err = obj.client.Global().GetServiceByName(ctx, l.Name)
	return
}

// LinkServices links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalSvcGroup) LinkServices(ctx context.Context,
	linkToAdd *GlobalService) error {

	payload := "{\"spec\": {\"servicesGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"Service\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().SvcGroups().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.SvcGroup = result
	return nil
}

// UnlinkServices unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalSvcGroup) UnlinkServices(ctx context.Context,
	linkToRemove *GlobalService) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/servicesGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().SvcGroups().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.SvcGroup = result
	return nil

}

// GetAllDeployments returns all links of given type
func (obj *GlobalSvcGroup) GetAllDeployments(ctx context.Context) (
	result []*GlobalServiceDeployment, err error) {
	result = make([]*GlobalServiceDeployment, 0, len(obj.Spec.DeploymentsGvk))
	for _, v := range obj.Spec.DeploymentsGvk {
		l, err := obj.client.Global().GetServiceDeploymentByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetDeployments returns link which has given displayName
func (obj *GlobalSvcGroup) GetDeployments(ctx context.Context,
	displayName string) (result *GlobalServiceDeployment, err error) {
	l, ok := obj.Spec.DeploymentsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.SvcGroup", "Deployments", displayName)
	}
	result, err = obj.client.Global().GetServiceDeploymentByName(ctx, l.Name)
	return
}

// LinkDeployments links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalSvcGroup) LinkDeployments(ctx context.Context,
	linkToAdd *GlobalServiceDeployment) error {

	payload := "{\"spec\": {\"deploymentsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceDeployment\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().SvcGroups().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.SvcGroup = result
	return nil
}

// UnlinkDeployments unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalSvcGroup) UnlinkDeployments(ctx context.Context,
	linkToRemove *GlobalServiceDeployment) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/deploymentsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().SvcGroups().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.SvcGroup = result
	return nil

}

// GetAllDaemonsets returns all links of given type
func (obj *GlobalSvcGroup) GetAllDaemonsets(ctx context.Context) (
	result []*GlobalServiceDaemonSet, err error) {
	result = make([]*GlobalServiceDaemonSet, 0, len(obj.Spec.DaemonsetsGvk))
	for _, v := range obj.Spec.DaemonsetsGvk {
		l, err := obj.client.Global().GetServiceDaemonSetByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetDaemonsets returns link which has given displayName
func (obj *GlobalSvcGroup) GetDaemonsets(ctx context.Context,
	displayName string) (result *GlobalServiceDaemonSet, err error) {
	l, ok := obj.Spec.DaemonsetsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.SvcGroup", "Daemonsets", displayName)
	}
	result, err = obj.client.Global().GetServiceDaemonSetByName(ctx, l.Name)
	return
}

// LinkDaemonsets links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalSvcGroup) LinkDaemonsets(ctx context.Context,
	linkToAdd *GlobalServiceDaemonSet) error {

	payload := "{\"spec\": {\"daemonsetsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceDaemonSet\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().SvcGroups().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.SvcGroup = result
	return nil
}

// UnlinkDaemonsets unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalSvcGroup) UnlinkDaemonsets(ctx context.Context,
	linkToRemove *GlobalServiceDaemonSet) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/daemonsetsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().SvcGroups().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.SvcGroup = result
	return nil

}

// GetAllStatefulsets returns all links of given type
func (obj *GlobalSvcGroup) GetAllStatefulsets(ctx context.Context) (
	result []*GlobalServiceStatefulSet, err error) {
	result = make([]*GlobalServiceStatefulSet, 0, len(obj.Spec.StatefulsetsGvk))
	for _, v := range obj.Spec.StatefulsetsGvk {
		l, err := obj.client.Global().GetServiceStatefulSetByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetStatefulsets returns link which has given displayName
func (obj *GlobalSvcGroup) GetStatefulsets(ctx context.Context,
	displayName string) (result *GlobalServiceStatefulSet, err error) {
	l, ok := obj.Spec.StatefulsetsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.SvcGroup", "Statefulsets", displayName)
	}
	result, err = obj.client.Global().GetServiceStatefulSetByName(ctx, l.Name)
	return
}

// LinkStatefulsets links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalSvcGroup) LinkStatefulsets(ctx context.Context,
	linkToAdd *GlobalServiceStatefulSet) error {

	payload := "{\"spec\": {\"statefulsetsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceStatefulSet\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().SvcGroups().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.SvcGroup = result
	return nil
}

// UnlinkStatefulsets unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalSvcGroup) UnlinkStatefulsets(ctx context.Context,
	linkToRemove *GlobalServiceStatefulSet) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/statefulsetsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().SvcGroups().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.SvcGroup = result
	return nil

}

// GetAllJobs returns all links of given type
func (obj *GlobalSvcGroup) GetAllJobs(ctx context.Context) (
	result []*GlobalServiceJob, err error) {
	result = make([]*GlobalServiceJob, 0, len(obj.Spec.JobsGvk))
	for _, v := range obj.Spec.JobsGvk {
		l, err := obj.client.Global().GetServiceJobByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetJobs returns link which has given displayName
func (obj *GlobalSvcGroup) GetJobs(ctx context.Context,
	displayName string) (result *GlobalServiceJob, err error) {
	l, ok := obj.Spec.JobsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.SvcGroup", "Jobs", displayName)
	}
	result, err = obj.client.Global().GetServiceJobByName(ctx, l.Name)
	return
}

// LinkJobs links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalSvcGroup) LinkJobs(ctx context.Context,
	linkToAdd *GlobalServiceJob) error {

	payload := "{\"spec\": {\"jobsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"ServiceJob\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().SvcGroups().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.SvcGroup = result
	return nil
}

// UnlinkJobs unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalSvcGroup) UnlinkJobs(ctx context.Context,
	linkToRemove *GlobalServiceJob) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/jobsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().SvcGroups().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.SvcGroup = result
	return nil

}

type svcgroupGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *svcgroupGlobalTsmV1Chainer) Subscribe() {
	key := "svcgroups.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewSvcGroupInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *svcgroupGlobalTsmV1Chainer) Unsubscribe() {
	key := "svcgroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *svcgroupGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "svcgroups.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetTableByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetTableByName(ctx context.Context, hashedName string) (*GlobalTable, error) {
	key := "tables.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Table)
		return &GlobalTable{
			client: group.client,
			Table:  result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Tables().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalTable{
			client: group.client,
			Table:  result,
		}, nil
	}
}

// DeleteTableByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteTableByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Tables().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Tables().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/tablesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["databases.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("databases.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Databases().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateTableByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateTableByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Table) (*GlobalTable, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.TemplateGvk = nil
	objToCreate.Spec.InventoryGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Tables().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["databases.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("databases.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"tablesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"Table\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Databases().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalTable{
		client: group.client,
		Table:  result,
	}, nil
}

// UpdateTableByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateTableByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Table) (*GlobalTable, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Tables().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Tables().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalTable{
		client: group.client,
		Table:  result,
	}, nil
}

// ListTables returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListTables(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalTable, err error) {
	key := "tables.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalTable, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Table)
			result[k] = &GlobalTable{
				client: group.client,
				Table:  item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Tables().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalTable, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalTable{
				client: group.client,
				Table:  &item,
			}
		}
	}
	return
}

type GlobalTable struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Table
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalTable) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteTableByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Table = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalTable) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateTableByName(ctx, obj.Table)
	if err != nil {
		return err
	}
	obj.Table = result.Table
	return nil
}

func (obj *GlobalTable) GetParent(ctx context.Context) (result *GlobalDatabase, err error) {
	hashedName := helper.GetHashedName("databases.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["databases.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDatabaseByName(ctx, hashedName)
}

// GetTemplate returns link of given type
func (obj *GlobalTable) GetTemplate(ctx context.Context) (
	result *GlobalTemplate, err error) {
	if obj.Spec.TemplateGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.Table", "Template")
	}
	return obj.client.Global().GetTemplateByName(ctx, obj.Spec.TemplateGvk.Name)
}

// LinkTemplate links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalTable) LinkTemplate(ctx context.Context,
	linkToAdd *GlobalTemplate) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/templateGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "Template",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Tables().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Table = result
	return nil
}

// UnlinkTemplate unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalTable) UnlinkTemplate(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/templateGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Tables().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Table = result
	return nil

}

// GetInventory returns link of given type
func (obj *GlobalTable) GetInventory(ctx context.Context) (
	result *GlobalInventory, err error) {
	if obj.Spec.InventoryGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.Table", "Inventory")
	}
	return obj.client.Global().GetInventoryByName(ctx, obj.Spec.InventoryGvk.Name)
}

// LinkInventory links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalTable) LinkInventory(ctx context.Context,
	linkToAdd *GlobalInventory) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/inventoryGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "Inventory",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Tables().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Table = result
	return nil
}

// UnlinkInventory unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalTable) UnlinkInventory(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/inventoryGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Tables().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Table = result
	return nil

}

type tableGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *tableGlobalTsmV1Chainer) Subscribe() {
	key := "tables.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewTableInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *tableGlobalTsmV1Chainer) Unsubscribe() {
	key := "tables.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *tableGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "tables.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetTemplateGroupByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetTemplateGroupByName(ctx context.Context, hashedName string) (*GlobalTemplateGroup, error) {
	key := "templategroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.TemplateGroup)
		return &GlobalTemplateGroup{
			client:        group.client,
			TemplateGroup: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			TemplateGroups().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalTemplateGroup{
			client:        group.client,
			TemplateGroup: result,
		}, nil
	}
}

// DeleteTemplateGroupByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteTemplateGroupByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		TemplateGroups().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.DataTemplatesGvk {
		err := group.client.
			Global().DeleteDataTemplateByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.NodeTemplatesGvk {
		err := group.client.
			Global().DeleteNodeTemplateByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.AppTemplatesGvk {
		err := group.client.
			Global().DeleteAppTemplateByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.ServiceTemplatesGvk {
		err := group.client.
			Global().DeleteServiceTemplateByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.PolicyTemplatesGvk {
		err := group.client.
			Global().DeletePolicyTemplateByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		TemplateGroups().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/templateGroupsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["templates.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("templates.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Templates().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateTemplateGroupByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateTemplateGroupByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.TemplateGroup) (*GlobalTemplateGroup, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.DataTemplatesGvk = nil
	objToCreate.Spec.NodeTemplatesGvk = nil
	objToCreate.Spec.AppTemplatesGvk = nil
	objToCreate.Spec.ServiceTemplatesGvk = nil
	objToCreate.Spec.PolicyTemplatesGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		TemplateGroups().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["templates.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("templates.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"templateGroupsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"TemplateGroup\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Templates().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalTemplateGroup{
		client:        group.client,
		TemplateGroup: result,
	}, nil
}

// UpdateTemplateGroupByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateTemplateGroupByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.TemplateGroup) (*GlobalTemplateGroup, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			TemplateGroups().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueProjectId :=
		objToUpdate.Spec.ProjectId
	patchOpProjectId := PatchOp{
		Op:    "replace",
		Path:  "/spec/projectId",
		Value: patchValueProjectId,
	}
	patch = append(patch, patchOpProjectId)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		TemplateGroups().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalTemplateGroup{
		client:        group.client,
		TemplateGroup: result,
	}, nil
}

// ListTemplateGroups returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListTemplateGroups(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalTemplateGroup, err error) {
	key := "templategroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalTemplateGroup, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.TemplateGroup)
			result[k] = &GlobalTemplateGroup{
				client:        group.client,
				TemplateGroup: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			TemplateGroups().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalTemplateGroup, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalTemplateGroup{
				client:        group.client,
				TemplateGroup: &item,
			}
		}
	}
	return
}

type GlobalTemplateGroup struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.TemplateGroup
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalTemplateGroup) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteTemplateGroupByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.TemplateGroup = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalTemplateGroup) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateTemplateGroupByName(ctx, obj.TemplateGroup)
	if err != nil {
		return err
	}
	obj.TemplateGroup = result.TemplateGroup
	return nil
}

func (obj *GlobalTemplateGroup) GetParent(ctx context.Context) (result *GlobalTemplate, err error) {
	hashedName := helper.GetHashedName("templates.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["templates.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetTemplateByName(ctx, hashedName)
}

// GetAllDataTemplates returns all children of given type
func (obj *GlobalTemplateGroup) GetAllDataTemplates(ctx context.Context) (
	result []*GlobalDataTemplate, err error) {
	result = make([]*GlobalDataTemplate, 0, len(obj.Spec.DataTemplatesGvk))
	for _, v := range obj.Spec.DataTemplatesGvk {
		l, err := obj.client.Global().GetDataTemplateByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetDataTemplates returns child which has given displayName
func (obj *GlobalTemplateGroup) GetDataTemplates(ctx context.Context,
	displayName string) (result *GlobalDataTemplate, err error) {
	l, ok := obj.Spec.DataTemplatesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.TemplateGroup", "DataTemplates", displayName)
	}
	result, err = obj.client.Global().GetDataTemplateByName(ctx, l.Name)
	return
}

// AddDataTemplates calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalTemplateGroup) AddDataTemplates(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DataTemplate) (result *GlobalDataTemplate, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["templategroups.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["templategroups.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateDataTemplateByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetTemplateGroupByName(ctx, obj.GetName())
	if getErr == nil {
		obj.TemplateGroup = updatedObj.TemplateGroup
	}
	return
}

// DeleteDataTemplates calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalTemplateGroup) DeleteDataTemplates(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.DataTemplatesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.TemplateGroup", "DataTemplates", displayName)
	}
	err = obj.client.Global().DeleteDataTemplateByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetTemplateGroupByName(ctx, obj.GetName())
	if err == nil {
		obj.TemplateGroup = updatedObj.TemplateGroup
	}
	return
}

// GetAllNodeTemplates returns all children of given type
func (obj *GlobalTemplateGroup) GetAllNodeTemplates(ctx context.Context) (
	result []*GlobalNodeTemplate, err error) {
	result = make([]*GlobalNodeTemplate, 0, len(obj.Spec.NodeTemplatesGvk))
	for _, v := range obj.Spec.NodeTemplatesGvk {
		l, err := obj.client.Global().GetNodeTemplateByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetNodeTemplates returns child which has given displayName
func (obj *GlobalTemplateGroup) GetNodeTemplates(ctx context.Context,
	displayName string) (result *GlobalNodeTemplate, err error) {
	l, ok := obj.Spec.NodeTemplatesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.TemplateGroup", "NodeTemplates", displayName)
	}
	result, err = obj.client.Global().GetNodeTemplateByName(ctx, l.Name)
	return
}

// AddNodeTemplates calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalTemplateGroup) AddNodeTemplates(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NodeTemplate) (result *GlobalNodeTemplate, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["templategroups.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["templategroups.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateNodeTemplateByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetTemplateGroupByName(ctx, obj.GetName())
	if getErr == nil {
		obj.TemplateGroup = updatedObj.TemplateGroup
	}
	return
}

// DeleteNodeTemplates calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalTemplateGroup) DeleteNodeTemplates(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.NodeTemplatesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.TemplateGroup", "NodeTemplates", displayName)
	}
	err = obj.client.Global().DeleteNodeTemplateByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetTemplateGroupByName(ctx, obj.GetName())
	if err == nil {
		obj.TemplateGroup = updatedObj.TemplateGroup
	}
	return
}

// GetAllAppTemplates returns all children of given type
func (obj *GlobalTemplateGroup) GetAllAppTemplates(ctx context.Context) (
	result []*GlobalAppTemplate, err error) {
	result = make([]*GlobalAppTemplate, 0, len(obj.Spec.AppTemplatesGvk))
	for _, v := range obj.Spec.AppTemplatesGvk {
		l, err := obj.client.Global().GetAppTemplateByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetAppTemplates returns child which has given displayName
func (obj *GlobalTemplateGroup) GetAppTemplates(ctx context.Context,
	displayName string) (result *GlobalAppTemplate, err error) {
	l, ok := obj.Spec.AppTemplatesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.TemplateGroup", "AppTemplates", displayName)
	}
	result, err = obj.client.Global().GetAppTemplateByName(ctx, l.Name)
	return
}

// AddAppTemplates calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalTemplateGroup) AddAppTemplates(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AppTemplate) (result *GlobalAppTemplate, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["templategroups.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["templategroups.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateAppTemplateByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetTemplateGroupByName(ctx, obj.GetName())
	if getErr == nil {
		obj.TemplateGroup = updatedObj.TemplateGroup
	}
	return
}

// DeleteAppTemplates calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalTemplateGroup) DeleteAppTemplates(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.AppTemplatesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.TemplateGroup", "AppTemplates", displayName)
	}
	err = obj.client.Global().DeleteAppTemplateByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetTemplateGroupByName(ctx, obj.GetName())
	if err == nil {
		obj.TemplateGroup = updatedObj.TemplateGroup
	}
	return
}

// GetAllServiceTemplates returns all children of given type
func (obj *GlobalTemplateGroup) GetAllServiceTemplates(ctx context.Context) (
	result []*GlobalServiceTemplate, err error) {
	result = make([]*GlobalServiceTemplate, 0, len(obj.Spec.ServiceTemplatesGvk))
	for _, v := range obj.Spec.ServiceTemplatesGvk {
		l, err := obj.client.Global().GetServiceTemplateByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServiceTemplates returns child which has given displayName
func (obj *GlobalTemplateGroup) GetServiceTemplates(ctx context.Context,
	displayName string) (result *GlobalServiceTemplate, err error) {
	l, ok := obj.Spec.ServiceTemplatesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.TemplateGroup", "ServiceTemplates", displayName)
	}
	result, err = obj.client.Global().GetServiceTemplateByName(ctx, l.Name)
	return
}

// AddServiceTemplates calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalTemplateGroup) AddServiceTemplates(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceTemplate) (result *GlobalServiceTemplate, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["templategroups.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["templategroups.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateServiceTemplateByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetTemplateGroupByName(ctx, obj.GetName())
	if getErr == nil {
		obj.TemplateGroup = updatedObj.TemplateGroup
	}
	return
}

// DeleteServiceTemplates calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalTemplateGroup) DeleteServiceTemplates(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ServiceTemplatesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.TemplateGroup", "ServiceTemplates", displayName)
	}
	err = obj.client.Global().DeleteServiceTemplateByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetTemplateGroupByName(ctx, obj.GetName())
	if err == nil {
		obj.TemplateGroup = updatedObj.TemplateGroup
	}
	return
}

// GetAllPolicyTemplates returns all children of given type
func (obj *GlobalTemplateGroup) GetAllPolicyTemplates(ctx context.Context) (
	result []*GlobalPolicyTemplate, err error) {
	result = make([]*GlobalPolicyTemplate, 0, len(obj.Spec.PolicyTemplatesGvk))
	for _, v := range obj.Spec.PolicyTemplatesGvk {
		l, err := obj.client.Global().GetPolicyTemplateByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetPolicyTemplates returns child which has given displayName
func (obj *GlobalTemplateGroup) GetPolicyTemplates(ctx context.Context,
	displayName string) (result *GlobalPolicyTemplate, err error) {
	l, ok := obj.Spec.PolicyTemplatesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.TemplateGroup", "PolicyTemplates", displayName)
	}
	result, err = obj.client.Global().GetPolicyTemplateByName(ctx, l.Name)
	return
}

// AddPolicyTemplates calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalTemplateGroup) AddPolicyTemplates(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PolicyTemplate) (result *GlobalPolicyTemplate, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["templategroups.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["templategroups.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreatePolicyTemplateByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetTemplateGroupByName(ctx, obj.GetName())
	if getErr == nil {
		obj.TemplateGroup = updatedObj.TemplateGroup
	}
	return
}

// DeletePolicyTemplates calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalTemplateGroup) DeletePolicyTemplates(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.PolicyTemplatesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.TemplateGroup", "PolicyTemplates", displayName)
	}
	err = obj.client.Global().DeletePolicyTemplateByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetTemplateGroupByName(ctx, obj.GetName())
	if err == nil {
		obj.TemplateGroup = updatedObj.TemplateGroup
	}
	return
}

type templategroupGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *templategroupGlobalTsmV1Chainer) Subscribe() {
	key := "templategroups.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewTemplateGroupInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *templategroupGlobalTsmV1Chainer) Unsubscribe() {
	key := "templategroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *templategroupGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "templategroups.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *templategroupGlobalTsmV1Chainer) DataTemplates(name string) *datatemplateGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["datatemplates.global.tsm.tanzu.vmware.com"] = name
	return &datatemplateGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetDataTemplates calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *templategroupGlobalTsmV1Chainer) GetDataTemplates(ctx context.Context, displayName string) (result *GlobalDataTemplate, err error) {
	hashedName := helper.GetHashedName("datatemplates.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetDataTemplateByName(ctx, hashedName)
}

// AddDataTemplates calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *templategroupGlobalTsmV1Chainer) AddDataTemplates(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.DataTemplate) (result *GlobalDataTemplate, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("datatemplates.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateDataTemplateByName(ctx, objToCreate)
}

// DeleteDataTemplates calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *templategroupGlobalTsmV1Chainer) DeleteDataTemplates(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("datatemplates.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteDataTemplateByName(ctx, hashedName)
}

func (c *templategroupGlobalTsmV1Chainer) NodeTemplates(name string) *nodetemplateGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["nodetemplates.global.tsm.tanzu.vmware.com"] = name
	return &nodetemplateGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetNodeTemplates calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *templategroupGlobalTsmV1Chainer) GetNodeTemplates(ctx context.Context, displayName string) (result *GlobalNodeTemplate, err error) {
	hashedName := helper.GetHashedName("nodetemplates.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetNodeTemplateByName(ctx, hashedName)
}

// AddNodeTemplates calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *templategroupGlobalTsmV1Chainer) AddNodeTemplates(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.NodeTemplate) (result *GlobalNodeTemplate, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("nodetemplates.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateNodeTemplateByName(ctx, objToCreate)
}

// DeleteNodeTemplates calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *templategroupGlobalTsmV1Chainer) DeleteNodeTemplates(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("nodetemplates.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteNodeTemplateByName(ctx, hashedName)
}

func (c *templategroupGlobalTsmV1Chainer) AppTemplates(name string) *apptemplateGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["apptemplates.global.tsm.tanzu.vmware.com"] = name
	return &apptemplateGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetAppTemplates calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *templategroupGlobalTsmV1Chainer) GetAppTemplates(ctx context.Context, displayName string) (result *GlobalAppTemplate, err error) {
	hashedName := helper.GetHashedName("apptemplates.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetAppTemplateByName(ctx, hashedName)
}

// AddAppTemplates calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *templategroupGlobalTsmV1Chainer) AddAppTemplates(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AppTemplate) (result *GlobalAppTemplate, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("apptemplates.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateAppTemplateByName(ctx, objToCreate)
}

// DeleteAppTemplates calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *templategroupGlobalTsmV1Chainer) DeleteAppTemplates(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("apptemplates.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteAppTemplateByName(ctx, hashedName)
}

func (c *templategroupGlobalTsmV1Chainer) ServiceTemplates(name string) *servicetemplateGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["servicetemplates.global.tsm.tanzu.vmware.com"] = name
	return &servicetemplateGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetServiceTemplates calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *templategroupGlobalTsmV1Chainer) GetServiceTemplates(ctx context.Context, displayName string) (result *GlobalServiceTemplate, err error) {
	hashedName := helper.GetHashedName("servicetemplates.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetServiceTemplateByName(ctx, hashedName)
}

// AddServiceTemplates calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *templategroupGlobalTsmV1Chainer) AddServiceTemplates(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.ServiceTemplate) (result *GlobalServiceTemplate, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("servicetemplates.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateServiceTemplateByName(ctx, objToCreate)
}

// DeleteServiceTemplates calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *templategroupGlobalTsmV1Chainer) DeleteServiceTemplates(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("servicetemplates.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteServiceTemplateByName(ctx, hashedName)
}

func (c *templategroupGlobalTsmV1Chainer) PolicyTemplates(name string) *policytemplateGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["policytemplates.global.tsm.tanzu.vmware.com"] = name
	return &policytemplateGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetPolicyTemplates calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *templategroupGlobalTsmV1Chainer) GetPolicyTemplates(ctx context.Context, displayName string) (result *GlobalPolicyTemplate, err error) {
	hashedName := helper.GetHashedName("policytemplates.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetPolicyTemplateByName(ctx, hashedName)
}

// AddPolicyTemplates calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *templategroupGlobalTsmV1Chainer) AddPolicyTemplates(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.PolicyTemplate) (result *GlobalPolicyTemplate, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("policytemplates.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreatePolicyTemplateByName(ctx, objToCreate)
}

// DeletePolicyTemplates calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *templategroupGlobalTsmV1Chainer) DeletePolicyTemplates(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("policytemplates.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeletePolicyTemplateByName(ctx, hashedName)
}

// GetTemplateByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetTemplateByName(ctx context.Context, hashedName string) (*GlobalTemplate, error) {
	key := "templates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Template)
		return &GlobalTemplate{
			client:   group.client,
			Template: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Templates().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalTemplate{
			client:   group.client,
			Template: result,
		}, nil
	}
}

// DeleteTemplateByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteTemplateByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Templates().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.TemplateGroupsGvk {
		err := group.client.
			Global().DeleteTemplateGroupByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.HealthChecksGvk {
		err := group.client.
			Global().DeleteHealthCheckConfigNByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Templates().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/templatesGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateTemplateByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateTemplateByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Template) (*GlobalTemplate, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.TemplateGroupsGvk = nil
	objToCreate.Spec.HealthChecksGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Templates().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/templatesGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "Template",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalTemplate{
		client:   group.client,
		Template: result,
	}, nil
}

// UpdateTemplateByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateTemplateByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Template) (*GlobalTemplate, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Templates().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Templates().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalTemplate{
		client:   group.client,
		Template: result,
	}, nil
}

// ListTemplates returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListTemplates(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalTemplate, err error) {
	key := "templates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalTemplate, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Template)
			result[k] = &GlobalTemplate{
				client:   group.client,
				Template: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Templates().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalTemplate, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalTemplate{
				client:   group.client,
				Template: &item,
			}
		}
	}
	return
}

type GlobalTemplate struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Template
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalTemplate) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteTemplateByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Template = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalTemplate) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateTemplateByName(ctx, obj.Template)
	if err != nil {
		return err
	}
	obj.Template = result.Template
	return nil
}

func (obj *GlobalTemplate) GetParent(ctx context.Context) (result *GlobalConfig, err error) {
	hashedName := helper.GetHashedName("configs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetConfigByName(ctx, hashedName)
}

// GetAllTemplateGroups returns all children of given type
func (obj *GlobalTemplate) GetAllTemplateGroups(ctx context.Context) (
	result []*GlobalTemplateGroup, err error) {
	result = make([]*GlobalTemplateGroup, 0, len(obj.Spec.TemplateGroupsGvk))
	for _, v := range obj.Spec.TemplateGroupsGvk {
		l, err := obj.client.Global().GetTemplateGroupByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetTemplateGroups returns child which has given displayName
func (obj *GlobalTemplate) GetTemplateGroups(ctx context.Context,
	displayName string) (result *GlobalTemplateGroup, err error) {
	l, ok := obj.Spec.TemplateGroupsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Template", "TemplateGroups", displayName)
	}
	result, err = obj.client.Global().GetTemplateGroupByName(ctx, l.Name)
	return
}

// AddTemplateGroups calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalTemplate) AddTemplateGroups(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.TemplateGroup) (result *GlobalTemplateGroup, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["templates.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["templates.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateTemplateGroupByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetTemplateByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Template = updatedObj.Template
	}
	return
}

// DeleteTemplateGroups calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalTemplate) DeleteTemplateGroups(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.TemplateGroupsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Template", "TemplateGroups", displayName)
	}
	err = obj.client.Global().DeleteTemplateGroupByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetTemplateByName(ctx, obj.GetName())
	if err == nil {
		obj.Template = updatedObj.Template
	}
	return
}

// GetAllHealthChecks returns all children of given type
func (obj *GlobalTemplate) GetAllHealthChecks(ctx context.Context) (
	result []*GlobalHealthCheckConfigN, err error) {
	result = make([]*GlobalHealthCheckConfigN, 0, len(obj.Spec.HealthChecksGvk))
	for _, v := range obj.Spec.HealthChecksGvk {
		l, err := obj.client.Global().GetHealthCheckConfigNByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetHealthChecks returns child which has given displayName
func (obj *GlobalTemplate) GetHealthChecks(ctx context.Context,
	displayName string) (result *GlobalHealthCheckConfigN, err error) {
	l, ok := obj.Spec.HealthChecksGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Template", "HealthChecks", displayName)
	}
	result, err = obj.client.Global().GetHealthCheckConfigNByName(ctx, l.Name)
	return
}

// AddHealthChecks calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalTemplate) AddHealthChecks(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.HealthCheckConfigN) (result *GlobalHealthCheckConfigN, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["templates.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["templates.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateHealthCheckConfigNByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetTemplateByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Template = updatedObj.Template
	}
	return
}

// DeleteHealthChecks calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalTemplate) DeleteHealthChecks(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.HealthChecksGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Template", "HealthChecks", displayName)
	}
	err = obj.client.Global().DeleteHealthCheckConfigNByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetTemplateByName(ctx, obj.GetName())
	if err == nil {
		obj.Template = updatedObj.Template
	}
	return
}

type templateGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *templateGlobalTsmV1Chainer) Subscribe() {
	key := "templates.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewTemplateInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *templateGlobalTsmV1Chainer) Unsubscribe() {
	key := "templates.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *templateGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "templates.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *templateGlobalTsmV1Chainer) TemplateGroups(name string) *templategroupGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["templategroups.global.tsm.tanzu.vmware.com"] = name
	return &templategroupGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetTemplateGroups calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *templateGlobalTsmV1Chainer) GetTemplateGroups(ctx context.Context, displayName string) (result *GlobalTemplateGroup, err error) {
	hashedName := helper.GetHashedName("templategroups.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetTemplateGroupByName(ctx, hashedName)
}

// AddTemplateGroups calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *templateGlobalTsmV1Chainer) AddTemplateGroups(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.TemplateGroup) (result *GlobalTemplateGroup, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("templategroups.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateTemplateGroupByName(ctx, objToCreate)
}

// DeleteTemplateGroups calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *templateGlobalTsmV1Chainer) DeleteTemplateGroups(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("templategroups.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteTemplateGroupByName(ctx, hashedName)
}

func (c *templateGlobalTsmV1Chainer) HealthChecks(name string) *healthcheckconfignGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["healthcheckconfigns.global.tsm.tanzu.vmware.com"] = name
	return &healthcheckconfignGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetHealthChecks calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *templateGlobalTsmV1Chainer) GetHealthChecks(ctx context.Context, displayName string) (result *GlobalHealthCheckConfigN, err error) {
	hashedName := helper.GetHashedName("healthcheckconfigns.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetHealthCheckConfigNByName(ctx, hashedName)
}

// AddHealthChecks calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *templateGlobalTsmV1Chainer) AddHealthChecks(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.HealthCheckConfigN) (result *GlobalHealthCheckConfigN, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("healthcheckconfigns.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateHealthCheckConfigNByName(ctx, objToCreate)
}

// DeleteHealthChecks calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *templateGlobalTsmV1Chainer) DeleteHealthChecks(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("healthcheckconfigns.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteHealthCheckConfigNByName(ctx, hashedName)
}

// GetTenantResourceByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetTenantResourceByName(ctx context.Context, hashedName string) (*GlobalTenantResource, error) {
	key := "tenantresources.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.TenantResource)
		return &GlobalTenantResource{
			client:         group.client,
			TenantResource: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			TenantResources().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalTenantResource{
			client:         group.client,
			TenantResource: result,
		}, nil
	}
}

// DeleteTenantResourceByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteTenantResourceByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		TenantResources().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		TenantResources().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/resourcesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["tenants.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("tenants.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Tenants().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateTenantResourceByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateTenantResourceByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.TenantResource) (*GlobalTenantResource, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		TenantResources().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["tenants.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("tenants.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"resourcesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"TenantResource\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Tenants().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalTenantResource{
		client:         group.client,
		TenantResource: result,
	}, nil
}

// UpdateTenantResourceByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateTenantResourceByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.TenantResource) (*GlobalTenantResource, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			TenantResources().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueType :=
		objToUpdate.Spec.Type
	patchOpType := PatchOp{
		Op:    "replace",
		Path:  "/spec/type",
		Value: patchValueType,
	}
	patch = append(patch, patchOpType)

	patchValueLocation :=
		objToUpdate.Spec.Location
	patchOpLocation := PatchOp{
		Op:    "replace",
		Path:  "/spec/location",
		Value: patchValueLocation,
	}
	patch = append(patch, patchOpLocation)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		TenantResources().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalTenantResource{
		client:         group.client,
		TenantResource: result,
	}, nil
}

// ListTenantResources returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListTenantResources(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalTenantResource, err error) {
	key := "tenantresources.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalTenantResource, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.TenantResource)
			result[k] = &GlobalTenantResource{
				client:         group.client,
				TenantResource: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			TenantResources().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalTenantResource, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalTenantResource{
				client:         group.client,
				TenantResource: &item,
			}
		}
	}
	return
}

type GlobalTenantResource struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.TenantResource
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalTenantResource) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteTenantResourceByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.TenantResource = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalTenantResource) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateTenantResourceByName(ctx, obj.TenantResource)
	if err != nil {
		return err
	}
	obj.TenantResource = result.TenantResource
	return nil
}

func (obj *GlobalTenantResource) GetParent(ctx context.Context) (result *GlobalTenant, err error) {
	hashedName := helper.GetHashedName("tenants.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["tenants.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetTenantByName(ctx, hashedName)
}

type tenantresourceGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *tenantresourceGlobalTsmV1Chainer) Subscribe() {
	key := "tenantresources.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewTenantResourceInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *tenantresourceGlobalTsmV1Chainer) Unsubscribe() {
	key := "tenantresources.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *tenantresourceGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "tenantresources.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetTenantTokenByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetTenantTokenByName(ctx context.Context, hashedName string) (*GlobalTenantToken, error) {
	key := "tenanttokens.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.TenantToken)
		return &GlobalTenantToken{
			client:      group.client,
			TenantToken: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			TenantTokens().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalTenantToken{
			client:      group.client,
			TenantToken: result,
		}, nil
	}
}

// DeleteTenantTokenByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteTenantTokenByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		TenantTokens().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		TenantTokens().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/tenantTokenGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["globalregistrationservices.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("globalregistrationservices.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GlobalRegistrationServices().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateTenantTokenByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateTenantTokenByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.TenantToken) (*GlobalTenantToken, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		TenantTokens().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["globalregistrationservices.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("globalregistrationservices.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"tenantTokenGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"TenantToken\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GlobalRegistrationServices().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalTenantToken{
		client:      group.client,
		TenantToken: result,
	}, nil
}

// UpdateTenantTokenByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateTenantTokenByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.TenantToken) (*GlobalTenantToken, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			TenantTokens().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueTtl :=
		objToUpdate.Spec.Ttl
	patchOpTtl := PatchOp{
		Op:    "replace",
		Path:  "/spec/ttl",
		Value: patchValueTtl,
	}
	patch = append(patch, patchOpTtl)

	patchValueCreated :=
		objToUpdate.Spec.Created
	patchOpCreated := PatchOp{
		Op:    "replace",
		Path:  "/spec/created",
		Value: patchValueCreated,
	}
	patch = append(patch, patchOpCreated)

	patchValueTenantId :=
		objToUpdate.Spec.TenantId
	patchOpTenantId := PatchOp{
		Op:    "replace",
		Path:  "/spec/tenantId",
		Value: patchValueTenantId,
	}
	patch = append(patch, patchOpTenantId)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		TenantTokens().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalTenantToken{
		client:      group.client,
		TenantToken: result,
	}, nil
}

// ListTenantTokens returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListTenantTokens(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalTenantToken, err error) {
	key := "tenanttokens.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalTenantToken, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.TenantToken)
			result[k] = &GlobalTenantToken{
				client:      group.client,
				TenantToken: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			TenantTokens().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalTenantToken, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalTenantToken{
				client:      group.client,
				TenantToken: &item,
			}
		}
	}
	return
}

type GlobalTenantToken struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.TenantToken
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalTenantToken) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteTenantTokenByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.TenantToken = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalTenantToken) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateTenantTokenByName(ctx, obj.TenantToken)
	if err != nil {
		return err
	}
	obj.TenantToken = result.TenantToken
	return nil
}

func (obj *GlobalTenantToken) GetParent(ctx context.Context) (result *GlobalGlobalRegistrationService, err error) {
	hashedName := helper.GetHashedName("globalregistrationservices.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["globalregistrationservices.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGlobalRegistrationServiceByName(ctx, hashedName)
}

type tenanttokenGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *tenanttokenGlobalTsmV1Chainer) Subscribe() {
	key := "tenanttokens.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewTenantTokenInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *tenanttokenGlobalTsmV1Chainer) Unsubscribe() {
	key := "tenanttokens.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *tenanttokenGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "tenanttokens.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetTenantByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetTenantByName(ctx context.Context, hashedName string) (*GlobalTenant, error) {
	key := "tenants.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.Tenant)
		return &GlobalTenant{
			client: group.client,
			Tenant: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Tenants().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalTenant{
			client: group.client,
			Tenant: result,
		}, nil
	}
}

// DeleteTenantByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteTenantByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Tenants().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.ResourcesGvk {
		err := group.client.
			Global().DeleteTenantResourceByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.AnnotationsGvk {
		err := group.client.
			Global().DeleteAnnotationByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Tenants().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/tenantsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["globalregistrationservices.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("globalregistrationservices.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GlobalRegistrationServices().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateTenantByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateTenantByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Tenant) (*GlobalTenant, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ResourcesGvk = nil
	objToCreate.Spec.AnnotationsGvk = nil
	objToCreate.Spec.TemplateGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Tenants().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["globalregistrationservices.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("globalregistrationservices.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"tenantsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"Tenant\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GlobalRegistrationServices().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalTenant{
		client: group.client,
		Tenant: result,
	}, nil
}

// UpdateTenantByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateTenantByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.Tenant) (*GlobalTenant, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Tenants().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueTenantName :=
		objToUpdate.Spec.TenantName
	patchOpTenantName := PatchOp{
		Op:    "replace",
		Path:  "/spec/tenantName",
		Value: patchValueTenantName,
	}
	patch = append(patch, patchOpTenantName)

	patchValueContactEmail :=
		objToUpdate.Spec.ContactEmail
	patchOpContactEmail := PatchOp{
		Op:    "replace",
		Path:  "/spec/contactEmail",
		Value: patchValueContactEmail,
	}
	patch = append(patch, patchOpContactEmail)

	patchValueYaml :=
		objToUpdate.Spec.Yaml
	patchOpYaml := PatchOp{
		Op:    "replace",
		Path:  "/spec/yaml",
		Value: patchValueYaml,
	}
	patch = append(patch, patchOpYaml)

	patchValueLb :=
		objToUpdate.Spec.Lb
	patchOpLb := PatchOp{
		Op:    "replace",
		Path:  "/spec/lb",
		Value: patchValueLb,
	}
	patch = append(patch, patchOpLb)

	patchValueCompanySize :=
		objToUpdate.Spec.CompanySize
	patchOpCompanySize := PatchOp{
		Op:    "replace",
		Path:  "/spec/companySize",
		Value: patchValueCompanySize,
	}
	patch = append(patch, patchOpCompanySize)

	patchValueAddress :=
		objToUpdate.Spec.Address
	patchOpAddress := PatchOp{
		Op:    "replace",
		Path:  "/spec/address",
		Value: patchValueAddress,
	}
	patch = append(patch, patchOpAddress)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Tenants().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalTenant{
		client: group.client,
		Tenant: result,
	}, nil
}

// ListTenants returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListTenants(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalTenant, err error) {
	key := "tenants.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalTenant, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.Tenant)
			result[k] = &GlobalTenant{
				client: group.client,
				Tenant: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Tenants().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalTenant, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalTenant{
				client: group.client,
				Tenant: &item,
			}
		}
	}
	return
}

type GlobalTenant struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.Tenant
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalTenant) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteTenantByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Tenant = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalTenant) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateTenantByName(ctx, obj.Tenant)
	if err != nil {
		return err
	}
	obj.Tenant = result.Tenant
	return nil
}

func (obj *GlobalTenant) GetParent(ctx context.Context) (result *GlobalGlobalRegistrationService, err error) {
	hashedName := helper.GetHashedName("globalregistrationservices.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["globalregistrationservices.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGlobalRegistrationServiceByName(ctx, hashedName)
}

// GetAllResources returns all children of given type
func (obj *GlobalTenant) GetAllResources(ctx context.Context) (
	result []*GlobalTenantResource, err error) {
	result = make([]*GlobalTenantResource, 0, len(obj.Spec.ResourcesGvk))
	for _, v := range obj.Spec.ResourcesGvk {
		l, err := obj.client.Global().GetTenantResourceByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetResources returns child which has given displayName
func (obj *GlobalTenant) GetResources(ctx context.Context,
	displayName string) (result *GlobalTenantResource, err error) {
	l, ok := obj.Spec.ResourcesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Tenant", "Resources", displayName)
	}
	result, err = obj.client.Global().GetTenantResourceByName(ctx, l.Name)
	return
}

// AddResources calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalTenant) AddResources(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.TenantResource) (result *GlobalTenantResource, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["tenants.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["tenants.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateTenantResourceByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetTenantByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Tenant = updatedObj.Tenant
	}
	return
}

// DeleteResources calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalTenant) DeleteResources(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.ResourcesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Tenant", "Resources", displayName)
	}
	err = obj.client.Global().DeleteTenantResourceByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetTenantByName(ctx, obj.GetName())
	if err == nil {
		obj.Tenant = updatedObj.Tenant
	}
	return
}

// GetAllAnnotations returns all children of given type
func (obj *GlobalTenant) GetAllAnnotations(ctx context.Context) (
	result []*GlobalAnnotation, err error) {
	result = make([]*GlobalAnnotation, 0, len(obj.Spec.AnnotationsGvk))
	for _, v := range obj.Spec.AnnotationsGvk {
		l, err := obj.client.Global().GetAnnotationByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetAnnotations returns child which has given displayName
func (obj *GlobalTenant) GetAnnotations(ctx context.Context,
	displayName string) (result *GlobalAnnotation, err error) {
	l, ok := obj.Spec.AnnotationsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.Tenant", "Annotations", displayName)
	}
	result, err = obj.client.Global().GetAnnotationByName(ctx, l.Name)
	return
}

// AddAnnotations calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalTenant) AddAnnotations(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Annotation) (result *GlobalAnnotation, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["tenants.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["tenants.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateAnnotationByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetTenantByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Tenant = updatedObj.Tenant
	}
	return
}

// DeleteAnnotations calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalTenant) DeleteAnnotations(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.AnnotationsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.Tenant", "Annotations", displayName)
	}
	err = obj.client.Global().DeleteAnnotationByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetTenantByName(ctx, obj.GetName())
	if err == nil {
		obj.Tenant = updatedObj.Tenant
	}
	return
}

// GetTemplate returns link of given type
func (obj *GlobalTenant) GetTemplate(ctx context.Context) (
	result *GlobalServiceTemplate, err error) {
	if obj.Spec.TemplateGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.Tenant", "Template")
	}
	return obj.client.Global().GetServiceTemplateByName(ctx, obj.Spec.TemplateGvk.Name)
}

// LinkTemplate links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalTenant) LinkTemplate(ctx context.Context,
	linkToAdd *GlobalServiceTemplate) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/templateGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "ServiceTemplate",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Tenants().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Tenant = result
	return nil
}

// UnlinkTemplate unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalTenant) UnlinkTemplate(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/templateGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().Tenants().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Tenant = result
	return nil

}

type tenantGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *tenantGlobalTsmV1Chainer) Subscribe() {
	key := "tenants.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewTenantInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *tenantGlobalTsmV1Chainer) Unsubscribe() {
	key := "tenants.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *tenantGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "tenants.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *tenantGlobalTsmV1Chainer) Resources(name string) *tenantresourceGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["tenantresources.global.tsm.tanzu.vmware.com"] = name
	return &tenantresourceGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetResources calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *tenantGlobalTsmV1Chainer) GetResources(ctx context.Context, displayName string) (result *GlobalTenantResource, err error) {
	hashedName := helper.GetHashedName("tenantresources.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetTenantResourceByName(ctx, hashedName)
}

// AddResources calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *tenantGlobalTsmV1Chainer) AddResources(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.TenantResource) (result *GlobalTenantResource, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("tenantresources.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateTenantResourceByName(ctx, objToCreate)
}

// DeleteResources calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *tenantGlobalTsmV1Chainer) DeleteResources(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("tenantresources.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteTenantResourceByName(ctx, hashedName)
}

func (c *tenantGlobalTsmV1Chainer) Annotations(name string) *annotationGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["annotations.global.tsm.tanzu.vmware.com"] = name
	return &annotationGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetAnnotations calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *tenantGlobalTsmV1Chainer) GetAnnotations(ctx context.Context, displayName string) (result *GlobalAnnotation, err error) {
	hashedName := helper.GetHashedName("annotations.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetAnnotationByName(ctx, hashedName)
}

// AddAnnotations calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *tenantGlobalTsmV1Chainer) AddAnnotations(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.Annotation) (result *GlobalAnnotation, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("annotations.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateAnnotationByName(ctx, objToCreate)
}

// DeleteAnnotations calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *tenantGlobalTsmV1Chainer) DeleteAnnotations(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("annotations.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteAnnotationByName(ctx, hashedName)
}

// GetUserDiscoveryRTByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetUserDiscoveryRTByName(ctx context.Context, hashedName string) (*GlobalUserDiscoveryRT, error) {
	key := "userdiscoveryrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.UserDiscoveryRT)
		return &GlobalUserDiscoveryRT{
			client:          group.client,
			UserDiscoveryRT: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			UserDiscoveryRTs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalUserDiscoveryRT{
			client:          group.client,
			UserDiscoveryRT: result,
		}, nil
	}
}

// DeleteUserDiscoveryRTByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteUserDiscoveryRTByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		UserDiscoveryRTs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		UserDiscoveryRTs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/userDiscoveryGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateUserDiscoveryRTByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateUserDiscoveryRTByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.UserDiscoveryRT) (*GlobalUserDiscoveryRT, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		UserDiscoveryRTs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domainconfigs.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"userDiscoveryGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"UserDiscoveryRT\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		DomainConfigs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalUserDiscoveryRT{
		client:          group.client,
		UserDiscoveryRT: result,
	}, nil
}

// UpdateUserDiscoveryRTByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateUserDiscoveryRTByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.UserDiscoveryRT) (*GlobalUserDiscoveryRT, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			UserDiscoveryRTs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueGnsid :=
		objToUpdate.Spec.Gnsid
	patchOpGnsid := PatchOp{
		Op:    "replace",
		Path:  "/spec/gnsid",
		Value: patchValueGnsid,
	}
	patch = append(patch, patchOpGnsid)

	patchValueSelectors :=
		objToUpdate.Spec.Selectors
	patchOpSelectors := PatchOp{
		Op:    "replace",
		Path:  "/spec/selectors",
		Value: patchValueSelectors,
	}
	patch = append(patch, patchOpSelectors)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		UserDiscoveryRTs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalUserDiscoveryRT{
		client:          group.client,
		UserDiscoveryRT: result,
	}, nil
}

// ListUserDiscoveryRTs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListUserDiscoveryRTs(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalUserDiscoveryRT, err error) {
	key := "userdiscoveryrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalUserDiscoveryRT, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.UserDiscoveryRT)
			result[k] = &GlobalUserDiscoveryRT{
				client:          group.client,
				UserDiscoveryRT: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			UserDiscoveryRTs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalUserDiscoveryRT, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalUserDiscoveryRT{
				client:          group.client,
				UserDiscoveryRT: &item,
			}
		}
	}
	return
}

type GlobalUserDiscoveryRT struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.UserDiscoveryRT
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalUserDiscoveryRT) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteUserDiscoveryRTByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.UserDiscoveryRT = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalUserDiscoveryRT) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateUserDiscoveryRTByName(ctx, obj.UserDiscoveryRT)
	if err != nil {
		return err
	}
	obj.UserDiscoveryRT = result.UserDiscoveryRT
	return nil
}

func (obj *GlobalUserDiscoveryRT) GetParent(ctx context.Context) (result *GlobalDomainConfig, err error) {
	hashedName := helper.GetHashedName("domainconfigs.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domainconfigs.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainConfigByName(ctx, hashedName)
}

type userdiscoveryrtGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *userdiscoveryrtGlobalTsmV1Chainer) Subscribe() {
	key := "userdiscoveryrts.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewUserDiscoveryRTInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *userdiscoveryrtGlobalTsmV1Chainer) Unsubscribe() {
	key := "userdiscoveryrts.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *userdiscoveryrtGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "userdiscoveryrts.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetUserDiscoveryByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetUserDiscoveryByName(ctx context.Context, hashedName string) (*GlobalUserDiscovery, error) {
	key := "userdiscoveries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.UserDiscovery)
		return &GlobalUserDiscovery{
			client:        group.client,
			UserDiscovery: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			UserDiscoveries().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalUserDiscovery{
			client:        group.client,
			UserDiscovery: result,
		}, nil
	}
}

// DeleteUserDiscoveryByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteUserDiscoveryByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		UserDiscoveries().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		UserDiscoveries().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/userDiscoveryGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateUserDiscoveryByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateUserDiscoveryByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.UserDiscovery) (*GlobalUserDiscovery, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		UserDiscoveries().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnss.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"userDiscoveryGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"UserDiscovery\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		GNSs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalUserDiscovery{
		client:        group.client,
		UserDiscovery: result,
	}, nil
}

// UpdateUserDiscoveryByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateUserDiscoveryByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.UserDiscovery) (*GlobalUserDiscovery, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			UserDiscoveries().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueSpec :=
		objToUpdate.Spec.Spec
	patchOpSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/spec",
		Value: patchValueSpec,
	}
	patch = append(patch, patchOpSpec)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		UserDiscoveries().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalUserDiscovery{
		client:        group.client,
		UserDiscovery: result,
	}, nil
}

// ListUserDiscoveries returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListUserDiscoveries(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalUserDiscovery, err error) {
	key := "userdiscoveries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalUserDiscovery, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.UserDiscovery)
			result[k] = &GlobalUserDiscovery{
				client:        group.client,
				UserDiscovery: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			UserDiscoveries().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalUserDiscovery, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalUserDiscovery{
				client:        group.client,
				UserDiscovery: &item,
			}
		}
	}
	return
}

type GlobalUserDiscovery struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.UserDiscovery
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalUserDiscovery) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteUserDiscoveryByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.UserDiscovery = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalUserDiscovery) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateUserDiscoveryByName(ctx, obj.UserDiscovery)
	if err != nil {
		return err
	}
	obj.UserDiscovery = result.UserDiscovery
	return nil
}

func (obj *GlobalUserDiscovery) GetParent(ctx context.Context) (result *GlobalGNS, err error) {
	hashedName := helper.GetHashedName("gnss.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnss.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetGNSByName(ctx, hashedName)
}

type userdiscoveryGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *userdiscoveryGlobalTsmV1Chainer) Subscribe() {
	key := "userdiscoveries.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewUserDiscoveryInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *userdiscoveryGlobalTsmV1Chainer) Unsubscribe() {
	key := "userdiscoveries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *userdiscoveryGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "userdiscoveries.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetUserFolderByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetUserFolderByName(ctx context.Context, hashedName string) (*GlobalUserFolder, error) {
	key := "userfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.UserFolder)
		return &GlobalUserFolder{
			client:     group.client,
			UserFolder: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			UserFolders().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalUserFolder{
			client:     group.client,
			UserFolder: result,
		}, nil
	}
}

// DeleteUserFolderByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteUserFolderByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		UserFolders().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.UsersGvk {
		err := group.client.
			Global().DeleteUserByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.AppUsersGvk {
		err := group.client.
			Global().DeleteAppUserByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.AccessTokenGvk {
		err := group.client.
			Global().DeleteAccessTokenByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		UserFolders().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/userFolderGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["runtimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateUserFolderByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateUserFolderByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.UserFolder) (*GlobalUserFolder, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.UsersGvk = nil
	objToCreate.Spec.AppUsersGvk = nil
	objToCreate.Spec.AccessTokenGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		UserFolders().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["runtimes.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/userFolderGvk",
		Value: baseglobaltsmtanzuvmwarecomv1.Child{
			Group: "global.tsm.tanzu.vmware.com",
			Kind:  "UserFolder",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Runtimes().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalUserFolder{
		client:     group.client,
		UserFolder: result,
	}, nil
}

// UpdateUserFolderByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateUserFolderByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.UserFolder) (*GlobalUserFolder, error) {
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			UserFolders().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		UserFolders().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalUserFolder{
		client:     group.client,
		UserFolder: result,
	}, nil
}

// ListUserFolders returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListUserFolders(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalUserFolder, err error) {
	key := "userfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalUserFolder, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.UserFolder)
			result[k] = &GlobalUserFolder{
				client:     group.client,
				UserFolder: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			UserFolders().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalUserFolder, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalUserFolder{
				client:     group.client,
				UserFolder: &item,
			}
		}
	}
	return
}

type GlobalUserFolder struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.UserFolder
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalUserFolder) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteUserFolderByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.UserFolder = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalUserFolder) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateUserFolderByName(ctx, obj.UserFolder)
	if err != nil {
		return err
	}
	obj.UserFolder = result.UserFolder
	return nil
}

func (obj *GlobalUserFolder) GetParent(ctx context.Context) (result *GlobalRuntime, err error) {
	hashedName := helper.GetHashedName("runtimes.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["runtimes.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetRuntimeByName(ctx, hashedName)
}

// GetAllUsers returns all children of given type
func (obj *GlobalUserFolder) GetAllUsers(ctx context.Context) (
	result []*GlobalUser, err error) {
	result = make([]*GlobalUser, 0, len(obj.Spec.UsersGvk))
	for _, v := range obj.Spec.UsersGvk {
		l, err := obj.client.Global().GetUserByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetUsers returns child which has given displayName
func (obj *GlobalUserFolder) GetUsers(ctx context.Context,
	displayName string) (result *GlobalUser, err error) {
	l, ok := obj.Spec.UsersGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.UserFolder", "Users", displayName)
	}
	result, err = obj.client.Global().GetUserByName(ctx, l.Name)
	return
}

// AddUsers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalUserFolder) AddUsers(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.User) (result *GlobalUser, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["userfolders.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["userfolders.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateUserByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetUserFolderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.UserFolder = updatedObj.UserFolder
	}
	return
}

// DeleteUsers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalUserFolder) DeleteUsers(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.UsersGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.UserFolder", "Users", displayName)
	}
	err = obj.client.Global().DeleteUserByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetUserFolderByName(ctx, obj.GetName())
	if err == nil {
		obj.UserFolder = updatedObj.UserFolder
	}
	return
}

// GetAllAppUsers returns all children of given type
func (obj *GlobalUserFolder) GetAllAppUsers(ctx context.Context) (
	result []*GlobalAppUser, err error) {
	result = make([]*GlobalAppUser, 0, len(obj.Spec.AppUsersGvk))
	for _, v := range obj.Spec.AppUsersGvk {
		l, err := obj.client.Global().GetAppUserByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetAppUsers returns child which has given displayName
func (obj *GlobalUserFolder) GetAppUsers(ctx context.Context,
	displayName string) (result *GlobalAppUser, err error) {
	l, ok := obj.Spec.AppUsersGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.UserFolder", "AppUsers", displayName)
	}
	result, err = obj.client.Global().GetAppUserByName(ctx, l.Name)
	return
}

// AddAppUsers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalUserFolder) AddAppUsers(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AppUser) (result *GlobalAppUser, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["userfolders.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["userfolders.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateAppUserByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetUserFolderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.UserFolder = updatedObj.UserFolder
	}
	return
}

// DeleteAppUsers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalUserFolder) DeleteAppUsers(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.AppUsersGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.UserFolder", "AppUsers", displayName)
	}
	err = obj.client.Global().DeleteAppUserByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetUserFolderByName(ctx, obj.GetName())
	if err == nil {
		obj.UserFolder = updatedObj.UserFolder
	}
	return
}

// GetAllAccessToken returns all children of given type
func (obj *GlobalUserFolder) GetAllAccessToken(ctx context.Context) (
	result []*GlobalAccessToken, err error) {
	result = make([]*GlobalAccessToken, 0, len(obj.Spec.AccessTokenGvk))
	for _, v := range obj.Spec.AccessTokenGvk {
		l, err := obj.client.Global().GetAccessTokenByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetAccessToken returns child which has given displayName
func (obj *GlobalUserFolder) GetAccessToken(ctx context.Context,
	displayName string) (result *GlobalAccessToken, err error) {
	l, ok := obj.Spec.AccessTokenGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.UserFolder", "AccessToken", displayName)
	}
	result, err = obj.client.Global().GetAccessTokenByName(ctx, l.Name)
	return
}

// AddAccessToken calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalUserFolder) AddAccessToken(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AccessToken) (result *GlobalAccessToken, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["userfolders.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["userfolders.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateAccessTokenByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetUserFolderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.UserFolder = updatedObj.UserFolder
	}
	return
}

// DeleteAccessToken calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalUserFolder) DeleteAccessToken(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.AccessTokenGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.UserFolder", "AccessToken", displayName)
	}
	err = obj.client.Global().DeleteAccessTokenByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetUserFolderByName(ctx, obj.GetName())
	if err == nil {
		obj.UserFolder = updatedObj.UserFolder
	}
	return
}

type userfolderGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *userfolderGlobalTsmV1Chainer) Subscribe() {
	key := "userfolders.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewUserFolderInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *userfolderGlobalTsmV1Chainer) Unsubscribe() {
	key := "userfolders.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *userfolderGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "userfolders.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *userfolderGlobalTsmV1Chainer) Users(name string) *userGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["users.global.tsm.tanzu.vmware.com"] = name
	return &userGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetUsers calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *userfolderGlobalTsmV1Chainer) GetUsers(ctx context.Context, displayName string) (result *GlobalUser, err error) {
	hashedName := helper.GetHashedName("users.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetUserByName(ctx, hashedName)
}

// AddUsers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *userfolderGlobalTsmV1Chainer) AddUsers(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.User) (result *GlobalUser, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("users.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateUserByName(ctx, objToCreate)
}

// DeleteUsers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *userfolderGlobalTsmV1Chainer) DeleteUsers(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("users.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteUserByName(ctx, hashedName)
}

func (c *userfolderGlobalTsmV1Chainer) AppUsers(name string) *appuserGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["appusers.global.tsm.tanzu.vmware.com"] = name
	return &appuserGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetAppUsers calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *userfolderGlobalTsmV1Chainer) GetAppUsers(ctx context.Context, displayName string) (result *GlobalAppUser, err error) {
	hashedName := helper.GetHashedName("appusers.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetAppUserByName(ctx, hashedName)
}

// AddAppUsers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *userfolderGlobalTsmV1Chainer) AddAppUsers(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AppUser) (result *GlobalAppUser, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("appusers.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateAppUserByName(ctx, objToCreate)
}

// DeleteAppUsers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *userfolderGlobalTsmV1Chainer) DeleteAppUsers(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("appusers.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteAppUserByName(ctx, hashedName)
}

func (c *userfolderGlobalTsmV1Chainer) AccessToken(name string) *accesstokenGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["accesstokens.global.tsm.tanzu.vmware.com"] = name
	return &accesstokenGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetAccessToken calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *userfolderGlobalTsmV1Chainer) GetAccessToken(ctx context.Context, displayName string) (result *GlobalAccessToken, err error) {
	hashedName := helper.GetHashedName("accesstokens.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetAccessTokenByName(ctx, hashedName)
}

// AddAccessToken calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *userfolderGlobalTsmV1Chainer) AddAccessToken(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.AccessToken) (result *GlobalAccessToken, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("accesstokens.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateAccessTokenByName(ctx, objToCreate)
}

// DeleteAccessToken calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *userfolderGlobalTsmV1Chainer) DeleteAccessToken(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("accesstokens.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteAccessTokenByName(ctx, hashedName)
}

// GetUserGroupByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetUserGroupByName(ctx context.Context, hashedName string) (*GlobalUserGroup, error) {
	key := "usergroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.UserGroup)
		return &GlobalUserGroup{
			client:    group.client,
			UserGroup: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			UserGroups().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalUserGroup{
			client:    group.client,
			UserGroup: result,
		}, nil
	}
}

// DeleteUserGroupByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteUserGroupByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		UserGroups().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		UserGroups().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/userGroupsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["resourcegroups.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("resourcegroups.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ResourceGroups().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateUserGroupByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateUserGroupByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.UserGroup) (*GlobalUserGroup, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		UserGroups().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["resourcegroups.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("resourcegroups.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"userGroupsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"UserGroup\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		ResourceGroups().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalUserGroup{
		client:    group.client,
		UserGroup: result,
	}, nil
}

// UpdateUserGroupByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateUserGroupByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.UserGroup) (*GlobalUserGroup, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			UserGroups().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDisplayName :=
		objToUpdate.Spec.DisplayName
	patchOpDisplayName := PatchOp{
		Op:    "replace",
		Path:  "/spec/displayName",
		Value: patchValueDisplayName,
	}
	patch = append(patch, patchOpDisplayName)

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueScope :=
		objToUpdate.Spec.Scope
	patchOpScope := PatchOp{
		Op:    "replace",
		Path:  "/spec/scope",
		Value: patchValueScope,
	}
	patch = append(patch, patchOpScope)

	patchValueColor :=
		objToUpdate.Spec.Color
	patchOpColor := PatchOp{
		Op:    "replace",
		Path:  "/spec/color",
		Value: patchValueColor,
	}
	patch = append(patch, patchOpColor)

	patchValueRules :=
		objToUpdate.Spec.Rules
	patchOpRules := PatchOp{
		Op:    "replace",
		Path:  "/spec/rules",
		Value: patchValueRules,
	}
	patch = append(patch, patchOpRules)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		UserGroups().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalUserGroup{
		client:    group.client,
		UserGroup: result,
	}, nil
}

// ListUserGroups returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListUserGroups(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalUserGroup, err error) {
	key := "usergroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalUserGroup, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.UserGroup)
			result[k] = &GlobalUserGroup{
				client:    group.client,
				UserGroup: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			UserGroups().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalUserGroup, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalUserGroup{
				client:    group.client,
				UserGroup: &item,
			}
		}
	}
	return
}

type GlobalUserGroup struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.UserGroup
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalUserGroup) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteUserGroupByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.UserGroup = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalUserGroup) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateUserGroupByName(ctx, obj.UserGroup)
	if err != nil {
		return err
	}
	obj.UserGroup = result.UserGroup
	return nil
}

func (obj *GlobalUserGroup) GetParent(ctx context.Context) (result *GlobalResourceGroup, err error) {
	hashedName := helper.GetHashedName("resourcegroups.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["resourcegroups.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetResourceGroupByName(ctx, hashedName)
}

type usergroupGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *usergroupGlobalTsmV1Chainer) Subscribe() {
	key := "usergroups.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewUserGroupInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *usergroupGlobalTsmV1Chainer) Unsubscribe() {
	key := "usergroups.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *usergroupGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "usergroups.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetUserPreferenceByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetUserPreferenceByName(ctx context.Context, hashedName string) (*GlobalUserPreference, error) {
	key := "userpreferences.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.UserPreference)
		return &GlobalUserPreference{
			client:         group.client,
			UserPreference: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			UserPreferences().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalUserPreference{
			client:         group.client,
			UserPreference: result,
		}, nil
	}
}

// DeleteUserPreferenceByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteUserPreferenceByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		UserPreferences().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		UserPreferences().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/preferencesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["users.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("users.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Users().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateUserPreferenceByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateUserPreferenceByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.UserPreference) (*GlobalUserPreference, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		UserPreferences().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["users.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("users.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"preferencesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"UserPreference\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Users().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalUserPreference{
		client:         group.client,
		UserPreference: result,
	}, nil
}

// UpdateUserPreferenceByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateUserPreferenceByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.UserPreference) (*GlobalUserPreference, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			UserPreferences().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueData :=
		objToUpdate.Spec.Data
	patchOpData := PatchOp{
		Op:    "replace",
		Path:  "/spec/data",
		Value: patchValueData,
	}
	patch = append(patch, patchOpData)

	patchValueUserId :=
		objToUpdate.Spec.UserId
	patchOpUserId := PatchOp{
		Op:    "replace",
		Path:  "/spec/userId",
		Value: patchValueUserId,
	}
	patch = append(patch, patchOpUserId)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		UserPreferences().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalUserPreference{
		client:         group.client,
		UserPreference: result,
	}, nil
}

// ListUserPreferences returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListUserPreferences(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalUserPreference, err error) {
	key := "userpreferences.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalUserPreference, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.UserPreference)
			result[k] = &GlobalUserPreference{
				client:         group.client,
				UserPreference: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			UserPreferences().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalUserPreference, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalUserPreference{
				client:         group.client,
				UserPreference: &item,
			}
		}
	}
	return
}

type GlobalUserPreference struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.UserPreference
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalUserPreference) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteUserPreferenceByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.UserPreference = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalUserPreference) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateUserPreferenceByName(ctx, obj.UserPreference)
	if err != nil {
		return err
	}
	obj.UserPreference = result.UserPreference
	return nil
}

func (obj *GlobalUserPreference) GetParent(ctx context.Context) (result *GlobalUser, err error) {
	hashedName := helper.GetHashedName("users.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["users.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetUserByName(ctx, hashedName)
}

type userpreferenceGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *userpreferenceGlobalTsmV1Chainer) Subscribe() {
	key := "userpreferences.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewUserPreferenceInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *userpreferenceGlobalTsmV1Chainer) Unsubscribe() {
	key := "userpreferences.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *userpreferenceGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "userpreferences.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetUserByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetUserByName(ctx context.Context, hashedName string) (*GlobalUser, error) {
	key := "users.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.User)
		return &GlobalUser{
			client: group.client,
			User:   result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			Users().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalUser{
			client: group.client,
			User:   result,
		}, nil
	}
}

// DeleteUserByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteUserByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Users().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.PreferencesGvk {
		err := group.client.
			Global().DeleteUserPreferenceByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		Users().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/usersGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["userfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("userfolders.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		UserFolders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateUserByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateUserByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.User) (*GlobalUser, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.PreferencesGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		Users().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["userfolders.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("userfolders.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"usersGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"User\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		UserFolders().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalUser{
		client: group.client,
		User:   result,
	}, nil
}

// UpdateUserByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateUserByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.User) (*GlobalUser, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			Users().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueUsername :=
		objToUpdate.Spec.Username
	patchOpUsername := PatchOp{
		Op:    "replace",
		Path:  "/spec/username",
		Value: patchValueUsername,
	}
	patch = append(patch, patchOpUsername)

	patchValuePassword :=
		objToUpdate.Spec.Password
	patchOpPassword := PatchOp{
		Op:    "replace",
		Path:  "/spec/password",
		Value: patchValuePassword,
	}
	patch = append(patch, patchOpPassword)

	patchValueEmail :=
		objToUpdate.Spec.Email
	patchOpEmail := PatchOp{
		Op:    "replace",
		Path:  "/spec/email",
		Value: patchValueEmail,
	}
	patch = append(patch, patchOpEmail)

	if objToUpdate.Spec.AccessTokens != nil {
		patchValueAccessTokens :=
			objToUpdate.Spec.AccessTokens
		patchOpAccessTokens := PatchOp{
			Op:    "replace",
			Path:  "/spec/accessTokens",
			Value: patchValueAccessTokens,
		}
		patch = append(patch, patchOpAccessTokens)
	}

	patchValueLastActionDate :=
		objToUpdate.Spec.LastActionDate
	patchOpLastActionDate := PatchOp{
		Op:    "replace",
		Path:  "/spec/lastActionDate",
		Value: patchValueLastActionDate,
	}
	patch = append(patch, patchOpLastActionDate)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		Users().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalUser{
		client: group.client,
		User:   result,
	}, nil
}

// ListUsers returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListUsers(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalUser, err error) {
	key := "users.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalUser, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.User)
			result[k] = &GlobalUser{
				client: group.client,
				User:   item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			Users().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalUser, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalUser{
				client: group.client,
				User:   &item,
			}
		}
	}
	return
}

type GlobalUser struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.User
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalUser) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteUserByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.User = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalUser) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateUserByName(ctx, obj.User)
	if err != nil {
		return err
	}
	obj.User = result.User
	return nil
}

func (obj *GlobalUser) GetParent(ctx context.Context) (result *GlobalUserFolder, err error) {
	hashedName := helper.GetHashedName("userfolders.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["userfolders.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetUserFolderByName(ctx, hashedName)
}

// GetAllPreferences returns all children of given type
func (obj *GlobalUser) GetAllPreferences(ctx context.Context) (
	result []*GlobalUserPreference, err error) {
	result = make([]*GlobalUserPreference, 0, len(obj.Spec.PreferencesGvk))
	for _, v := range obj.Spec.PreferencesGvk {
		l, err := obj.client.Global().GetUserPreferenceByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetPreferences returns child which has given displayName
func (obj *GlobalUser) GetPreferences(ctx context.Context,
	displayName string) (result *GlobalUserPreference, err error) {
	l, ok := obj.Spec.PreferencesGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Global.User", "Preferences", displayName)
	}
	result, err = obj.client.Global().GetUserPreferenceByName(ctx, l.Name)
	return
}

// AddPreferences calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GlobalUser) AddPreferences(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.UserPreference) (result *GlobalUserPreference, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["users.global.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["users.global.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Global().CreateUserPreferenceByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Global().GetUserByName(ctx, obj.GetName())
	if getErr == nil {
		obj.User = updatedObj.User
	}
	return
}

// DeletePreferences calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GlobalUser) DeletePreferences(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.PreferencesGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Global.User", "Preferences", displayName)
	}
	err = obj.client.Global().DeleteUserPreferenceByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Global().GetUserByName(ctx, obj.GetName())
	if err == nil {
		obj.User = updatedObj.User
	}
	return
}

type userGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *userGlobalTsmV1Chainer) Subscribe() {
	key := "users.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewUserInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *userGlobalTsmV1Chainer) Unsubscribe() {
	key := "users.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *userGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "users.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *userGlobalTsmV1Chainer) Preferences(name string) *userpreferenceGlobalTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["userpreferences.global.tsm.tanzu.vmware.com"] = name
	return &userpreferenceGlobalTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetPreferences calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *userGlobalTsmV1Chainer) GetPreferences(ctx context.Context, displayName string) (result *GlobalUserPreference, err error) {
	hashedName := helper.GetHashedName("userpreferences.global.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Global().GetUserPreferenceByName(ctx, hashedName)
}

// AddPreferences calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *userGlobalTsmV1Chainer) AddPreferences(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.UserPreference) (result *GlobalUserPreference, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("userpreferences.global.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Global().CreateUserPreferenceByName(ctx, objToCreate)
}

// DeletePreferences calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *userGlobalTsmV1Chainer) DeletePreferences(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("userpreferences.global.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Global().DeleteUserPreferenceByName(ctx, hashedName)
}

// GetVirtualServiceByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetVirtualServiceByName(ctx context.Context, hashedName string) (*GlobalVirtualService, error) {
	key := "virtualservices.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.VirtualService)
		return &GlobalVirtualService{
			client:         group.client,
			VirtualService: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			VirtualServices().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalVirtualService{
			client:         group.client,
			VirtualService: result,
		}, nil
	}
}

// DeleteVirtualServiceByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteVirtualServiceByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		VirtualServices().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		VirtualServices().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/virtualServicesGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateVirtualServiceByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateVirtualServiceByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.VirtualService) (*GlobalVirtualService, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.DestinationRulesGvk = nil
	objToCreate.Spec.ServicesGvk = nil
	objToCreate.Spec.GatewaysGvk = nil

	result, err := group.client.baseClient.
		GlobalTsmV1().
		VirtualServices().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"virtualServicesGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"VirtualService\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalVirtualService{
		client:         group.client,
		VirtualService: result,
	}, nil
}

// UpdateVirtualServiceByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateVirtualServiceByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.VirtualService) (*GlobalVirtualService, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			VirtualServices().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueCreationTimestamp :=
		objToUpdate.Spec.CreationTimestamp
	patchOpCreationTimestamp := PatchOp{
		Op:    "replace",
		Path:  "/spec/creationTimestamp",
		Value: patchValueCreationTimestamp,
	}
	patch = append(patch, patchOpCreationTimestamp)

	patchValueApiLink :=
		objToUpdate.Spec.ApiLink
	patchOpApiLink := PatchOp{
		Op:    "replace",
		Path:  "/spec/apiLink",
		Value: patchValueApiLink,
	}
	patch = append(patch, patchOpApiLink)

	patchValueUid :=
		objToUpdate.Spec.Uid
	patchOpUid := PatchOp{
		Op:    "replace",
		Path:  "/spec/uid",
		Value: patchValueUid,
	}
	patch = append(patch, patchOpUid)

	patchValueAnnotations :=
		objToUpdate.Spec.Annotations
	patchOpAnnotations := PatchOp{
		Op:    "replace",
		Path:  "/spec/annotations",
		Value: patchValueAnnotations,
	}
	patch = append(patch, patchOpAnnotations)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueHosts :=
		objToUpdate.Spec.Hosts
	patchOpHosts := PatchOp{
		Op:    "replace",
		Path:  "/spec/hosts",
		Value: patchValueHosts,
	}
	patch = append(patch, patchOpHosts)

	patchValueHttp :=
		objToUpdate.Spec.Http
	patchOpHttp := PatchOp{
		Op:    "replace",
		Path:  "/spec/http",
		Value: patchValueHttp,
	}
	patch = append(patch, patchOpHttp)

	patchValueTls :=
		objToUpdate.Spec.Tls
	patchOpTls := PatchOp{
		Op:    "replace",
		Path:  "/spec/tls",
		Value: patchValueTls,
	}
	patch = append(patch, patchOpTls)

	patchValueTcp :=
		objToUpdate.Spec.Tcp
	patchOpTcp := PatchOp{
		Op:    "replace",
		Path:  "/spec/tcp",
		Value: patchValueTcp,
	}
	patch = append(patch, patchOpTcp)

	patchValueGatewayNames :=
		objToUpdate.Spec.GatewayNames
	patchOpGatewayNames := PatchOp{
		Op:    "replace",
		Path:  "/spec/gatewayNames",
		Value: patchValueGatewayNames,
	}
	patch = append(patch, patchOpGatewayNames)

	if objToUpdate.Spec.ExportTo != nil {
		patchValueExportTo :=
			objToUpdate.Spec.ExportTo
		patchOpExportTo := PatchOp{
			Op:    "replace",
			Path:  "/spec/exportTo",
			Value: patchValueExportTo,
		}
		patch = append(patch, patchOpExportTo)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		VirtualServices().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalVirtualService{
		client:         group.client,
		VirtualService: result,
	}, nil
}

// ListVirtualServices returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListVirtualServices(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalVirtualService, err error) {
	key := "virtualservices.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalVirtualService, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.VirtualService)
			result[k] = &GlobalVirtualService{
				client:         group.client,
				VirtualService: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			VirtualServices().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalVirtualService, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalVirtualService{
				client:         group.client,
				VirtualService: &item,
			}
		}
	}
	return
}

type GlobalVirtualService struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.VirtualService
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalVirtualService) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteVirtualServiceByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.VirtualService = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalVirtualService) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateVirtualServiceByName(ctx, obj.VirtualService)
	if err != nil {
		return err
	}
	obj.VirtualService = result.VirtualService
	return nil
}

func (obj *GlobalVirtualService) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

// GetAllDestinationRules returns all links of given type
func (obj *GlobalVirtualService) GetAllDestinationRules(ctx context.Context) (
	result []*GlobalDestinationRule, err error) {
	result = make([]*GlobalDestinationRule, 0, len(obj.Spec.DestinationRulesGvk))
	for _, v := range obj.Spec.DestinationRulesGvk {
		l, err := obj.client.Global().GetDestinationRuleByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetDestinationRules returns link which has given displayName
func (obj *GlobalVirtualService) GetDestinationRules(ctx context.Context,
	displayName string) (result *GlobalDestinationRule, err error) {
	l, ok := obj.Spec.DestinationRulesGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.VirtualService", "DestinationRules", displayName)
	}
	result, err = obj.client.Global().GetDestinationRuleByName(ctx, l.Name)
	return
}

// LinkDestinationRules links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalVirtualService) LinkDestinationRules(ctx context.Context,
	linkToAdd *GlobalDestinationRule) error {

	payload := "{\"spec\": {\"destinationRulesGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"DestinationRule\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().VirtualServices().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.VirtualService = result
	return nil
}

// UnlinkDestinationRules unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalVirtualService) UnlinkDestinationRules(ctx context.Context,
	linkToRemove *GlobalDestinationRule) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/destinationRulesGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().VirtualServices().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.VirtualService = result
	return nil

}

// GetAllServices returns all links of given type
func (obj *GlobalVirtualService) GetAllServices(ctx context.Context) (
	result []*GlobalService, err error) {
	result = make([]*GlobalService, 0, len(obj.Spec.ServicesGvk))
	for _, v := range obj.Spec.ServicesGvk {
		l, err := obj.client.Global().GetServiceByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetServices returns link which has given displayName
func (obj *GlobalVirtualService) GetServices(ctx context.Context,
	displayName string) (result *GlobalService, err error) {
	l, ok := obj.Spec.ServicesGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.VirtualService", "Services", displayName)
	}
	result, err = obj.client.Global().GetServiceByName(ctx, l.Name)
	return
}

// LinkServices links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalVirtualService) LinkServices(ctx context.Context,
	linkToAdd *GlobalService) error {

	payload := "{\"spec\": {\"servicesGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"Service\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().VirtualServices().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.VirtualService = result
	return nil
}

// UnlinkServices unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalVirtualService) UnlinkServices(ctx context.Context,
	linkToRemove *GlobalService) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/servicesGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().VirtualServices().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.VirtualService = result
	return nil

}

// GetAllGateways returns all links of given type
func (obj *GlobalVirtualService) GetAllGateways(ctx context.Context) (
	result []*GlobalGateway, err error) {
	result = make([]*GlobalGateway, 0, len(obj.Spec.GatewaysGvk))
	for _, v := range obj.Spec.GatewaysGvk {
		l, err := obj.client.Global().GetGatewayByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGateways returns link which has given displayName
func (obj *GlobalVirtualService) GetGateways(ctx context.Context,
	displayName string) (result *GlobalGateway, err error) {
	l, ok := obj.Spec.GatewaysGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Global.VirtualService", "Gateways", displayName)
	}
	result, err = obj.client.Global().GetGatewayByName(ctx, l.Name)
	return
}

// LinkGateways links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GlobalVirtualService) LinkGateways(ctx context.Context,
	linkToAdd *GlobalGateway) error {

	payload := "{\"spec\": {\"gatewaysGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"Gateway\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GlobalTsmV1().VirtualServices().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.VirtualService = result
	return nil
}

// UnlinkGateways unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GlobalVirtualService) UnlinkGateways(ctx context.Context,
	linkToRemove *GlobalGateway) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gatewaysGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GlobalTsmV1().VirtualServices().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.VirtualService = result
	return nil

}

type virtualserviceGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *virtualserviceGlobalTsmV1Chainer) Subscribe() {
	key := "virtualservices.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewVirtualServiceInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *virtualserviceGlobalTsmV1Chainer) Unsubscribe() {
	key := "virtualservices.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *virtualserviceGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "virtualservices.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetWorkloadEntryByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) GetWorkloadEntryByName(ctx context.Context, hashedName string) (*GlobalWorkloadEntry, error) {
	key := "workloadentries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseglobaltsmtanzuvmwarecomv1.WorkloadEntry)
		return &GlobalWorkloadEntry{
			client:        group.client,
			WorkloadEntry: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GlobalTsmV1().
			WorkloadEntries().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GlobalWorkloadEntry{
			client:        group.client,
			WorkloadEntry: result,
		}, nil
	}
}

// DeleteWorkloadEntryByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GlobalTsmV1) DeleteWorkloadEntryByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GlobalTsmV1().
		WorkloadEntries().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GlobalTsmV1().
		WorkloadEntries().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/workloadEntryGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateWorkloadEntryByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GlobalTsmV1) CreateWorkloadEntryByName(ctx context.Context,
	objToCreate *baseglobaltsmtanzuvmwarecomv1.WorkloadEntry) (*GlobalWorkloadEntry, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GlobalTsmV1().
		WorkloadEntries().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["domains.global.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"workloadEntryGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"WorkloadEntry\", \"group\": \"global.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GlobalTsmV1().
		Domains().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GlobalWorkloadEntry{
		client:        group.client,
		WorkloadEntry: result,
	}, nil
}

// UpdateWorkloadEntryByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GlobalTsmV1) UpdateWorkloadEntryByName(ctx context.Context,
	objToUpdate *baseglobaltsmtanzuvmwarecomv1.WorkloadEntry) (*GlobalWorkloadEntry, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GlobalTsmV1().
			WorkloadEntries().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueAnnotations :=
		objToUpdate.Spec.Annotations
	patchOpAnnotations := PatchOp{
		Op:    "replace",
		Path:  "/spec/annotations",
		Value: patchValueAnnotations,
	}
	patch = append(patch, patchOpAnnotations)

	patchValueLabels :=
		objToUpdate.Spec.Labels
	patchOpLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/labels",
		Value: patchValueLabels,
	}
	patch = append(patch, patchOpLabels)

	patchValueCreationTimestamp :=
		objToUpdate.Spec.CreationTimestamp
	patchOpCreationTimestamp := PatchOp{
		Op:    "replace",
		Path:  "/spec/creationTimestamp",
		Value: patchValueCreationTimestamp,
	}
	patch = append(patch, patchOpCreationTimestamp)

	patchValueApiLink :=
		objToUpdate.Spec.ApiLink
	patchOpApiLink := PatchOp{
		Op:    "replace",
		Path:  "/spec/apiLink",
		Value: patchValueApiLink,
	}
	patch = append(patch, patchOpApiLink)

	patchValueUid :=
		objToUpdate.Spec.Uid
	patchOpUid := PatchOp{
		Op:    "replace",
		Path:  "/spec/uid",
		Value: patchValueUid,
	}
	patch = append(patch, patchOpUid)

	patchValueAddress :=
		objToUpdate.Spec.Address
	patchOpAddress := PatchOp{
		Op:    "replace",
		Path:  "/spec/address",
		Value: patchValueAddress,
	}
	patch = append(patch, patchOpAddress)

	patchValueWorkloadLabels :=
		objToUpdate.Spec.WorkloadLabels
	patchOpWorkloadLabels := PatchOp{
		Op:    "replace",
		Path:  "/spec/workloadLabels",
		Value: patchValueWorkloadLabels,
	}
	patch = append(patch, patchOpWorkloadLabels)

	patchValuePorts :=
		objToUpdate.Spec.Ports
	patchOpPorts := PatchOp{
		Op:    "replace",
		Path:  "/spec/ports",
		Value: patchValuePorts,
	}
	patch = append(patch, patchOpPorts)

	patchValueLocality :=
		objToUpdate.Spec.Locality
	patchOpLocality := PatchOp{
		Op:    "replace",
		Path:  "/spec/locality",
		Value: patchValueLocality,
	}
	patch = append(patch, patchOpLocality)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GlobalTsmV1().
		WorkloadEntries().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GlobalWorkloadEntry{
		client:        group.client,
		WorkloadEntry: result,
	}, nil
}

// ListWorkloadEntries returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GlobalTsmV1) ListWorkloadEntries(ctx context.Context,
	opts metav1.ListOptions) (result []*GlobalWorkloadEntry, err error) {
	key := "workloadentries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GlobalWorkloadEntry, len(items))
		for k, v := range items {
			item, _ := v.(*baseglobaltsmtanzuvmwarecomv1.WorkloadEntry)
			result[k] = &GlobalWorkloadEntry{
				client:        group.client,
				WorkloadEntry: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GlobalTsmV1().
			WorkloadEntries().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GlobalWorkloadEntry, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GlobalWorkloadEntry{
				client:        group.client,
				WorkloadEntry: &item,
			}
		}
	}
	return
}

type GlobalWorkloadEntry struct {
	client *Clientset
	*baseglobaltsmtanzuvmwarecomv1.WorkloadEntry
}

// Delete removes obj and all it's children from the database.
func (obj *GlobalWorkloadEntry) Delete(ctx context.Context) error {
	err := obj.client.Global().DeleteWorkloadEntryByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.WorkloadEntry = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GlobalWorkloadEntry) Update(ctx context.Context) error {
	result, err := obj.client.Global().UpdateWorkloadEntryByName(ctx, obj.WorkloadEntry)
	if err != nil {
		return err
	}
	obj.WorkloadEntry = result.WorkloadEntry
	return nil
}

func (obj *GlobalWorkloadEntry) GetParent(ctx context.Context) (result *GlobalDomain, err error) {
	hashedName := helper.GetHashedName("domains.global.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["domains.global.tsm.tanzu.vmware.com"])
	return obj.client.Global().GetDomainByName(ctx, hashedName)
}

type workloadentryGlobalTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *workloadentryGlobalTsmV1Chainer) Subscribe() {
	key := "workloadentries.global.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerglobaltsmtanzuvmwarecomv1.NewWorkloadEntryInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *workloadentryGlobalTsmV1Chainer) Unsubscribe() {
	key := "workloadentries.global.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *workloadentryGlobalTsmV1Chainer) IsSubscribed() bool {
	key := "workloadentries.global.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}
