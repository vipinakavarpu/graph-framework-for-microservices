// Code generated by nexus. DO NOT EDIT.

// Nexus client is a shim layer working over k8s API meant to simplify graph operation on nexus nodes.
// Features of nexus client:
// - create/get/update/delete/list of nexus nodes,
// - name hashing to avoid name collision between objects with same name but different parents,
// - ability to get, create and delete child of given parent object,
// - ability to add link and remove link to given object,
// - recursive delete of object and all it's children.
// To initialize client use NewForConfig function with Rest Config as a parameter. After that you can start using
// nexus client. You can check example in: https://gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/docs/-/tree/master/example/crudapp

package nexus_client

import (
	"context"
	"encoding/json"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	types "k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/rest"

	baseClientset "nexustempmodule/client/clientset/versioned"
	fakeBaseClienset "nexustempmodule/client/clientset/versioned/fake"
	"nexustempmodule/common"
	"nexustempmodule/helper"

	baseconfigtsmtanzuvmwarecomv1 "nexustempmodule/apis/config.tsm.tanzu.vmware.com/v1"
	basegnstsmtanzuvmwarecomv1 "nexustempmodule/apis/gns.tsm.tanzu.vmware.com/v1"
	baseroottsmtanzuvmwarecomv1 "nexustempmodule/apis/root.tsm.tanzu.vmware.com/v1"
)

type Clientset struct {
	baseClient  baseClientset.Interface
	rootTsmV1   *RootTsmV1
	configTsmV1 *ConfigTsmV1
	gnsTsmV1    *GnsTsmV1
}

// NewForConfig returns Client which can be which can be used to connect to database
func NewForConfig(config *rest.Config) (*Clientset, error) {
	baseClient, err := baseClientset.NewForConfig(config)
	if err != nil {
		return nil, err
	}
	client := &Clientset{}
	client.baseClient = baseClient
	client.rootTsmV1 = newRootTsmV1(client)
	client.configTsmV1 = newConfigTsmV1(client)
	client.gnsTsmV1 = newGnsTsmV1(client)

	return client, nil
}

// NewFakeClient creates simple client which can be used for unit tests
func NewFakeClient() *Clientset {
	client := &Clientset{}
	client.baseClient = fakeBaseClienset.NewSimpleClientset()
	client.rootTsmV1 = newRootTsmV1(client)
	client.configTsmV1 = newConfigTsmV1(client)
	client.gnsTsmV1 = newGnsTsmV1(client)

	return client
}

type PatchOp struct {
	Op    string      `json:"op"`
	Path  string      `json:"path"`
	Value interface{} `json:"value,omitempty"`
}

type Patch []PatchOp

func (p Patch) Marshal() ([]byte, error) {
	return json.Marshal(p)
}

func (c *Clientset) Root() *RootTsmV1 {
	return c.rootTsmV1
}
func (c *Clientset) Config() *ConfigTsmV1 {
	return c.configTsmV1
}
func (c *Clientset) Gns() *GnsTsmV1 {
	return c.gnsTsmV1
}

type RootTsmV1 struct {
	client *Clientset
}

func newRootTsmV1(client *Clientset) *RootTsmV1 {
	return &RootTsmV1{
		client: client,
	}
}

type ConfigTsmV1 struct {
	client *Clientset
}

func newConfigTsmV1(client *Clientset) *ConfigTsmV1 {
	return &ConfigTsmV1{
		client: client,
	}
}

type GnsTsmV1 struct {
	client *Clientset
}

func newGnsTsmV1(client *Clientset) *GnsTsmV1 {
	return &GnsTsmV1{
		client: client,
	}
}

// GetRootByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RootTsmV1) GetRootByName(ctx context.Context, hashedName string) (*RootRoot, error) {
	result, err := group.client.baseClient.
		RootTsmV1().
		Roots().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &RootRoot{
		client: group.client,
		Root:   result,
	}, nil
}

// DeleteRootByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RootTsmV1) DeleteRootByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		RootTsmV1().
		Roots().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.ConfigGvk != nil {
		err := group.client.
			Config().
			DeleteConfigByName(ctx, result.Spec.ConfigGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		RootTsmV1().
		Roots().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateRootByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RootTsmV1) CreateRootByName(ctx context.Context,
	objToCreate *baseroottsmtanzuvmwarecomv1.Root) (*RootRoot, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.ConfigGvk = nil

	result, err := group.client.baseClient.
		RootTsmV1().
		Roots().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	return &RootRoot{
		client: group.client,
		Root:   result,
	}, nil
}

// UpdateRootByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RootTsmV1) UpdateRootByName(ctx context.Context,
	objToUpdate *baseroottsmtanzuvmwarecomv1.Root) (*RootRoot, error) {
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			RootTsmV1().
			Roots().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDisplayName :=
		objToUpdate.Spec.DisplayName
	patchOpDisplayName := PatchOp{
		Op:    "replace",
		Path:  "/spec/displayName",
		Value: patchValueDisplayName,
	}
	patch = append(patch, patchOpDisplayName)

	patchValueCustomBar :=
		objToUpdate.Spec.CustomBar
	patchOpCustomBar := PatchOp{
		Op:    "replace",
		Path:  "/spec/customBar",
		Value: patchValueCustomBar,
	}
	patch = append(patch, patchOpCustomBar)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		RootTsmV1().
		Roots().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &RootRoot{
		client: group.client,
		Root:   result,
	}, nil
}

// ListRoots returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *RootTsmV1) ListRoots(ctx context.Context,
	opts metav1.ListOptions) (result []*RootRoot, err error) {
	list, err := group.client.baseClient.RootTsmV1().
		Roots().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*RootRoot, len(list.Items))
	for k, v := range list.Items {
		item := v
		result[k] = &RootRoot{
			client: group.client,
			Root:   &item,
		}
	}
	return
}

type RootRoot struct {
	client *Clientset
	*baseroottsmtanzuvmwarecomv1.Root
}

// Delete removes obj and all it's children from the database.
func (obj *RootRoot) Delete(ctx context.Context) error {
	err := obj.client.Root().DeleteRootByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Root = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RootRoot) Update(ctx context.Context) error {
	result, err := obj.client.Root().UpdateRootByName(ctx, obj.Root)
	if err != nil {
		return err
	}
	obj.Root = result.Root
	return nil
}

// GetRootRoot calculates the hashed name based on parents and
// returns given object
func (c *Clientset) GetRootRoot(ctx context.Context) (result *RootRoot, err error) {
	hashedName := helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", nil, helper.DEFAULT_KEY)
	return c.Root().GetRootByName(ctx, hashedName)
}

func (c *Clientset) RootRoot() *rootRootTsmV1Chainer {
	parentLabels := make(map[string]string)
	parentLabels["roots.root.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &rootRootTsmV1Chainer{
		client:       c,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// AddRootRoot calculates hashed name of the object based on
// parents names and creates it. objToCreate.Name is changed to the hashed name. Original name (helper.DEFAULT_KEY) is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) AddRootRoot(ctx context.Context,
	objToCreate *baseroottsmtanzuvmwarecomv1.Root) (result *RootRoot, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.Root().CreateRootByName(ctx, objToCreate)
}

// DeleteRootRoot calculates hashedName of object based on
// parents and deletes given object
func (c *Clientset) DeleteRootRoot(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", nil, helper.DEFAULT_KEY)
	return c.Root().DeleteRootByName(ctx, hashedName)
}

// GetConfig returns child of given type
func (obj *RootRoot) GetConfig(ctx context.Context) (
	result *ConfigConfig, err error) {
	if obj.Spec.ConfigGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Root.Root", "Config")
	}
	return obj.client.Config().GetConfigByName(ctx, obj.Spec.ConfigGvk.Name)
}

// AddConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *RootRoot) AddConfig(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.Config) (result *ConfigConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["roots.root.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["roots.root.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Config().CreateConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Root().GetRootByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Root = updatedObj.Root
	}
	return
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *RootRoot) DeleteConfig(ctx context.Context) (err error) {
	if obj.Spec.ConfigGvk != nil {
		err = obj.client.
			Config().DeleteConfigByName(ctx, obj.Spec.ConfigGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Root().GetRootByName(ctx, obj.GetName())
	if err == nil {
		obj.Root = updatedObj.Root
	}
	return
}

type rootRootTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *rootRootTsmV1Chainer) Config(name string) *configConfigTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["configs.config.tsm.tanzu.vmware.com"] = name
	return &configConfigTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetConfig calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *rootRootTsmV1Chainer) GetConfig(ctx context.Context, displayName string) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Config().GetConfigByName(ctx, hashedName)
}

// AddConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *rootRootTsmV1Chainer) AddConfig(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.Config) (result *ConfigConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Config().CreateConfigByName(ctx, objToCreate)
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *rootRootTsmV1Chainer) DeleteConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Config().DeleteConfigByName(ctx, hashedName)
}

// GetConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConfigTsmV1) GetConfigByName(ctx context.Context, hashedName string) (*ConfigConfig, error) {
	result, err := group.client.baseClient.
		ConfigTsmV1().
		Configs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// DeleteConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ConfigTsmV1) DeleteConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		ConfigTsmV1().
		Configs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.GNSGvk != nil {
		err := group.client.
			Gns().
			DeleteGnsByName(ctx, result.Spec.GNSGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		ConfigTsmV1().
		Configs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/configGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["roots.root.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		RootTsmV1().
		Roots().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ConfigTsmV1) CreateConfigByName(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.Config) (*ConfigConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.GNSGvk = nil

	result, err := group.client.baseClient.
		ConfigTsmV1().
		Configs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["roots.root.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/configGvk",
		Value: baseconfigtsmtanzuvmwarecomv1.Child{
			Group: "config.tsm.tanzu.vmware.com",
			Kind:  "Config",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		RootTsmV1().
		Roots().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// UpdateConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ConfigTsmV1) UpdateConfigByName(ctx context.Context,
	objToUpdate *baseconfigtsmtanzuvmwarecomv1.Config) (*ConfigConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			ConfigTsmV1().
			Configs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueConfigName :=
		objToUpdate.Spec.ConfigName
	patchOpConfigName := PatchOp{
		Op:    "replace",
		Path:  "/spec/configName",
		Value: patchValueConfigName,
	}
	patch = append(patch, patchOpConfigName)

	patchValueCluster :=
		objToUpdate.Spec.Cluster
	patchOpCluster := PatchOp{
		Op:    "replace",
		Path:  "/spec/cluster",
		Value: patchValueCluster,
	}
	patch = append(patch, patchOpCluster)

	patchValueFooA :=
		objToUpdate.Spec.FooA
	patchOpFooA := PatchOp{
		Op:    "replace",
		Path:  "/spec/fooA",
		Value: patchValueFooA,
	}
	patch = append(patch, patchOpFooA)

	patchValueFooMap :=
		objToUpdate.Spec.FooMap
	patchOpFooMap := PatchOp{
		Op:    "replace",
		Path:  "/spec/fooMap",
		Value: patchValueFooMap,
	}
	patch = append(patch, patchOpFooMap)

	patchValueFooB :=
		objToUpdate.Spec.FooB
	patchOpFooB := PatchOp{
		Op:    "replace",
		Path:  "/spec/fooB",
		Value: patchValueFooB,
	}
	patch = append(patch, patchOpFooB)

	patchValueFooC :=
		objToUpdate.Spec.FooC
	patchOpFooC := PatchOp{
		Op:    "replace",
		Path:  "/spec/fooC",
		Value: patchValueFooC,
	}
	patch = append(patch, patchOpFooC)

	patchValueFooD :=
		objToUpdate.Spec.FooD
	patchOpFooD := PatchOp{
		Op:    "replace",
		Path:  "/spec/fooD",
		Value: patchValueFooD,
	}
	patch = append(patch, patchOpFooD)

	patchValueFooE :=
		objToUpdate.Spec.FooE
	patchOpFooE := PatchOp{
		Op:    "replace",
		Path:  "/spec/fooE",
		Value: patchValueFooE,
	}
	patch = append(patch, patchOpFooE)

	patchValueFooF :=
		objToUpdate.Spec.FooF
	patchOpFooF := PatchOp{
		Op:    "replace",
		Path:  "/spec/fooF",
		Value: patchValueFooF,
	}
	patch = append(patch, patchOpFooF)

	patchValueXYZPort :=
		objToUpdate.Spec.XYZPort
	patchOpXYZPort := PatchOp{
		Op:    "replace",
		Path:  "/spec/xYZPort",
		Value: patchValueXYZPort,
	}
	patch = append(patch, patchOpXYZPort)

	patchValueABCHost :=
		objToUpdate.Spec.ABCHost
	patchOpABCHost := PatchOp{
		Op:    "replace",
		Path:  "/spec/aBCHost",
		Value: patchValueABCHost,
	}
	patch = append(patch, patchOpABCHost)

	patchValueClusterNamespaces :=
		objToUpdate.Spec.ClusterNamespaces
	patchOpClusterNamespaces := PatchOp{
		Op:    "replace",
		Path:  "/spec/clusterNamespaces",
		Value: patchValueClusterNamespaces,
	}
	patch = append(patch, patchOpClusterNamespaces)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		ConfigTsmV1().
		Configs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// ListConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ConfigTsmV1) ListConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*ConfigConfig, err error) {
	list, err := group.client.baseClient.ConfigTsmV1().
		Configs().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*ConfigConfig, len(list.Items))
	for k, v := range list.Items {
		item := v
		result[k] = &ConfigConfig{
			client: group.client,
			Config: &item,
		}
	}
	return
}

type ConfigConfig struct {
	client *Clientset
	*baseconfigtsmtanzuvmwarecomv1.Config
}

// Delete removes obj and all it's children from the database.
func (obj *ConfigConfig) Delete(ctx context.Context) error {
	err := obj.client.Config().DeleteConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Config = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ConfigConfig) Update(ctx context.Context) error {
	result, err := obj.client.Config().UpdateConfigByName(ctx, obj.Config)
	if err != nil {
		return err
	}
	obj.Config = result.Config
	return nil
}

func (obj *ConfigConfig) GetParent(ctx context.Context) (result *RootRoot, err error) {
	hashedName := helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["roots.root.tsm.tanzu.vmware.com"])
	return obj.client.Root().GetRootByName(ctx, hashedName)
}

// GetGNS returns child of given type
func (obj *ConfigConfig) GetGNS(ctx context.Context) (
	result *GnsGns, err error) {
	if obj.Spec.GNSGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Config.Config", "GNS")
	}
	return obj.client.Gns().GetGnsByName(ctx, obj.Spec.GNSGvk.Name)
}

// AddGNS calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddGNS(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Gns) (result *GnsGns, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Gns().CreateGnsByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteGNS calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteGNS(ctx context.Context) (err error) {
	if obj.Spec.GNSGvk != nil {
		err = obj.client.
			Gns().DeleteGnsByName(ctx, obj.Spec.GNSGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

type configConfigTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *configConfigTsmV1Chainer) GNS(name string) *gnsGnsTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gnses.gns.tsm.tanzu.vmware.com"] = name
	return &gnsGnsTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGNS calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigTsmV1Chainer) GetGNS(ctx context.Context, displayName string) (result *GnsGns, err error) {
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Gns().GetGnsByName(ctx, hashedName)
}

// AddGNS calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigTsmV1Chainer) AddGNS(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Gns) (result *GnsGns, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Gns().CreateGnsByName(ctx, objToCreate)
}

// DeleteGNS calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigTsmV1Chainer) DeleteGNS(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Gns().DeleteGnsByName(ctx, hashedName)
}

// GetGnsByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) GetGnsByName(ctx context.Context, hashedName string) (*GnsGns, error) {
	result, err := group.client.baseClient.
		GnsTsmV1().
		Gnses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &GnsGns{
		client: group.client,
		Gns:    result,
	}, nil
}

// DeleteGnsByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) DeleteGnsByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GnsTsmV1().
		Gnses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.FooChildGvk != nil {
		err := group.client.
			Gns().
			DeleteBarChildByName(ctx, result.Spec.FooChildGvk.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.FooChildrenGvk {
		err := group.client.
			Gns().DeleteBarChildrenByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GnsTsmV1().
		Gnses().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gNSGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		ConfigTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGnsByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GnsTsmV1) CreateGnsByName(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Gns) (*GnsGns, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.FooChildGvk = nil
	objToCreate.Spec.FooChildrenGvk = nil
	objToCreate.Spec.FooLinkGvk = nil
	objToCreate.Spec.FooLinksGvk = nil

	result, err := group.client.baseClient.
		GnsTsmV1().
		Gnses().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/gNSGvk",
		Value: basegnstsmtanzuvmwarecomv1.Child{
			Group: "gns.tsm.tanzu.vmware.com",
			Kind:  "Gns",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		ConfigTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GnsGns{
		client: group.client,
		Gns:    result,
	}, nil
}

// UpdateGnsByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GnsTsmV1) UpdateGnsByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.Gns) (*GnsGns, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GnsTsmV1().
			Gnses().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDomain :=
		objToUpdate.Spec.Domain
	patchOpDomain := PatchOp{
		Op:    "replace",
		Path:  "/spec/domain",
		Value: patchValueDomain,
	}
	patch = append(patch, patchOpDomain)

	patchValueUseSharedGateway :=
		objToUpdate.Spec.UseSharedGateway
	patchOpUseSharedGateway := PatchOp{
		Op:    "replace",
		Path:  "/spec/useSharedGateway",
		Value: patchValueUseSharedGateway,
	}
	patch = append(patch, patchOpUseSharedGateway)

	patchValueMydesc :=
		objToUpdate.Spec.Mydesc
	patchOpMydesc := PatchOp{
		Op:    "replace",
		Path:  "/spec/mydesc",
		Value: patchValueMydesc,
	}
	patch = append(patch, patchOpMydesc)

	patchValueHostPort :=
		objToUpdate.Spec.HostPort
	patchOpHostPort := PatchOp{
		Op:    "replace",
		Path:  "/spec/hostPort",
		Value: patchValueHostPort,
	}
	patch = append(patch, patchOpHostPort)

	patchValueInstance :=
		objToUpdate.Spec.Instance
	patchOpInstance := PatchOp{
		Op:    "replace",
		Path:  "/spec/instance",
		Value: patchValueInstance,
	}
	patch = append(patch, patchOpInstance)

	patchValueArray1 :=
		objToUpdate.Spec.Array1
	patchOpArray1 := PatchOp{
		Op:    "replace",
		Path:  "/spec/array1",
		Value: patchValueArray1,
	}
	patch = append(patch, patchOpArray1)

	patchValueArray2 :=
		objToUpdate.Spec.Array2
	patchOpArray2 := PatchOp{
		Op:    "replace",
		Path:  "/spec/array2",
		Value: patchValueArray2,
	}
	patch = append(patch, patchOpArray2)

	patchValueArray3 :=
		objToUpdate.Spec.Array3
	patchOpArray3 := PatchOp{
		Op:    "replace",
		Path:  "/spec/array3",
		Value: patchValueArray3,
	}
	patch = append(patch, patchOpArray3)

	patchValueArray4 :=
		objToUpdate.Spec.Array4
	patchOpArray4 := PatchOp{
		Op:    "replace",
		Path:  "/spec/array4",
		Value: patchValueArray4,
	}
	patch = append(patch, patchOpArray4)

	patchValueArray5 :=
		objToUpdate.Spec.Array5
	patchOpArray5 := PatchOp{
		Op:    "replace",
		Path:  "/spec/array5",
		Value: patchValueArray5,
	}
	patch = append(patch, patchOpArray5)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GnsGns{
		client: group.client,
		Gns:    result,
	}, nil
}

// ListGnses returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GnsTsmV1) ListGnses(ctx context.Context,
	opts metav1.ListOptions) (result []*GnsGns, err error) {
	list, err := group.client.baseClient.GnsTsmV1().
		Gnses().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*GnsGns, len(list.Items))
	for k, v := range list.Items {
		item := v
		result[k] = &GnsGns{
			client: group.client,
			Gns:    &item,
		}
	}
	return
}

type GnsGns struct {
	client *Clientset
	*basegnstsmtanzuvmwarecomv1.Gns
}

// Delete removes obj and all it's children from the database.
func (obj *GnsGns) Delete(ctx context.Context) error {
	err := obj.client.Gns().DeleteGnsByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Gns = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GnsGns) Update(ctx context.Context) error {
	result, err := obj.client.Gns().UpdateGnsByName(ctx, obj.Gns)
	if err != nil {
		return err
	}
	obj.Gns = result.Gns
	return nil
}

func (obj *GnsGns) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.config.tsm.tanzu.vmware.com"])
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

// GetFooChild returns child of given type
func (obj *GnsGns) GetFooChild(ctx context.Context) (
	result *GnsBarChild, err error) {
	if obj.Spec.FooChildGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Gns.Gns", "FooChild")
	}
	return obj.client.Gns().GetBarChildByName(ctx, obj.Spec.FooChildGvk.Name)
}

// AddFooChild calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GnsGns) AddFooChild(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.BarChild) (result *GnsBarChild, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnses.gns.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnses.gns.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Gns().CreateBarChildByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Gns().GetGnsByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// DeleteFooChild calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GnsGns) DeleteFooChild(ctx context.Context) (err error) {
	if obj.Spec.FooChildGvk != nil {
		err = obj.client.
			Gns().DeleteBarChildByName(ctx, obj.Spec.FooChildGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Gns().GetGnsByName(ctx, obj.GetName())
	if err == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// GetAllFooChildren returns all children of given type
func (obj *GnsGns) GetAllFooChildren(ctx context.Context) (
	result []*GnsBarChildren, err error) {
	result = make([]*GnsBarChildren, 0, len(obj.Spec.FooChildrenGvk))
	for _, v := range obj.Spec.FooChildrenGvk {
		l, err := obj.client.Gns().GetBarChildrenByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetFooChildren returns child which has given displayName
func (obj *GnsGns) GetFooChildren(ctx context.Context,
	displayName string) (result *GnsBarChildren, err error) {
	l, ok := obj.Spec.FooChildrenGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Gns.Gns", "FooChildren", displayName)
	}
	result, err = obj.client.Gns().GetBarChildrenByName(ctx, l.Name)
	return
}

// AddFooChildren calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GnsGns) AddFooChildren(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.BarChildren) (result *GnsBarChildren, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnses.gns.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnses.gns.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Gns().CreateBarChildrenByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Gns().GetGnsByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// DeleteFooChildren calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GnsGns) DeleteFooChildren(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.FooChildrenGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Gns.Gns", "FooChildren", displayName)
	}
	err = obj.client.Gns().DeleteBarChildrenByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Gns().GetGnsByName(ctx, obj.GetName())
	if err == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// GetFooLink returns link of given type
func (obj *GnsGns) GetFooLink(ctx context.Context) (
	result *GnsBarLink, err error) {
	if obj.Spec.FooLinkGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Gns.Gns", "FooLink")
	}
	return obj.client.Gns().GetBarLinkByName(ctx, obj.Spec.FooLinkGvk.Name)
}

// LinkFooLink links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GnsGns) LinkFooLink(ctx context.Context,
	linkToAdd *GnsBarLink) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/fooLinkGvk",
		Value: basegnstsmtanzuvmwarecomv1.Child{
			Group: "gns.tsm.tanzu.vmware.com",
			Kind:  "BarLink",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GnsTsmV1().Gnses().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Gns = result
	return nil
}

// UnlinkFooLink unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GnsGns) UnlinkFooLink(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/fooLinkGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GnsTsmV1().Gnses().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Gns = result
	return nil

}

// GetAllFooLinks returns all links of given type
func (obj *GnsGns) GetAllFooLinks(ctx context.Context) (
	result []*GnsBarLinks, err error) {
	result = make([]*GnsBarLinks, 0, len(obj.Spec.FooLinksGvk))
	for _, v := range obj.Spec.FooLinksGvk {
		l, err := obj.client.Gns().GetBarLinksByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetFooLinks returns link which has given displayName
func (obj *GnsGns) GetFooLinks(ctx context.Context,
	displayName string) (result *GnsBarLinks, err error) {
	l, ok := obj.Spec.FooLinksGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Gns.Gns", "FooLinks", displayName)
	}
	result, err = obj.client.Gns().GetBarLinksByName(ctx, l.Name)
	return
}

// LinkFooLinks links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GnsGns) LinkFooLinks(ctx context.Context,
	linkToAdd *GnsBarLinks) error {

	payload := "{\"spec\": {\"fooLinksGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"BarLinks\", \"group\": \"gns.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.GnsTsmV1().Gnses().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Gns = result
	return nil
}

// UnlinkFooLinks unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GnsGns) UnlinkFooLinks(ctx context.Context,
	linkToRemove *GnsBarLinks) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/fooLinksGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GnsTsmV1().Gnses().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Gns = result
	return nil

}

type gnsGnsTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *gnsGnsTsmV1Chainer) FooChild() *barchildGnsTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["barchilds.gns.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &barchildGnsTsmV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetFooChild calculates hashed name of the object based on it's parents and returns the object
func (c *gnsGnsTsmV1Chainer) GetFooChild(ctx context.Context) (result *GnsBarChild, err error) {
	hashedName := helper.GetHashedName("barchilds.gns.tsm.tanzu.vmware.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Gns().GetBarChildByName(ctx, hashedName)
}

// AddFooChild calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGnsTsmV1Chainer) AddFooChild(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.BarChild) (result *GnsBarChild, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("barchilds.gns.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Gns().CreateBarChildByName(ctx, objToCreate)
}

// DeleteFooChild calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGnsTsmV1Chainer) DeleteFooChild(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("barchilds.gns.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Gns().DeleteBarChildByName(ctx, hashedName)
}

func (c *gnsGnsTsmV1Chainer) FooChildren(name string) *barchildrenGnsTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["barchildrens.gns.tsm.tanzu.vmware.com"] = name
	return &barchildrenGnsTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetFooChildren calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGnsTsmV1Chainer) GetFooChildren(ctx context.Context, displayName string) (result *GnsBarChildren, err error) {
	hashedName := helper.GetHashedName("barchildrens.gns.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Gns().GetBarChildrenByName(ctx, hashedName)
}

// AddFooChildren calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGnsTsmV1Chainer) AddFooChildren(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.BarChildren) (result *GnsBarChildren, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("barchildrens.gns.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Gns().CreateBarChildrenByName(ctx, objToCreate)
}

// DeleteFooChildren calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGnsTsmV1Chainer) DeleteFooChildren(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("barchildrens.gns.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Gns().DeleteBarChildrenByName(ctx, hashedName)
}

// GetBarLinkByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) GetBarLinkByName(ctx context.Context, hashedName string) (*GnsBarLink, error) {
	result, err := group.client.baseClient.
		GnsTsmV1().
		BarLinks().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &GnsBarLink{
		client:  group.client,
		BarLink: result,
	}, nil
}

// DeleteBarLinkByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) DeleteBarLinkByName(ctx context.Context, hashedName string) (err error) {

	err = group.client.baseClient.
		GnsTsmV1().
		BarLinks().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateBarLinkByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GnsTsmV1) CreateBarLinkByName(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.BarLink) (*GnsBarLink, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GnsTsmV1().
		BarLinks().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	return &GnsBarLink{
		client:  group.client,
		BarLink: result,
	}, nil
}

// UpdateBarLinkByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GnsTsmV1) UpdateBarLinkByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.BarLink) (*GnsBarLink, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GnsTsmV1().
			BarLinks().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GnsTsmV1().
		BarLinks().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GnsBarLink{
		client:  group.client,
		BarLink: result,
	}, nil
}

// ListBarLinks returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GnsTsmV1) ListBarLinks(ctx context.Context,
	opts metav1.ListOptions) (result []*GnsBarLink, err error) {
	list, err := group.client.baseClient.GnsTsmV1().
		BarLinks().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*GnsBarLink, len(list.Items))
	for k, v := range list.Items {
		item := v
		result[k] = &GnsBarLink{
			client:  group.client,
			BarLink: &item,
		}
	}
	return
}

type GnsBarLink struct {
	client *Clientset
	*basegnstsmtanzuvmwarecomv1.BarLink
}

// Delete removes obj and all it's children from the database.
func (obj *GnsBarLink) Delete(ctx context.Context) error {
	err := obj.client.Gns().DeleteBarLinkByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.BarLink = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GnsBarLink) Update(ctx context.Context) error {
	result, err := obj.client.Gns().UpdateBarLinkByName(ctx, obj.BarLink)
	if err != nil {
		return err
	}
	obj.BarLink = result.BarLink
	return nil
}

// GetGnsBarLink calculates the hashed name based on parents and displayName and
// returns given object
func (c *Clientset) GetGnsBarLink(ctx context.Context, displayName string) (result *GnsBarLink, err error) {
	hashedName := helper.GetHashedName("barlinks.gns.tsm.tanzu.vmware.com", nil, displayName)
	return c.Gns().GetBarLinkByName(ctx, hashedName)
}

func (c *Clientset) GnsBarLink(displayName string) *barlinkGnsTsmV1Chainer {
	parentLabels := make(map[string]string)
	parentLabels["barlinks.gns.tsm.tanzu.vmware.com"] = displayName
	return &barlinkGnsTsmV1Chainer{
		client:       c,
		name:         displayName,
		parentLabels: parentLabels,
	}
}

// AddGnsBarLink calculates hashed name of the object based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) AddGnsBarLink(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.BarLink) (result *GnsBarLink, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.Gns().CreateBarLinkByName(ctx, objToCreate)
}

// DeleteGnsBarLink calculates hashedName of object based on displayName and
// parents and deletes given object
func (c *Clientset) DeleteGnsBarLink(ctx context.Context, displayName string) (err error) {
	hashedName := helper.GetHashedName("barlinks.gns.tsm.tanzu.vmware.com", nil, displayName)
	return c.Gns().DeleteBarLinkByName(ctx, hashedName)
}

type barlinkGnsTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

// GetBarChildByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) GetBarChildByName(ctx context.Context, hashedName string) (*GnsBarChild, error) {
	result, err := group.client.baseClient.
		GnsTsmV1().
		BarChilds().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &GnsBarChild{
		client:   group.client,
		BarChild: result,
	}, nil
}

// DeleteBarChildByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) DeleteBarChildByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GnsTsmV1().
		BarChilds().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GnsTsmV1().
		BarChilds().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/fooChildGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateBarChildByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GnsTsmV1) CreateBarChildByName(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.BarChild) (*GnsBarChild, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	result, err := group.client.baseClient.
		GnsTsmV1().
		BarChilds().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/fooChildGvk",
		Value: basegnstsmtanzuvmwarecomv1.Child{
			Group: "gns.tsm.tanzu.vmware.com",
			Kind:  "BarChild",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GnsBarChild{
		client:   group.client,
		BarChild: result,
	}, nil
}

// UpdateBarChildByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GnsTsmV1) UpdateBarChildByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.BarChild) (*GnsBarChild, error) {
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GnsTsmV1().
			BarChilds().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GnsTsmV1().
		BarChilds().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GnsBarChild{
		client:   group.client,
		BarChild: result,
	}, nil
}

// ListBarChilds returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GnsTsmV1) ListBarChilds(ctx context.Context,
	opts metav1.ListOptions) (result []*GnsBarChild, err error) {
	list, err := group.client.baseClient.GnsTsmV1().
		BarChilds().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*GnsBarChild, len(list.Items))
	for k, v := range list.Items {
		item := v
		result[k] = &GnsBarChild{
			client:   group.client,
			BarChild: &item,
		}
	}
	return
}

type GnsBarChild struct {
	client *Clientset
	*basegnstsmtanzuvmwarecomv1.BarChild
}

// Delete removes obj and all it's children from the database.
func (obj *GnsBarChild) Delete(ctx context.Context) error {
	err := obj.client.Gns().DeleteBarChildByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.BarChild = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GnsBarChild) Update(ctx context.Context) error {
	result, err := obj.client.Gns().UpdateBarChildByName(ctx, obj.BarChild)
	if err != nil {
		return err
	}
	obj.BarChild = result.BarChild
	return nil
}

func (obj *GnsBarChild) GetParent(ctx context.Context) (result *GnsGns, err error) {
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnses.gns.tsm.tanzu.vmware.com"])
	return obj.client.Gns().GetGnsByName(ctx, hashedName)
}

type barchildGnsTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

// GetBarChildrenByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) GetBarChildrenByName(ctx context.Context, hashedName string) (*GnsBarChildren, error) {
	result, err := group.client.baseClient.
		GnsTsmV1().
		BarChildrens().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &GnsBarChildren{
		client:      group.client,
		BarChildren: result,
	}, nil
}

// DeleteBarChildrenByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) DeleteBarChildrenByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GnsTsmV1().
		BarChildrens().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GnsTsmV1().
		BarChildrens().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/fooChildrenGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateBarChildrenByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GnsTsmV1) CreateBarChildrenByName(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.BarChildren) (*GnsBarChildren, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GnsTsmV1().
		BarChildrens().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"fooChildrenGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"BarChildren\", \"group\": \"gns.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GnsBarChildren{
		client:      group.client,
		BarChildren: result,
	}, nil
}

// UpdateBarChildrenByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GnsTsmV1) UpdateBarChildrenByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.BarChildren) (*GnsBarChildren, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GnsTsmV1().
			BarChildrens().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GnsTsmV1().
		BarChildrens().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GnsBarChildren{
		client:      group.client,
		BarChildren: result,
	}, nil
}

// ListBarChildrens returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GnsTsmV1) ListBarChildrens(ctx context.Context,
	opts metav1.ListOptions) (result []*GnsBarChildren, err error) {
	list, err := group.client.baseClient.GnsTsmV1().
		BarChildrens().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*GnsBarChildren, len(list.Items))
	for k, v := range list.Items {
		item := v
		result[k] = &GnsBarChildren{
			client:      group.client,
			BarChildren: &item,
		}
	}
	return
}

type GnsBarChildren struct {
	client *Clientset
	*basegnstsmtanzuvmwarecomv1.BarChildren
}

// Delete removes obj and all it's children from the database.
func (obj *GnsBarChildren) Delete(ctx context.Context) error {
	err := obj.client.Gns().DeleteBarChildrenByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.BarChildren = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GnsBarChildren) Update(ctx context.Context) error {
	result, err := obj.client.Gns().UpdateBarChildrenByName(ctx, obj.BarChildren)
	if err != nil {
		return err
	}
	obj.BarChildren = result.BarChildren
	return nil
}

func (obj *GnsBarChildren) GetParent(ctx context.Context) (result *GnsGns, err error) {
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnses.gns.tsm.tanzu.vmware.com"])
	return obj.client.Gns().GetGnsByName(ctx, hashedName)
}

type barchildrenGnsTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

// GetBarLinksByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) GetBarLinksByName(ctx context.Context, hashedName string) (*GnsBarLinks, error) {
	result, err := group.client.baseClient.
		GnsTsmV1().
		BarLinkses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &GnsBarLinks{
		client:   group.client,
		BarLinks: result,
	}, nil
}

// DeleteBarLinksByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) DeleteBarLinksByName(ctx context.Context, hashedName string) (err error) {

	err = group.client.baseClient.
		GnsTsmV1().
		BarLinkses().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateBarLinksByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GnsTsmV1) CreateBarLinksByName(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.BarLinks) (*GnsBarLinks, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GnsTsmV1().
		BarLinkses().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	return &GnsBarLinks{
		client:   group.client,
		BarLinks: result,
	}, nil
}

// UpdateBarLinksByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GnsTsmV1) UpdateBarLinksByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.BarLinks) (*GnsBarLinks, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GnsTsmV1().
			BarLinkses().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GnsTsmV1().
		BarLinkses().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GnsBarLinks{
		client:   group.client,
		BarLinks: result,
	}, nil
}

// ListBarLinkses returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GnsTsmV1) ListBarLinkses(ctx context.Context,
	opts metav1.ListOptions) (result []*GnsBarLinks, err error) {
	list, err := group.client.baseClient.GnsTsmV1().
		BarLinkses().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*GnsBarLinks, len(list.Items))
	for k, v := range list.Items {
		item := v
		result[k] = &GnsBarLinks{
			client:   group.client,
			BarLinks: &item,
		}
	}
	return
}

type GnsBarLinks struct {
	client *Clientset
	*basegnstsmtanzuvmwarecomv1.BarLinks
}

// Delete removes obj and all it's children from the database.
func (obj *GnsBarLinks) Delete(ctx context.Context) error {
	err := obj.client.Gns().DeleteBarLinksByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.BarLinks = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GnsBarLinks) Update(ctx context.Context) error {
	result, err := obj.client.Gns().UpdateBarLinksByName(ctx, obj.BarLinks)
	if err != nil {
		return err
	}
	obj.BarLinks = result.BarLinks
	return nil
}

// GetGnsBarLinks calculates the hashed name based on parents and displayName and
// returns given object
func (c *Clientset) GetGnsBarLinks(ctx context.Context, displayName string) (result *GnsBarLinks, err error) {
	hashedName := helper.GetHashedName("barlinkses.gns.tsm.tanzu.vmware.com", nil, displayName)
	return c.Gns().GetBarLinksByName(ctx, hashedName)
}

func (c *Clientset) GnsBarLinks(displayName string) *barlinksGnsTsmV1Chainer {
	parentLabels := make(map[string]string)
	parentLabels["barlinkses.gns.tsm.tanzu.vmware.com"] = displayName
	return &barlinksGnsTsmV1Chainer{
		client:       c,
		name:         displayName,
		parentLabels: parentLabels,
	}
}

// AddGnsBarLinks calculates hashed name of the object based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) AddGnsBarLinks(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.BarLinks) (result *GnsBarLinks, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.Gns().CreateBarLinksByName(ctx, objToCreate)
}

// DeleteGnsBarLinks calculates hashedName of object based on displayName and
// parents and deletes given object
func (c *Clientset) DeleteGnsBarLinks(ctx context.Context, displayName string) (err error) {
	hashedName := helper.GetHashedName("barlinkses.gns.tsm.tanzu.vmware.com", nil, displayName)
	return c.Gns().DeleteBarLinksByName(ctx, hashedName)
}

type barlinksGnsTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}
